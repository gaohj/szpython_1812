{"title": "微信小程序开发早知道 ", "author": "Rolan", "pub_time": "2019-4-4 00:24", "content": "小程序没有跳转公众号、跳转公众号图文素材的能力。除非用户通过扫描二维码进入小程序的情景，可以显示关注公众号组件。公众号菜单、公众号图文素材可以打开小程序，网页无法直接打开小程序。小程序内嵌网页、内嵌网页中跳转链接、iframe 嵌套的页面，都必须在安全域名内，否则无法访问。如果想在小程序内加入第三方广告，要注意这点，因为安全域名修改是有次数限制的，并要求验证服务器。还要注意网页中嵌套 iframe 的情况，例如，网页内嵌了腾讯视频 iframe，由于腾讯视频不在安全域名内，会造成页面无法访问。用户信息授权、手机号码授权需要用户通过点击操作。小程序间跳转需要用户点击操作，跳转前需要用户确认，可跳转小程序数量不超过10个。小程序分为开发版、体验版、审核版、线上版：开发版是开发工具编辑过的最新版本；开发工具上传后成为体验版，具备体验权限的用户都可以查看；将开发版提交给官方审核后，成为审核版；审核成功后，才可以发布成为线上版本。官方「小程序助手」小程序可以很方便打开各版本小程序。每次发布新版本，用户都需要重新下载新版本。小程序仍在不断更新和完善，旧代码可能会因不符合新政策，在下次发布的时候无法正常运行。为避免这种情况的发生，应多关注官方公告。版本回退功能可以将线上版本回退成上一个版本小程序使用 CommonJS 规范，对 ES6 有很好的支持小程序没有官方状态管理工具，页面间通讯靠 query string 传递参数。如果有复杂状态管理的需求的话，建议引入一些设计模式或使用第三方框架。用户微信支付后，需要后台推送消息到服务器，才能确认支付成功。小程序的 DOM 操作只能查询属性，无法设置属性。小程序基础库版本与微信版本有关， 基础库版本与客户端版本对应关系 。小程序也存在兼容性问题，对待不愿更新微信的用户，要像对待忠实的IE6用户一样， 小程序基础库版本分布 。小程序页面只有 onLoad、onShow、onReady、onHide、onUnload 生命周期，没有更新视图相关的生命周期小程序不能直接渲染 HTML string，要用 rich-text 组件，但组件使用 HTML string 性能会有所下降。小程序有很多原生组件，如 Vedio、Map。原生组件位于最上层，会遮挡所有非原生组件，还存在诸多限制，如无法改变大小、无法添加动画效果等等。不过，有些组件在最新版本已经可以同层渲染了。小程序不支持摇一摇功能，但可以通过监听加速度传感器来实现。小程序有官方的广告组件，广告收入官方会抽走一部分。想到再更，欢迎补充."}
{"title": "微信小程序ad自适应布局 ", "author": "Rolan", "pub_time": "2019-4-8 00:11", "content": "场景：微信小程序中添加广告，可以是微信广告和自定义广告的自适应布局；问题：微信广告在小屏（比如：320）手机上或是设置ad组件父组件宽度小于300px，内容会超出布局范围；截图效果：说明：可以从截图中看出，微信广告组件 ad 都自动添加了行内样式，而且其样式的权重都是最高的!imporant;解决办法：1) 百度的解决办法 是添加样式：ad {\r\n         zoom: 0.8;    \r\n    }百度方法效果截图：说明：从截图的效果可以看出，现在广告未超出父元素，但是没有100%在父元素中撑开；这种方法我用过，个人总结是： 当是使用场景宽度小于300px的时候，可以使用这种方法 。附：在微信开发者工具中审查元素，元素好像错位了，不过展示效果正常，这个就忽略吧，微信开发者工具还应该和我一样，继续努力啊~2) 我的解决办法：在微信广告组件父元素上添加弹性盒子布局；样式如下.ad-block {\r\n        width: 100%;\r\n        height: 100%;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n }效果截图：说明：从截图中可以看出，广告正常展示。使用ad（微信广告）需要注意的问题：1、问题：添加微信广告的小程序在正式上线后微信广告不会正常展示，在开发版本和体验版本微信却展示正常；微信社区解释是 ： 开发者首次提交广告组件审核，线上版本的告功能将暂时关闭，我们会在一个工作日完成广告组件合规性审核 。2、问题：添加微信广告的小程序在正式上线并且通过审查后，如果有除了纯展示的其他需求，比如：需要点击观看广告6秒才能领取奖励。如果是微信广告，一天点击几次后，微信广告不会正常展示；解释： 当前用户没有展示广告可能是由于该用户当前不适合浏览广告 ；解决办法：通过在 ad 的广告发生错误的回调binderror可以做对应的处理。我所接的需求是：当微信广告展示不出来的时候，就展示自定义广告，通过binderror这个回调函数就可以实现这个需求。注意：广告加载成功的回调bindload，页面每次重新渲染并且广告加载成功的话都会执行这个回调。附：社区中的官方解释我暂时没有找到，后期如果我找到了，再附上链接地址。*随记：今天是4月7号，清明就剩一天咯。已踏青，已出游，该静一下咯。*"}
{"title": "微信小程序低功耗蓝牙踩坑二 ", "author": "Rolan", "pub_time": "2019-4-8 00:25", "content": "今天分享的是踩第二个坑。小程序对应安卓手机支持性是比较差的，所有很多安卓手机出现了连接一次就断开的情况，自己也去小程序官社区去查了一下，很多开发者用户在上面反馈了安卓手机连接过慢的情况，于是我顺便开始进行第二个坑。小程序对低功耗蓝牙对安卓手机的连接支持不好问题 这个问题困扰了我很久，一直也是睡不好.......................................................,在此处省略无数草泥马， 安卓手机在连接之后，再次去连接，基本上连接不上，这样出现的概率基本为70%以上，现在这就是面临的一个问题。 于是..............作死的去贴吧，百度，小程序社区，直到测试小姐姐，测试小姐姐特别的热情跟我说，一定要退出小程序，或者杀死小程序，才能再次连接上，于是我就开了我猜测（蓝牙厂商跟我说过，连接蓝牙开启设备之后，然后再关闭设备，下一次才能连接上，我看了一下源码，是真的，果真在结束蓝牙连接设备之后，没有断开）。 于是我用了这样的方案来解决这个问题。思路 蓝牙连接失败,就再次连接一次，每一次连接之前执行关闭蓝牙,还得判断蓝牙状态是否在开启中，一直连接三次，三次失败之后，返回首页，重新开始。"}
{"title": "踩坑小程序之can't read property 'offsetLeft' of undefined ", "author": "Rolan", "pub_time": "2019-4-3 00:23", "content": "↑开局一张图，故事全靠编↑从一个需求说起接触过小程序的同学应该都接触过这样一个需求：点击列表页的某一项，进入详情页。同样，今天我也遇到这样一个需求，其实很简单的一个需求，无非就是一个tap事件加dataset传参实现路由带参数跳转到详情页。以前开发小程序的时候，也处理过这样的需求，本来应该是得心应手的。不过，可能是Copy别人代码Copy得太多太久太深，也从来没自主去想过别人为什么这样写、换种方式要怎样写、为什么换种方式就会报错等等诸如此类的问题，更别说去熟读开源源码，甚至自己造轮子。有时候反思，自己入行这么多年了，资质依旧平平，别说造轮子，就算是把别人轮子拿过来安上，都能整出一堆B.U.G。就比如开头的图片上，用的是鹅厂旗下某著名公司的豪华套餐，居然被我用得翻车了！-- TypeError: Cannot read property 'offsetLeft' of undefined !!! 简直了，还是只能怪自己技术太low了。（图片来源于网络）提问的智慧自从朋友给了我一个SS的IP和密码，现在我一有问题就是直接google开干。在我看来，与其把问题抛到各种广告满天飞的技术群或者丢给朋友圈里边的大佬，倒不如自己先动手解决，哪怕是尝试了所有的答案，至少对问题会有更深的理解，以后面试中遇到面试官问您在项目中遇到过什么问题之类的，因为经过自己的一番搜索加实践，一般印象会深刻很多。反而别人直接告诉您答案的，可能您的成本更小，但是收获甚微。根据以往的经验，遇到问题，自己动手，是更接近答案的唯一出路。或许您在开发中，遇到了某些问题，您通过一些途径解决了这个问题，然后，您又记录了下来，后续您遇到同样的问题，应该是可以迎刃而解的。如果您还把解决方案分享出来了，您简直是在造福人类。后来者，托您的福，更快的解决了同样的问题。尝试方案1--重启开发者工具can't read property 'offsetLeft' of undefined #1132这是来自全球最大的同性交友网站GitHub上的一个issue，是由@yuwanlin 在一套遵循 React 语法规范的多端统一开发框架 Taro 中提出来的。根据当时的情境，是在微信开发者工具中删掉该小程序然后重新载入就解决了，大家给出的结论是微信小程序开发者工具的B.U.G。(注：该操作不会删除文件，请放心使用)--但是，我按照楼主的说法操作了一遍，结果然并卵，还是原来的B.U.G，还是一样的报错。该方案失败尝试方案2--外层加view自定义组件在首次点击后会报错@欧新志 这个小咯咯在2018-06-14向微信社区提出了类似的问题，他那个是自定义组件在点击之后出现了和我同款的B.U.G，而且也是存在嵌套子组件。评论中各位大神给出的答案是嵌套view。我也尝试了，试着加了一层view，但是问题依旧存在。不过我感还是和嵌套的子组件有关。于是，我各种尝试终于找到了一个方案。第一次滚动和点击的时候都有这个报错,下面是报错时的组件wxml<view class=\"wraper\" bindtap=\"onClick\"><slot></slot></view>如果换成下面这样就不报错了<view><view class=\"wraper\" bindtap=\"onClick\"><slot></slot></view></view>解决方案3--tap事件加在子组件里面原代码：<block wx:for=\"{{itemList}}\" wx:key=\"key\" wx:code=\"{{item}}\">\r\n      <view style=\"margin-top: 15px\" bindtap=\"toDetail\">\r\n        <dgd-preview>\r\n          <!--常规 preview-list 控件  -->\r\n          <view class=\"dgd-preview-list\"  data-item=\"{{item}}\">\r\n            <dgd-preview-item label=\"服务中心名称\" style=\"color:#000;\">\r\n              {{item.name}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约业务\" style=\"color:#000;\">\r\n              {{item.business}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约时间\" style=\"color:#000;\">\r\n              {{item.time}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约状态\" style=\"color:#000;\">\r\n              {{item.status}}\r\n            </dgd-preview-item>\r\n          </view>\r\n        </dgd-preview>\r\n      </view>\r\n    </block>修改之后：<block wx:for=\"{{itemList}}\" wx:key=\"key\" wx:code=\"{{item}}\">\r\n      <view style=\"margin-top: 15px\">\r\n        <dgd-preview>\r\n          <!--常规 preview-list 控件  -->\r\n          <view class=\"dgd-preview-list\" bindtap=\"toDetail\" data-item=\"{{item}}\">\r\n            <dgd-preview-item label=\"服务中心名称\" style=\"color:#000;\">\r\n              {{item.name}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约业务\" style=\"color:#000;\">\r\n              {{item.business}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约时间\" style=\"color:#000;\">\r\n              {{item.time}}\r\n            </dgd-preview-item>\r\n            <dgd-preview-item label=\"预约状态\" style=\"color:#000;\">\r\n              {{item.status}}\r\n            </dgd-preview-item>\r\n          </view>\r\n        </dgd-preview>\r\n      </view>\r\n    </block>只是把方法挂载到了不同的位置，确实截然不同的效果。看来接下来应该再研究一下小程序的组件。"}
{"title": "微信小程序npm安装第三方包（引用第三方插件avtv f2.js） ", "author": "Rolan", "pub_time": "2019-4-2 00:41", "content": "由于我要使用微信小程序引用图标插件，就以AntV F2插件为例；AntV F2官网：https://antv.alipay.com/zh-cn...需要准备：微信开发工具（必须支持npm功能）; node.js安装； npm基础知识；以下操作是node.js已经安装过了。1、先建好小程序模版。比如下图：然后使用dos命令打开这个当前的文件夹。比如下图：注意：dos命令打开的是小程序文件夹所放的路径。2、初始化指令如果是该文件夹第一次使用： 请先使用指令npm init(初始化指令);如下图：如果出现这种情况就对了，进行对这个文件夹进行编辑，也可以全部点击回车键，一路回车；3、再次安装npm install --production建议使用--production选项，可以减少安装一些业务无关的 npm 包，从而减少整个小程序包的大小如下图：4、安装微信小程序 F2 图表组件*npm i @antv/f2-canvas如下图：恭喜你，操作完以上这几步已经安装好依赖包。5、安装好依赖包之后，打开微信开发工具点击开发者工具顶部详情，勾选 使用npm模块，再点击菜单栏中工具下的构建npm即可运行操作图第一步：点击详情，勾选npm模块操作图第二步：工具菜单栏打开，点击构建npm点击构建npm后，会出现：完成后会出现：一个文件夹为miniprogram_npm恭喜自己吧，npm安装第三方包已经完成；以下就是在小程序中代码的撰写：1.index.json;2.index.wxml;3.index.wxss;#myCanvas {\r\n  width: 100%;\r\n  height: 300px;\r\n}\r\n4.index.js;let chart = null;\r\nfunction initChart(canvas, width, height, F2) {\r\n  const data = [\r\n    { year: '1951 年', sales: 38 },\r\n    { year: '1952 年', sales: 52 },\r\n    { year: '1956 年', sales: 61 },\r\n    { year: '1957 年', sales: 145 },\r\n    { year: '1958 年', sales: 48 },\r\n    { year: '1959 年', sales: 38 },\r\n    { year: '1960 年', sales: 38 },\r\n    { year: '1962 年', sales: 38 },\r\n  ];\r\n  chart = new F2.Chart({\r\n    el: canvas,\r\n    width,\r\n    height\r\n  });\r\n\r\n  chart.source(data, {\r\n    sales: {\r\n      tickCount: 5\r\n    }\r\n  });\r\n  chart.tooltip({\r\n    showItemMarker: false,\r\n    onShow(ev) {\r\n      const { items } = ev;\r\n      items[0].name = null;\r\n      items[0].name = items[0].title;\r\n      items[0].value = '$ ' + items[0].value;\r\n    }\r\n  });\r\n  chart.interval().position('year*sales');\r\n  chart.render();\r\n  return chart;\r\n}\r\nPage({\r\n  data: {\r\n    opts: {\r\n      onInit: initChart\r\n    }\r\n  },\r\n  onLoad(){\r\n  },\r\n  onReady() {\r\n  }\r\n})\r\n看右侧是不是已经出来柱形图了，如果需要做其他图表，去官网让选择就行了，官网的例子比较多，选择做自己需要的就行了。"}
{"title": "小程序渲染架构设计 ", "author": "Rolan", "pub_time": "2019-4-3 00:34", "content": "One 什么是小程序\r\nⅠ 小程序概念\r\n微信小程序算是小程序的鼻祖了，2017年1月9日微信正式上线了小程序。在探究小程序技术架构之前，我们先看看小程序究竟是什么，微信官网对微信小程序的产品定位及功能介绍是：\r\n“微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。”\r\n这个介绍有种看了跟没看一样的感觉。网上对于微信小程序是什么还有一个介绍的版本：\r\n“小程序是一种不需要下载安装即可使用的应用，它实现了应用「触手可及」的梦想，用户扫一扫或搜一下即可打开应用。也体现了「用完即走」的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。”\r\n这个概念就更清晰一些，可以看出小程序是众多实例运行在一个宿主应用中，小程序本身也是一种可插拔的外接应用。\r\nⅡ 用户角度的小程序\r\n下面从用户使用交互角度来看一下小程序：\r\n\r\n（图1）\r\niOS：从小程序独立性角度（小程序与小程序之间，小程序与宿主应用之间切换）来说，BATT 的小程序与招商银行的小程序基本交互相似。\r\nAndroid：从交互上来看BATT 的小程序都可以看做是独立的应用程序，独立存在于后台（多进程），可以在小程序与小程序之间，小程序与宿主应用之间切换。可以直观的理解为这类小程序为小程序应用。招商银行的的小程序是与宿主应用共存的，也就是在一个进程中，不能在小程序与小程序之间，小程序与宿主应用之间切换。这类小程序可以直观的理解为小程序页面。\r\n\r\nBATT: 微信，支付宝，头条，百度小程序。由于交互相似，所以并称。\r\n\r\n所以，从用户使用角度来看，BATT的交互体验更有优势。从对小程序概念的理解来看，各app理解有所差异，但这并不影响功能层面的使用。\r\nⅢ 平台角度的小程序\r\n最早应用小程序的微信为什么会创造出小程序这个东西呢？它到底有什么作用？在我看来，主要目的还是在于管控为目的，使用了多个手段来实现，主要管控在于两个方面：\r\nUI管控：以微信为例，微信自己定义了一套DSL，而不是用HTML来开发页面。这样就不能让开发者随意开发，而是在微信的DSL框架中开发。开发者写的DSL具体转换成什么，是通过什么渲染，都是微信平台来决定。基于自定义的这套DSL，可以更好的做代码管控方面的工作，比如：请求白名单，代码扫描等。\r\n服务管控：还是以微信为例，微信中的宿主平台提供的服务（比如：支付，微信运动，卡券，发票，用户账号信息等）对于无论是二方使用者还是三方使用者，都有权限管控的需求。目的也是不能让接入的小程序，在没有授权机制的前提下，随意调用微信基础服务。\r\nTwo 小程序技术架构\r\n基于从用户角度的体验需求，以及平台角度的管控需求，我们来看看BATT系小程序在技术上做了哪些达到了这些目的。\r\nⅠ 渲染流程\r\n下图是小程序的渲染流程，里面包含了部分技术选型，后面的部分会提到：\r\n\r\n(图2)\r\nⅡ 主要技术点\r\n\r\nDSL(Domain-specific language)：\r\n\r\n在我们聊DSL之前，我们先看看编译代码需要做哪些工作。无论是解释性语言（JS，Ruby，Python）还是编译型语言（Java，C++，C#），都会有一个共同的部分，将源代码解析为AST(抽象语法树)。AST不仅能够以结构化的方式呈现源代码，而且在语义分析中起到关键作用。AST不仅仅应用在解释器和编译器，而且在静态代码分析中也比较常用，比如：我们在重构代码的时候，希望提取出公共模块，以便减少重复代码方便复用。这时我们单纯的用字符串比对的方式会比较片面不能达到效果，这时生成AST就比较有用。另一个应用例子对于我们的DSL设计会比较有借鉴意义：代码转换器。下图是一种语言代码转换为另一种语言代码的主要步骤：\r\n\r\n（图3：图片来源于网络）\r\n源代码先解析成AST，解析之前它是遵循语言规则的文本，解析之后成为与输入文本完全相同的树形结构，这个过程是可逆的。然后再对AST遍历以及替换，这个过程对于前端来说类似于DOM树的生成，最后根据修改后的AST生成编译后的代码。我们以JS为例，用acorn生成的AST，同样我们也可以使用其他的解析器，例如：babylon，esprima等，下面是一个简单的例子（限于篇幅，右侧的AST树没有完全展开，读者可以到astexplorer上生成结果）：\r\n\r\n（图4）\r\n由于小程序的渲染容器有可能是Webview容器，原生Native容器，Flutter容器（虽然Flutter也是Native渲染，为了与原生Native区别，这里把它单独出来，下同），所以我们可以借鉴前面的代码转换器的思路，用AST抹平具体渲染容器的区别，下图是DSL转换的整体思路：\r\n\r\n（图5）\r\n有了以上的的设计并不是大功告成，还需要有很多需要做的工作要做。我们可以简单的把DSL的处理分为编译时和运行时，编译时负责把DSL代码预编译为目标代码，目标代码可以在相应的运行时环境执行。生成的目标代码的作用是，可以在具体的运行时通过当前环境的参数来执行出实际的代码，简单的理解就是为了在多渲染环境运行的一个适配器。\r\n对于编译时来说，从零写起肯定是不现实的。首先我们继续上面AST的话题，上面已经提到了几个AST的解析器：acorn，babylon，esprima。当然还有很多其他的例如：cherow，espree，shift等。所以我们不用再造一个轮子，下面用babylon举例，因为babylon在babel中使用，会与最近的JS功能同步，并且API设计良好易于使用。babel是js编译器（并不仅仅是ES6支持的工具包，否则就变成了类似于Android里面的support包了），可以用于代码压缩，语法转换等。对于生成目标代码的过程：解析（babylon），转换（babel-traverse）都有很好的支持。由于不同的渲染容器有不同的组件库和API，同样功能的组件或API的使用也不尽相同，所以需要封装出适配层代码。\r\n对于运行时来说，只需要把编译生成的适配代码生成具体渲染环境的代码执行就可以了。这里比较类似babel把ECMAScript新版代码转换成旧版代码的逻辑比较像。\r\n\r\nNative渲染\r\n\r\n从性能角度出发，把小程序最终通过Native方式渲染会比用Webview作为渲染容器得到更好的效果。DSL的设计可以很好的屏蔽底层实际渲染的实现，可以用Native，也可以用H5，也可以使用两者结合的方式，底层渲染引擎的切换也不会影响到小程序开发者的外部接入。目前移动端跨平台Native渲染的技术非常流行，比较常用的有Weex/RN/Flutter。市场上有基于Weex和RN进行小程序的案例，Flutter毕竟是后起之秀，目前还没有见到用Flutter作为渲染引擎的案例。\r\n\r\nAndroid多进程：\r\n\r\n前面我们在从“用户角度的小程序”部分看到，BATT的方案让小程序真正可以做到像应用一样的体验。由于iOS应用无法开启新进程让小程序本身在独立进程中运行，所以iOS中的小程序只能与宿主应用共享同一进程。对于Android来说就不一样了，小程序占用独立进程，从安全角度来说，二方后者三方的小程序应用与宿主应用进程隔离，小程序出现的问题不会影响宿主应用。而且，从性能角度来说，小程序不会共享宿主应用的内存。从BATT的小程序实际应用操作来看，基本都会控制五个后台开启的进程保活，可以用五个容器Activity各自在自己的进程中渲染小程序，有的还会有后台的保活时间限制。再开启新的小程序，会关闭最早打开的小程序进程，这样达到了高效热启动的目标。\r\n\r\n多线程：\r\n\r\n逻辑渲染隔离：\r\n首先，在聊具体的多线程之前，先说一下小程序的逻辑和渲染的问题。小程序的逻辑和渲染是分离的，当然从功能层面，不分离一样可以实现。这里说的逻辑和渲染分离是指小程序的逻辑运行在单独JS环境的线程中，只需要JS引擎就可以，渲染运行在Webview线程中。逻辑和渲染分离到两个线程有几点好处：第一个是可以逻辑和渲染代码分离没有耦合，第二个是可以让逻辑线程和渲染线程并行执行，JS执行不会阻塞UI。第三是补充了前面所说的UI管控的目的，逻辑线程里面JS在JS引擎中运行，而不是在Webview里面，这样就限制了通过注入JS代码来操作dom的可能，任何与UI相关的API都没有办法通过JS来改变，这样就与DSL一起达到了UI管控的目的。第四个好处是多个小程序页面共享同一个JS逻辑运行环境，可以方便高效的共享数据。\r\n\r\n（图6）\r\n上图展示了逻辑层与视图层的通信过程，通信通过Bridge中转，利用发布/订阅模式。视图层通过触发UI事件，会把事件通过bridge传递到Native，Native再通过bridge把事件中转给逻辑层，逻辑层处理事件完成后，把数据再通过bridge传递到Native，之后再由bridge返回给视图层做渲染。\r\n优化：\r\n逻辑和渲染分离之后，逻辑线程需要把数据发送给渲染线程，渲染线程需要把事件发送给逻辑线程，这都需要序列化为字符串进行传输。这样会带来一个问题，频繁的数据传输，和单次大数据量传输都会带来性能问题。针对这个问题，支付宝小程序的设计思路比较值得借鉴，支付宝小程序重新设计了V8虚拟机，让逻辑和渲染都有自己的Local Runtime，存放私有的模块和数据。又提供了共享的Global Runtime的Shared Heap来共享数据，这样依然保证了逻辑和渲染的隔离，又减少了序列化和传输成本。\r\n\r\n预加载：\r\n\r\n小程序的开发者在小程序应用方面，做了很多优化，比如：数据的预加载。从用户点击页面，到新页面onload()，会延迟100ms-300ms，这个延迟时间，可以做数据的预加载。这里所说的小程序启动预加载，是小程序渲染框架层面的。iOS的优化会预加载比实际渲染小程序数多一个wkwebview放在后台，打开新的小程序会直接把预先加载的wkwebview直接渲染，节省了初始化时间；Android上实现稍微复杂一点，不过依然是空间换时间的思路，从Android宿主应用启动开始，就会启动一个预留进程，当开启新的小程序，会占用这个进程，并再预加载新的进程，直到开启第五个进程的上限。\r\n\r\n离线包（分包）：\r\n\r\n离线包机制的根本目的在于让小程序打开的时候，可以让页面资源从网络IO替换为本地IO。其实就是在app打开之前从网络拉取或者推拉结合，预置等方式让离线包可以在打开小程序之前就已经在本地了。离线包模块的职责包括：更新，解压，存储，读取和校验等，当然也可以做二进制的差量包以。有了离线包机制，也要考虑把整个小程序整体作为一个离线包会影响效率的问题，所以这里需要增加分包的方案，可以把离线包分为一个主包和多个子包的形式，主包里面主要包括：首屏资源，公共代码，相关子包的信息等；子包可以包含二级页面的页面资源。这样就可以提高首屏打开速度，可以做到按需加载的目的，如下图：\r\n\r\n（图7）\r\nⅢ 技术选型\r\n\r\nIDE\r\n\r\n小程序平台都有自己的IDE，对于多系统平台的现状，选取跨平台桌面技术开发小程序IDE，肯定是最好的选择，这里选择了Electron和NW.JS做了一下对比：\r\n\r\n（图8）\r\n对比结果简单的说，两者开源协议都比较友好，如果重视代码安全性或者兼容XP需求，就选择NW.JS，也是国内厂商的选择；如果从开发支持角度来比较，就选择Electron。\r\n\r\nJS引擎\r\n\r\n前面已经说了，逻辑层具有单独的JS环境，也从管控角度说明了这样做也可以防止js修改UI的风险。就技术选型角度来说，iOS可以使用自带的JScore，虽然iOS上wkwebview的JS引擎比JScore多了JIT优化，执行速度快很多，但是比起额外引入js引擎来说，使用自带js引擎具有稳定且不增加包大小的先天优势。这块可能有人会提到Flutter在iOS里面引入了skia渲染引擎的问题，Flutter在iOS引入skia的好处是与Android自带的skia引擎使用相同渲染引擎，这样会在UI兼容性上有更好的提升。而js引擎兼容性问题就小的多。\r\nAndroid方面，可选择性多一下，以下是一个主流JS引擎对比：\r\n\r\n（图9）\r\n微信小程序旧版本用的JScore，新版本用的V8；支付宝小程序用的重新设计的V8；头条小程序也是使用的V8；可以看到V8的中标率还是很高的，而且开源协议也比较友好。\r\nThree 结语\r\n本文算是介绍了一种小程序渲染架构的一种实现方式，就小程序平台本身来说，还有一些其他的功能和优化点，比如：小程序路由，Debug包加载，埋点统计，虚拟Dom的优化等。文章只是介绍了一些主要流程和技术点，真正做一个完善的小程序平台还是需要很多细节需要考虑的，就小程序开发者的角度来说，也是有优化空间的，比如：骨架屏。做一个小程序平台需要多平台多种技术能力的综合应用才能不断完善，随着新技术的涌现，未来会有更多的技术应用到小程序中。"}
{"title": "小程序自定义导航栏适配（完美版） ", "author": "Rolan", "pub_time": "2019-4-2 00:27", "content": "1、发现问题小程序页面自定义导航栏功能已经开放有些日子了(还不知道这个功能的可以先 >>了解一下 )，这极大的提升了小程序开发的自由度，相信不少小伙伴已经使用过这个功能，同时也相信不少小伙伴在此功能开发过程中踩过同样的一些坑：机型多如牛毛：自定义导航栏高度在不同机型始终无法达到视觉上的统一；调皮的胶囊按钮：导航栏元素（文字，图标等）怎么也对不齐那该死的胶囊按钮；各种尺寸的全面屏，奇怪的刘海屏，简直要抓狂。同样的，这些问题也是小灰经历过的。但是小灰相信，办法总比问题多，于是开始了自己的探究：2、一探究竟为了搞明白到底该怎么去适配，老规矩，我先翻了一波官方文档，还别说，官方还真有这么一段介绍了相关细节， >>详情点击 ：从图中分析，我们可以得到如下信息：Android跟iOS有差异，表现在顶部到胶囊按钮之间的距离差了6pt胶囊按钮高度为32pt， iOS和Android一致这。。。，好像并没有什么L用啊？？这仅仅是普通屏幕为参照的，ipx， 安卓全面屏完全没介绍。沉着冷静，我们接着分析：胶囊按钮到状态栏下边缘这块距离，好像是固定的？安卓这个图，好像有点奇怪？导航栏分为 状态栏+标题栏？如果车两个条件成立，那我们的问题是不是就解决了80%了？那么我们来论证一下：第一个问题：胶囊按钮到状态栏下边缘的距离是不是固定的？很简单，我们写一个状态栏，通过wx.getSystemInfoSync().statusBarHeight设置高度为了好测量，我们设置状态栏背景色为深色js代码：var sysinfo = wx.getSystemInfoSync();\r\nthis.setData({ \r\n     statusBarHeight:sysinfo.statusBarHeight \r\n})wxml代码：<view class=\"status-bar\" style=\"height:{{statusBarHeight}}px\"></view>wxss代码：.status-bar{\r\n    background: rgb(141, 71, 71);\r\n }效果图（iPhone6）：效果图（iPhoneX）：效果图（安卓）：是不是有点眉目了？是的，从截图可以看出，iOS是一致的，但是Android好像有所差别。那究竟距离是多少？我们用神器（微信截图）来量一量：Android：iOS：可以看出，iOS胶囊按钮与状态栏之间距离为：6px， Android为8px，并且经过测量，iOS各机型，Android各机型结果一致（由于篇幅原因，就不一一展示截图了，有兴趣的可以自行测量）第二个问题：导航栏分为 状态栏+标题栏？通过对第一个问题的论证，很明显能看出来确实是这样的。并且通过第一个问题的测量结果以及官方提供的数据，我们可以对标题栏高度进行计算：导航栏高度 = 胶囊按钮高度 + 状态栏到胶囊按钮间距 * 2Android导航栏高度 = 32px + 8px * 2 = 48pxiOS导航栏高度 = 32px + 6px * 2 = 44px*注：由于胶囊按钮是原生组件，为表现一直，其单位在个系统都为px，所以我们的自定义导航栏各个高度的单位都必需是px（切记不能用rpx），才能完美适配。3、解决问题通过上述分析，相信小伙伴们都能有一个解决问题的思路了，在上代码之前，小灰再给大家画一下重点：写自定义导航组件的时候，需要将组件结构一分为二：状态栏 + 标题栏状态栏高度可通过wx.getSystemInfoSync().statusBarHeight获取标题栏高度：安卓：48px，iOS：44px单位必需跟胶囊按钮一致，用px话不多说，上代码( gitHub地址 )：js：Component({   \r\n   properties: {        \r\n    background: {            \r\n        type: String,            \r\n        value: 'rgba(255, 255, 255, 1)'        \r\n    },        \r\n    color: {            \r\n        type: String,            \r\n        value: 'rgba(0, 0, 0, 1)'        \r\n    },        \r\n    titleText: {            \r\n        type: String,            \r\n        value: '导航栏'        \r\n    },        \r\n    titleImg: {            \r\n        type: String,            \r\n        value: ''        \r\n    },        \r\n    backIcon: {            \r\n        type: String,            \r\n        value: ''        \r\n     },        \r\n    homeIcon: {            \r\n        type: String,            \r\n        value: ''        \r\n    },        \r\n    fontSize: {            \r\n        type: Number,            \r\n        value: 16        \r\n    },        \r\n    iconHeight: {            \r\n        type: Number,            \r\n        value: 19       \r\n    },        \r\n    iconWidth: {            \r\n        type:Number,            \r\n        value: 58        \r\n    }    \r\n   },    \r\nattached: function(){        \r\n   var that = this;        \r\n   that.setNavSize();        \r\n   that.setStyle();    \r\n},    \r\n data: {\r\n    },    \r\nmethods: {        \r\n// 通过获取系统信息计算导航栏高度        \r\nsetNavSize: function() {            \r\nvar that = this                \r\n    , sysinfo = wx.getSystemInfoSync()                \r\n    , statusHeight = sysinfo.statusBarHeight                \r\n    , isiOS = sysinfo.system.indexOf('iOS') > -1                \r\n    , navHeight;            \r\nif (!isiOS) {                \r\n    navHeight = 48;            \r\n   } else {                \r\n    navHeight = 44;            \r\n}            \r\nthat.setData({                \r\n    status: statusHeight,                \r\n    navHeight: navHeight            \r\n  })        \r\n},        \r\nsetStyle: function() {            \r\n    var that  = this                \r\n    , containerStyle                \r\n    , textStyle                \r\n    , iconStyle;            \r\n    containerStyle = [                \r\n        'background:' + that.data.background                \r\n        ].join(';');            \r\n        textStyle = [                \r\n        'color:' + that.data.color,                \r\n        'font-size:' + that.data.fontSize + 'px'            \r\n        ].join(';');            \r\n        iconStyle = [                \r\n        'width: ' + that.data.iconWidth + 'px',                \r\n        'height: ' + that.data.iconHeight + 'px'            \r\n        ].join(';');            \r\n        that.setData({               \r\n             containerStyle: containerStyle,                \r\n             textStyle: textStyle,                \r\n             iconStyle: iconStyle            \r\n        })        },        \r\n        // 返回事件        \r\nback: function(){            \r\n    wx.navigateBack({                \r\n        delta: 1            \r\n    })            \r\n    this.triggerEvent('back', {back: 1})        \r\n},        \r\nhome: function() {            \r\n    this.triggerEvent('home', {});       \r\n }   \r\n }})wxml：<view class='nav' style='height: {{status + navHeight}}px'>    \r\n    <view class='status' style='height: {{status}}px;{{containerStyle}}'></view>                               <view class='navbar' style='height:{{navHeight}}px;{{containerStyle}}'>        <view class='back-icon' wx:if=\"{{backIcon}}\" bindtap='back'>                    <image src='{{backIcon}}'></image>       \r\n         </view>        \r\n    <view class='home-icon' wx:if=\"{{homeIcon}}\" bindtap='home'>            \r\n        <image src='{{homeIcon}}'></image>        \r\n    </view>        [链接描述][10]\r\n    <view class='nav-icon' wx:if=\"{{titleImg}}\">            \r\n    <image src='{{titleImg}}' style='{{iconStyle}}'></image>       \r\n     </view>\r\n            <view class='nav-title' wx:if=\"{{titleText && !titleImg}}\">\r\n                <text style='{{textStyle}}'>{{titleText}}</text>\r\n            </view>\r\n        </view>\r\n    </view>wxss：.navbar{\r\n    position: relative\r\n}\r\n.back-icon, .home-icon{\r\n    width: 28px;\r\n    height: 100%;\r\n    position: absolute;    \r\n    transform: translateY(-50%);    \r\n    top: 50%;    \r\n    display: flex;\r\n    }\r\n.back-icon{    \r\n    left: 16px;\r\n}\r\n.home-icon{    \r\n    left: 44px\r\n}\r\n.back-icon image{    \r\n    width: 28px;    \r\n    height: 28px;    \r\n    margin: auto;\r\n}\r\n.home-icon image{    \r\n    width: 20px;    \r\n    height: 20px;    \r\n    margin: auto;\r\n}\r\n.nav-title, .nav-icon{    \r\n    position: absolute;    \r\n    transform: translate(-50%, -50%);    \r\n    left: 50%;    \r\n    top: 50%;    \r\n    font-size: 0;    \r\n    font-weight: bold;\r\n}运行效果图：文字标题：图片标题：4、总结经过小灰的一番论证以及实践经验，最终总结出以上最终解决方案，但希望对小伙伴们有所帮助，如果小伙伴们觉得有用，记得给颗star哦 --> 点我 ，后续还会更新其他组件。如果大家有更好的方案或者觉得小灰的方案有问题，欢迎大家留言。"}
{"title": "我们用5分钟写了一个跨多端项目 ", "author": "Rolan", "pub_time": "2019-4-3 00:13", "content": "cml 作为真正让一套代码运行多端的框架，提供标准的MVVM模式，统一开发各类终端。同时，拥有各端独立的 运行时框架(runtime) 、 数据管理(store) 、 组件库(ui) 、 接口(api)。此外， cml 在跨端 能力加强 、 能力统一 、 表现一致 等方面做了许多工作。今天，为了让大家的项目优雅升级，快速接入，给你带来一份丰盛的 cml迁移指南 ~源码地址： github.com/jalonjs/cml…目录结构和微信小程序一样， cml 包含一个描述整体程序的 app 和多个描述各自页面的 page 。小程序目录结构.\r\n├── components // 包含各个组件\r\n├── pages // 包含各个页面\r\n├── app.js // 包含各个组件\r\n├── app.js  // 应用启动入口\r\n├── app.json // 全局配置\r\n├── app.wxss // 全局样式\r\n└── project.config.json // 项目配置文件\r\n\r\n复制代码cml目录结构.\r\n├── dist // 各个端构建结果\r\n│   ├── alipay \r\n│   ├── baidu \r\n│   ├── wx \r\n│   ├── web  \r\n│   ├── weex \r\n│   └── config.json // 跨端配置map映射表\r\n├── node_modules // 第三方库\r\n├── mock // 模拟 接口数据 和 模板数据\r\n├── src  // 源代码开发目录\r\n│   ├── app // 应用启动入口\r\n│   ├── assets // 静态资源\r\n│   ├── components // 包含组件\r\n│   ├── pages  // 包含页面\r\n│   ├── store //数据管理\r\n│   └── router.config.json // 路由配置文件\r\n├── chameleon.config.js // 项目配置文件\r\n└── package.json // npm包配置文件\r\n\r\n复制代码如何修改配置在小程序项目里面，分为：可以在项目根目录使用 project.config.json 文件对项目进行配置。配置示例：{\r\n  \"miniprogramRoot\": \"./src\",\r\n  \"debugOptions\": {}\r\n}\r\n复制代码小程序根目录下的 app.json 文件用来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等配置示例：{\r\n  \"pages\": [\"pages/index/index\", \"pages/logs/index\"],\r\n  \"window\": {\r\n    \"navigationBarTitleText\": \"Demo\"\r\n  },\r\n  \"networkTimeout\": {\r\n    \"request\": 10000,\r\n    \"downloadFile\": 10000\r\n  }\r\n}\r\n复制代码每一个小程序页面也可以使用 .json 文件来对本页面的窗口表现进行配置。页面的配置只能设置 app.json 中部分 window 配置项的内容，页面中配置项会覆盖 app.json的 window 中相同的配置项。配置示例：{\r\n  \"navigationBarBackgroundColor\": \"#ffffff\",\r\n  \"navigationBarTextStyle\": \"black\",\r\n  \"navigationBarTitleText\": \"微信接口功能演示\",\r\n  \"backgroundColor\": \"#eeeeee\",\r\n  \"backgroundTextStyle\": \"light\"\r\n}\r\n复制代码同样，在 cml 项目里面，分为：cml —— 项目配置chameleon.config.js 为项目的配置文件，你可以定制化构建，比如是否带hash，是否压缩等等。配置示例：// 设置静态资源的线上路径\r\nconst publicPath = '//www.static.chameleon.com/static';\r\n// 设置api请求前缀\r\nconst apiPrefix = 'https://api.chameleon.com';\r\n// 合并配置\r\ncml.config.merge({\r\n  wx: {\r\n    build: {apiPrefix}\r\n  },\r\n  alipay: {\r\n    build: {apiPrefix}\r\n  },\r\n  baidu: {\r\n    build: {apiPrefix}\r\n  },\r\n  web: {\r\n    dev: {\r\n      hot: true,\r\n      console: true\r\n    },\r\n    build: {\r\n      publicPath: `${publicPath}/web`,\r\n      apiPrefix\r\n    }\r\n  },\r\n  weex: {\r\n    build: {\r\n      publicPath: `${publicPath}/weex`,\r\n      apiPrefix\r\n    }\r\n  }\r\n})\r\n\r\n复制代码cml —— 全局配置cml 项目 app 目录下的 app.cml 文件的 <script cml-type=\"json\" /> 用来对 cml 应用 进行全局配置，具有 跨端配置 和 差异化 的能力配置示例：<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n    \"window\": {\r\n      \"navigationBarTitleText\": \"各个端共同title\",\r\n    },\r\n    \"permission\": {\r\n      \"scope.userLocation\": {\r\n        \"desc\": \"你的位置信息将用于小程序位置接口的效果展示\"\r\n      }\r\n    }\r\n  },\r\n  \"wx\": {\r\n    \"window\": {\r\n      \"backgroundTextStyle\":\"light\",\r\n      \"navigationBarBackgroundColor\": \"#fff\",\r\n      \"navigationBarTitleText\": \"差异化 title\",\r\n      \"navigationBarTextStyle\":\"black\"\r\n    }\r\n  },\r\n  \"baidu\": {\r\n    \"window\": {\r\n      \"backgroundTextStyle\": \"light\"\r\n    }\r\n  },\r\n  \"alipay\": {\r\n      \"window\": {\r\n        \"defaultTitle\": \"Chameleon\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码通过 usingComponents 配置 组件路径 注册引用的组件。配置示例：<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n    \"usingComponents\": {\r\n      \"navi\": \"/components/navi/navi\",\r\n      \"navi-npm\": \"cml-test-ui/navi/navi\"\r\n    }\r\n  },\r\n  \"wx\": {\r\n  },\r\n  \"alipay\": {\r\n  },\r\n  \"baidu\": {\r\n  },\r\n  \"web\": {\r\n  },\r\n  \"weex\": {\r\n  }\r\n}\r\n</script>\r\n复制代码如何使用路由能力小程序配置路由app.json 配置项列表的 pages 字段用于指定小程序由哪些页面组成，每一项都对应一个页面的路径+文件名 信息。数组的第一项代表小程序的初始页面（首页）。新增/减少页面，需要对 pages 数组进行修改。如果项目有 pages/index/index.wxml 、 pages/logs/logs.wxml 两个页面，则需要在 app.json 中写{\r\n  \"pages\": [\"pages/index/index\", \"pages/logs/logs\"]\r\n}\r\n复制代码cml配置路由src/router.config.json 是路由的配置文件， cml 内置了一套各端统一的路由管理方式。相应有 cml 路由配置映射如下：{\r\n  \"mode\": \"history\",\r\n  \"domain\": \"https://www.chameleon.com\",\r\n  \"routes\":[\r\n    {\r\n      \"url\": \"/cml/h5/index\",\r\n      \"path\": \"/pages/index/index\",\r\n      \"mock\": \"index.php\"\r\n    },\r\n    {\r\n      \"url\": \"/cml/h5/logs\",\r\n      \"path\": \"pages/logs/logs\",\r\n      \"mock\": \"logs.php\"\r\n    }\r\n  ]\r\n}\r\n复制代码文件名不需要写文件后缀， cml 框架会自动去寻找对于位置的 .cml 文件进行处理。小程序使用路由打开新页面：调用 APIwx.navigateTo页面重定向：调用 APIwx.redirectTo页面返回：调用 APIwx.navigateBack打开另一个小程序：调用 API wx.navigateToMiniProgram返回到上一个小程序：调用 API wx.navigateBackMiniProgramcml使用路由依据统一资源索引URI，自适应打开不同环境同一路由PATH：打开新页面：调用 chameleon-apicml.navigateTo页面重定向：调用 chameleon-apicml.redirectTo页面返回：调用 chameleon-apicml.navigateBack打开另一个跨端应用：调用 chameleon-apicml.open返回到上一个跨端应用：调用 chameleon-apicml.close如何注册如何注册程序小程序注册程序在小程序项目里面， App() 函数用来注册一个小程序。接受一个 Object 参数，其指定小程序的生命周期回调等。示例代码App({\r\n  onLaunch(options) {\r\n    // Do something initial when launch.\r\n  },\r\n  globalData: 'I am global data'\r\n})\r\n复制代码cml注册程序示例代码<script>\r\nimport store from '../store/index.js'\r\nimport routerConfig from '../router.config.json';\r\n\r\nclass App {\r\n  data = {\r\n    store,\r\n    routerConfig\r\n  }\r\n  created(res) {\r\n  }\r\n}\r\n\r\nexport default new App();\r\n</script>\r\n复制代码细心的你会发现，小程序中 app.json app.js app.wxss 和 src/app/app.cml 的对应关系如下小程序 app.jscml项目 src/app/app.cmlapp.js<script></script>app.wxss<style></style>app.json<script cml-type=\"json\"></script>如何注册页面小程序注册页面在小程序项目里面， Page(Object) 函数用来注册一个页面。接受一个 Object 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。示例代码：// index.js\r\nPage({\r\n  data: {\r\n    text: 'This is page data.'\r\n  },\r\n  changeText: function(e) {\r\n    // sent data change to view\r\n    this.setData({\r\n      text: 'CML'\r\n    })\r\n  }\r\n})\r\n复制代码cml注册页面示例代码<script>\r\nclass Index {\r\n  data = {\r\n    text: 'Chameleon'\r\n  }\r\n  methods = {\r\n    changeText: function(e) {\r\n      // sent data change to view\r\n      this.text = 'CML';\r\n    }\r\n  }\r\n  computed = {}\r\n  watch = {}\r\n};\r\nexport default new Index();\r\n</script>\r\n复制代码如何注册组件小程序注册组件在小程序项目里面， Component(Object) 构造器可用于定义组件，调用 Component 构造器时可以指定组件的属性、数据、方法等。示例代码Component({\r\n  properties: {\r\n    myProperty: { // 属性名\r\n      type: String, // 类型（必填）\r\n      value: '' // 属性初始值（可选）\r\n    },\r\n    myProperty2: String // 简化的定义方式\r\n  },\r\n  data: {\r\n    text: ''\r\n  }, // 私有数据，可用于模板渲染\r\n\r\n  // 生命周期函数，可以为函数，或一个在methods段中定义的方法名\r\n  attached() { }, \r\n  ready() { },\r\n  methods: {\r\n    onMyButtonTap() {\r\n      this.setData({\r\n        // 更新属性和数据的方法与更新页面数据的方法类似\r\n        text: 'wx'\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码cml注册组件示例代码<script>\r\nclass MyComponent {\r\n  props = {\r\n    myProperty: { // 属性名\r\n      type: String, // 类型（必填）\r\n      default: '' // 属性初始值（可选）\r\n    },\r\n    myProperty2: String // 简化的定义方式\r\n  }\r\n  data =  {\r\n    text: ''\r\n  } // 私有数据，可用于模板渲染\r\n\r\n  beforeMount() {}\r\n  mounted() {}\r\n  methods = {\r\n    onMyButtonTap() {\r\n      this.text = 'cml'\r\n    }\r\n  }\r\n  computed = {}\r\n  watch = {}\r\n};\r\nexport default new MyComponent();\r\n</script>\r\n复制代码如何声明生命周期统一各端应用生命周期的定义，是跨端框架的重要组成，也是迁移的必经之路。小程序声明生命周期可以在 App(Object) 、 Page(Object) 、 Component(Object) 传入 Object 参数，其指定小程序的生命周期回调等代码示例// index.js\r\nPage({\r\n  onLoad(options) {\r\n    // Do some initialize when page load.\r\n  },\r\n  onReady() {\r\n    // Do something when page ready.\r\n  },\r\n  onShow() {\r\n    // Do something when page show.\r\n  },\r\n  onHide() {\r\n    // Do something when page hide.\r\n  },\r\n  onUnload() {\r\n    // Do something when page close.\r\n  },\r\n  onShareAppMessage() {\r\n    // return custom share data when user share.\r\n  }\r\n})\r\n复制代码cml声明生命周期在 .cml 文件 <script /> 代码块返回的对象实例，其指定生命周期回调示例代码<script>\r\nclass Index {\r\n  beforeCreate(query) {\r\n    // data数据挂载到this根节点上之前，以及methods所有方法挂载到实例根节点之前\r\n    // 注意：只用页面的 beforeCreate钩子 会返回页面query\r\n    console.log('App beforeCreate: 打开当前页面路径中的参数是 ', query)\r\n  }\r\n  created() {\r\n    // data,methods里面的这些events挂载完成\r\n    console.log('App created')\r\n  }\r\n  beforeMount() {\r\n    // 开始挂载已经编译完成的cml到对应的节点时\r\n    console.log('App beforeMount')\r\n  }\r\n  mounted() {\r\n    // cml模板编译完成,且渲染到dom中完成,在整个生命周期中只执行一次\r\n    console.log('App mounted')\r\n  }\r\n  beforeDestroy() {\r\n    // 实例销毁前\r\n    console.log('App beforeDestroy')\r\n  }\r\n  destroyed() {\r\n    // 实例销毁后\r\n    console.log('App destroyed')\r\n  }\r\n};\r\nexport default new Index();\r\n</script>\r\n复制代码App 生命周期 映射小程序 app.js 中的生命周期 -> cml src/app/app.cml小程序chameleononLaunchbeforeCreateonShowmountedonHidedestroyedPage 生命周期 映射小程序 Page() 中的生命周期 -> cml src/pages/mypage/mypage.cml小程序chameleononLoadbeforeCreateonShowmountedonUnloaddestroyedonReady生命周期多态onHide生命周期多态onShareAppMessage生命周期多态Component 生命周期 映射小程序 Component() 中的生命周期 -> cml src/components/mycomponent/mycomponent.cml小程序chameleoncreatedcreatedattachedbeforeMountreadymounteddetacheddestroyed生命周期总结每个 cml 实例( App 、 Page 、 Component )在被创建时都要经过一系列的初始化过程 ————例如，需要设置数据监听、编译模板、将实例挂载到 CML节点 并在数据变化时更新 CML节点等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给开发者在不同阶段添加自己的代码的机会。cml 为 App 、 页面Page 、 组件Component 提供了一系列生命周期事件，保障应用有序执行。另外，如果你想使用某个端特定的生命周期，你可以从业务出发使用生命周期多态。数据如何响应到视图如今，双向数据绑定&单向数据流 已深入开发者日常，MVMM开发模式算是框架标配。数据绑定 、 条件渲染 、列表渲染 是如何书写的呢？示例代码小程序使用数据响应<!--wxml-->\r\n<view class=\"scroller-wrap\">\r\n    <!--数据绑定-->\r\n  <view>{{message}}</view>\r\n  <!--条件渲染-->\r\n  <view wx:if=\"{{view == 'WEBVIEW'}}\">WEBVIEW</view>\r\n  <view wx:elif=\"{{view == 'APP'}}\">APP</view>\r\n  <view wx:else=\"{{view == 'MINA'}}\">MINA</view>\r\n    <!--列表渲染-->\r\n  <view wx:for=\"{{array}}\" wx:for-index=\"index\" wx:for-item=\"item\">{{item}}</view>\r\n</view>\r\n复制代码// page.js\r\nPage({\r\n  data: {\r\n    message: 'Hello MINA!',\r\n    view: 'MINA',\r\n    array: [1, 2, 3, 4, 5]\r\n  },\r\n  onLoad() {\r\n    this.setData({\r\n      message: 'wx'\r\n    })\r\n  }\r\n})\r\n复制代码cml使用数据响应<template>\r\n<!--index.cml-->\r\n<view class=\"scroller-wrap\">\r\n    <!--数据绑定-->\r\n  <view>{{message}}</view>\r\n  <!--条件渲染-->\r\n  <view c-if=\"{{view == 'WEBVIEW'}}\">WEBVIEW</view>\r\n  <view c-else-if=\"{{view == 'APP'}}\">APP</view>\r\n  <view c-else=\"{{view == 'MINA'}}\">MINA</view>\r\n    <!--列表渲染-->\r\n  <view c-for=\"{{array}}\" c-for-index=\"index\" c-for-item=\"item\">{{item}}</view>\r\n</view>\r\n</template>\r\n<script>\r\nclass Index {\r\n  data =  {\r\n    message: 'Hello MINA!',\r\n    view: 'MINA',\r\n    array: [1, 2, 3, 4, 5]\r\n  }\r\n\r\n  beforeCreate () {\r\n    this.message = 'cml'\r\n  }\r\n};\r\nexport default new Index();\r\n</script>\r\n复制代码数据响应总结cml 运行时框架 提供了跨端响应式数据绑定系统(Data binding)，当做数据修改的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。只需要将 view<-->model 交互部分逻辑，作简单迁移，便可使它成为跨多端的数据响应系统。事件交互cml 支持一些基础的事件，保障各端效果( 类型 、 绑定 、 事件对象 )一致运行。示例代码小程序使用事件<!--wxml-->\r\n<view id=\"tapTest\" data-hi=\"WeChat\" bindtap=\"tapName\">Click me!</view>\r\n复制代码// page.js\r\nPage({\r\n  tapName(event) {\r\n    console.log(event)\r\n  }\r\n})\r\n复制代码cml使用事件<template>\r\n  <view id=\"tapTest\" data-hi=\"WeChat\" c-bind:tap=\"tapName\">\r\n    <text>Click me!</text>\r\n  </view>\r\n</template>\r\n<script>\r\nclass Index {\r\n  methods = {\r\n    tapName(e) {\r\n      // 打印事件对象\r\n      console.log('事件对象:', e);\r\n    }\r\n  }\r\n}\r\nexport default new Index();\r\n</script>\r\n复制代码事件使用总结同时，还支持，用于父子组件之间的通信。另外，如果你想要使用某个端特定的事件， cml 并不会限制你的自由发挥，你可以从业务出发使用组件多态 或者接口多态 差异化实现功能。布局和外观各端描述 布局和外观 的层叠样式表(CSS)实现存在差异，包括不限于 布局 、 盒模型 、 定位、 文本 。所以， cml 框架内置跨端一致性基础样式能力。并且，定义了用于描述页面的样式规范 CMSS(Chameleon Style Sheet) 。如何导入外部样式使用 @import 语句可以导入外联样式表， @import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。小程序导入外部样式示例代码：/** common.wxss **/\r\n.small-p {\r\n  padding:5px;\r\n}\r\n复制代码/** app.wxss **/\r\n@import \"common.wxss\";\r\n.middle-p {\r\n  padding:15px;\r\n}\r\n复制代码cml导入外部样式详细文档示例代码：/** common.css **/\r\n.small-p {\r\n  padding: 5px;\r\n}\r\n复制代码<!-- app.cml -->\r\n<style>\r\n  @import './common.css';\r\n  .middle-p {\r\n    padding:15 cpx;\r\n  }\r\n</style>\r\n复制代码样式使用总结同时，为了统一多端尺寸单位，呈现效果一致，同时页面响应式布局， cml 项目统一采用cpx 作为尺寸单位，规定以屏幕750px（占满屏幕）视觉稿作为标准。而且，各端样式表拥有的能力不尽相同，是项目迁移的主要阵地之一。另外，如果你想要使用某个端特定的样式能力， cml 并不会限制你的自由发挥，你可以从业务出发使用样式多态注意：由于chameleon应用是 跨多端 web native 小程序 框架，如果需要跨 native ，必须使用flexbox 进行样式布局！！！组件cml 项目一切皆组件。组件(Component)是视图的基本组成单元。框架为开发者提供了一系列基础组件，开发者可以通过组合这些基础组件进行快速开发。如：<template>\r\n  <view>\r\n    <view>view 基础组件</view>\r\n    <text>text 基础组件</text>\r\n  </view>\r\n</template>\r\n复制代码同时， cml 支持简洁的组件化编程。自定义组件开发者可以将页面内的功能模块抽象成自定义组件，以便在不同的页面中重复使用。自定义组件在使用时与基础组件非常相似。如何创建自定义组件小程序创建自定义组件代码示例：Component({\r\n  properties: {\r\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\r\n    innerText: {\r\n      type: String,\r\n      value: 'default value',\r\n    }\r\n  },\r\n  data: {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  },\r\n  methods: {\r\n    // 这里是一个自定义方法\r\n    customMethod() {}\r\n  }\r\n})\r\n复制代码cml创建自定义组件示例代码<script>\r\nclass MyComponent {\r\n  props = {\r\n    // 这里定义了innerText属性，属性值可以在组件使用时指定\r\n    innerText: {\r\n      type: String,\r\n      value: 'default value',\r\n    }\r\n  }\r\n  data = {\r\n    // 这里是一些组件内部数据\r\n    someData: {}\r\n  }\r\n  methods = {\r\n    // 这里是一个自定义方法\r\n    customMethod() {}\r\n  }\r\n  computed = {}\r\n  watch = {}\r\n};\r\nexport default new MyComponent();\r\n</script>\r\n复制代码如何使用自定义组件使用已注册的自定义组件前，首先要进行引用声明。此时需要提供每个自定义组件的标签名和对应的自定义组件文件路径。小程序使用自定义组件代码示例：在 page.json 中进行引用声明{\r\n  \"usingComponents\": {\r\n    \"component-tag-name\": \"path/to/the/custom/component\"\r\n  }\r\n}\r\n复制代码在 page.wxml 中使用<view>\r\n  <!-- 以下是对一个自定义组件的引用 -->\r\n  <component-tag-name inner-text=\"Some text\"></component-tag-name>\r\n</view>\r\n复制代码cml使用自定义组件代码示例：在 page.cml 中 <script cml-type='json' /> 进行引用声明<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n      \"usingComponents\": {\r\n        \"component-tag-name\": \"path/to/the/custom/component\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码在 page.cml 中 <template /> 使用<template>\r\n<view>\r\n  <!-- 以下是对一个自定义组件的引用 -->\r\n  <component-tag-name inner-text=\"Some text\"></component-tag-name>\r\n</view>\r\n</template>\r\n复制代码如何实现父子组件事件通信事件系统是组件间通信的主要方式之一。自定义组件可以触发任意的事件，引用组件的页面可以监听这些事件。小程序组件通信代码示例：<!-- 页面 page.wxml -->\r\n<view>\r\n  <my-component bindcustomevent=\"onMyEvent\"></my-component>\r\n</view>\r\n复制代码// 页面 page.js\r\nPage({\r\n  methods: {\r\n    onMyEvent(e) {\r\n      console.log(e.detail) // 自定义组件触发事件时提供的detail对象\r\n    }\r\n  }\r\n})\r\n复制代码<!-- 组件 my-component.wxml -->\r\n<view>\r\n  <button bindtap=\"onTap\">点击这个按钮将触发“myevent”事件</button>\r\n</view>\r\n复制代码// 组件 my-component.js\r\nComponent({\r\n  methods: {\r\n    onTap() {\r\n      this.triggerEvent('customevent', {}) // 触发 自定义组件事件\r\n    }\r\n  }\r\n})\r\n复制代码cml组件通信代码示例：<!-- 页面 page.cml -->\r\n<template>\r\n  <view>\r\n    <my-component c-bind:customevent=\"onMyEvent\"></my-component>\r\n  </view>\r\n</template>\r\n<script>\r\nclass Index {\r\n  methods = {\r\n    // 这里是一个自定义方法\r\n    onMyEvent(e) {\r\n      console.log(e.detail) // 自定义组件触发事件时提供的detail对象\r\n    }\r\n  }\r\n};\r\nexport default new Index();\r\n</script>\r\n<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n      \"usingComponents\": {\r\n        \"my-component\": \"path/to/the/custom/component\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码<!-- 页面 path/to/the/custom/component.cml -->\r\n<template>\r\n  <view>\r\n    <button c-bind:tap=\"onTap\">点击这个按钮将触发“myevent”事件</button>\r\n  </view>\r\n</template>\r\n<script>\r\nclass MyComponent {\r\n  methods = {\r\n    // 这里是一个自定义方法\r\n    onTap() {\r\n      this.$cmlEmit('customevent', {}) // 触发 自定义组件事件\r\n    }\r\n  }\r\n};\r\nexport default new MyComponent();\r\n</script>\r\n<script cml-type=\"json\">\r\n{}\r\n</script>\r\n复制代码组件使用总结和小程序一样， cml框架 提供了大量内置组件和扩展组件，抹平多端差异，便于开发者通过组合这些组件，创建出强大的应用程序。扩展组件需要额外引入。如：<script cml-type=\"json\">\r\n{\r\n  \"base\": {\r\n      \"usingComponents\": {\r\n        \"c-dialog\": \"cml-ui/components/c-dialog/c-dialog\"\r\n      }\r\n  }\r\n}\r\n</script>\r\n复制代码在执行 cml build 构建打包时， cml 框架 会按需打包引用的内置组件和扩展组件，为代码瘦身。内置组件 和扩展组件 都是支持跨多端的，对于一些没有提供的某个端的组件，可以通过组件多态来实现。如果希望使用小程序端的原生组件，那么可以在原生标签前加上 origin-* ， cml 框架会渲染原生组件参考注意： origin-* 只能在灰度区文件中使用！！如在 map.wx.cml 文件中使用原生地图组件 <map/> ：<!-- map.wx.cml -->\r\n<template>\r\n  <origin-map\r\n    id=\"map\"\r\n    longitude=\"113.324520\"\r\n    latitude=\"23.099994\"\r\n    controls=\"{{controls}}\"\r\n    bindcontroltap=\"controltap\"\r\n    style=\"width: 100%; height: 300px;\"\r\n  ></origin-map>\r\n</template>\r\n复制代码如何调用平台接口能力在小程序里面，可以通过微信原生 API ，调起如获取用户信息，本地存储，支付功能等。示例代码try {\r\n  wx.setStorageSync('name', 'Hanks')\r\n} catch (e) {\r\n  console.error(e)\r\n}\r\n复制代码同样，在 cml 项目里面可以这样调用：示例代码import cml from 'chameleon-api'\r\ncml.setStorage('name', 'Hanks').then((res)=>{\r\n  console.log(res)\r\n},function(e){\r\n  console.error(e)\r\n})\r\n复制代码接口使用总结cml 框架提供了丰富的多态接口，可以调起各端提供的原生能力，如系统信息、元素节点信息、动画效果、本地存储、网络请求、地理位置等。请参考API 文档。chameleon-api 提供的接口都是支持跨多端的，对于一些没有提供的某个端的原生接口，可以通过接口多态来调用。"}
{"title": "微信小程序自定义导航栏 ", "author": "Rolan", "pub_time": "2019-4-8 00:53", "content": "在做快狗打车小程序时，关于默认导航栏，我们遇到了以下的问题：Android、IOS手机对于页面title的展示不一致，安卓title的显示不居中页面的title只支持纯文本级别的样式控制，不能够做更丰富的title效果左上角的事件无法监听、定制路由导航单一，只能够返回上一页，深层级页面的返回不够友好我们希望的是：在各个机型页面上title一致性 & 个性化展示、取得左上角点击事件控制权及深层级页面的一键返回实现step1 自定义第一步 取得导航栏的控制权小程序支持自定义导航栏，只需要在 app.json 文件中， window 项中配置\"navigationStyle\": \"custom\"\r\n复制代码这样微信就放开了导航栏的控制权，只保留右上角的胶囊。页面会从 视窗的顶部 开始渲染，如图接下来，我们要做的就是实现一个导航栏组件，把它放置在页面原来的默认导航栏的位置，内容什么的完全由开发者自己定制。step2 功能点第二步 梳理导航栏的功能点导航栏高度（各个机型动态适配）导航栏内容定制所有机型title居中显示（自己布局实现）首页 导航栏左上角显示个人中心、中部title使用个性图标嵌套页面 左上角显示 返回上一页 + 回到首页 按钮非常规首页 左上角显示 回到首页 按钮导航栏高度 包含两个部分：工具栏和title栏， 工具栏的高度一般是固定的20px，title栏的高度需要计算导航栏内容的定制，需要识别当前页面的性质，根据不同的页面展示不同的内容，可以通过获取当前的页面路由栈来判定当前的页面性质step3 导航栏组件基本结构目前快狗打车小程序的基本结构// navBar.wxml\r\n<cover-view class='place-holder'></cover-view>\r\n<cover-view class='nav-bar'>\r\n    <cover-view class='tool-bar' style='height: 20px'></cover-view>\r\n    <cover-view class='title-bar'>\r\n        <cover-view class='left-cell'>\r\n            // scene0 常规首页   个人中心按钮\r\n            // scene1 非常规首页 回首页按钮\r\n            // scene2 嵌套页     返回上一页按钮 + 回首页按钮\r\n        </cover-view>\r\n        <cover-view class='center-cell'>\r\n            // scene0 常规首页  个性化title\r\n            // scene1 其他页    正常title\r\n        </cover-view>\r\n        <cover-view class='right-cell'>\r\n            // 占位用的\r\n        </cover-view>\r\n    </cover-view>\r\n</cover-view>\r\n复制代码Tips：组件内多了一个占位的place-holder块，是因为某些页面有类似滚动列表的需求，要保证导航栏始终在视窗的顶部的话，需要使用定位，定位之后脱离文档流，在最初的时候需要占位块保证后续的页面内容不会被导航栏遮挡使用 cover-view 布局是因为快狗的业务中有类似 map 的原生组件，使用 view 的话有被遮挡的风险step4 高度计算需要计算 title-bar 的高度在 默认导航栏 & 无底部tab栏 的情况下，使用 wx.getSystemInfoSync 获取手机信息，可以看到两项信息:screenHeight\r\nwindowHeight\r\n这种情况下，二者的差值就是默认的导航栏的高度, 但是在设置了 \"navigationStyle\": \"custom\" 之后，二者的值是一样的了，因此导航栏的高度我们需要使用统计的经验值。根据统计，得到如下的结果：{\r\n    'iPhone': 64,\r\n    'iPhoneX': 88,\r\n    'Android': 68,\r\n    'samsung': 72\r\n}\r\n复制代码工具栏的高度可根据 wx.getSystemInfoSync 返回值中的 statusBarHeight 获取。至此，我们得到了导航栏的相关的高度值// 导航栏总高度 & 占位块高度\r\nplaceHoder = totalBar = {\r\n    'iPhone': 64,\r\n    'iPhoneX': 88,\r\n    'Android': 68,\r\n    'samsung': 72\r\n}\r\n// 时间、信号等工具栏的高度\r\ntoolBar = systermInfo.statusBarHeight\r\n// 页面title栏的高度\r\ntitleBar = totalBar - toolBar\r\n复制代码step5 内容定制在组件的生命周期函数 attached 中，我们可以获取当前的页面路由栈let pages = getCurrentPages()\r\nlet current_page = pages[pages.length - 1].route \r\nconst NORMAL_ENTRY = '常规的入口页路径'\r\n\r\n// scene 0 常规入口页  个性化title、个人中心\r\npages.length === 1 && current_page === NORMAL_ENTRY\r\n// scene 1 非常规入口页 回首页\r\npages.length === 1 && current_page !== NORMAL_ENTRY\r\n// scene 2 嵌套页面  返回 + 回首页\r\npages.length > 1 \r\n    \r\n复制代码根据不同的条件，展示不同的内容目前在生产环境99%的机型中，都可以完美的运行。\r\n写在最后\r\n\r\n自定义导航栏是全局生效的，一旦设置，各个原生小程序页面都需要引入\r\n目前微信版本7+支持了针对特定页面的自定义导航栏，可以根据需要个性化定制\r\n自定义导航栏在web-view页面不会起效\r\n有尝试把导航栏做成插件，但是遇到在插件组件中无法获取页面路由栈的问题，因此没有成功"}
{"title": "我的前端规范系列-高清屏适配[按标准来就行] ", "author": "Rolan", "pub_time": "2019-4-9 00:29", "content": "目标1.明确统一@x图的标准，以750x1334切下来的图 为@2x的标准2.使用以屏幕宽度为基准的相对单位,为了适配,从设计稿到成品肯定存在换算过程3.为位图的容器设置宽高适配后效果图: 基本不会出现很不理想的状况什么才是标准的@2x图？其实已750x1334设计出来的图，切下来，刚刚好就是2x图，缩小1倍就是1x，乘以1.5就是3x图设计稿里量下的宽高就是你需要的宽高吗？不是的 ！！比如750px的iphone6 量出75px的物体，在375px的手机里肯定只有35px。所以为了适配你必需转换成 以屏幕宽度为标准的相对单位,所以换算过程肯定是存在的,因为设计稿只是一个750的基准 。@x图只针对于图片和图标,这种需要用到位图的地方 详细原理请点击查看 .其目标既是在等大的容器内装入像素更大的位图,从而补足像素点的缺失。 因为只有用到位图的地方才会出现像素缺失和像素丢失的状况,其他的元素都是系统绘制的矢量图形不受是否是高清屏幕的影响。@x图过大过小会出现什么问题？@x图比实际需要小如果@x图比实际需要小，那么图像就会模糊。@x图比实际需要大如果@x图比实际需要大时会出现什么问题，其实这种情况也会出现问题只是问题不明显，会出现的问题就是图像失真，因为设备实际上没那么多像素点显示，就是丢失一些像素点。这种情况一般不易察觉,但是问题肯定是存在的。这就是为什么有些同志拿到大图了，却觉得可以的原因，因为只要他限制了图片的大小，他自己也看不出问题。另外还有一点，就是web前端同志拿到的图片会过大,这个影响就比较大了。所以不是用越大的图就越好。解决方案@x图标准还是按照上方的标准。如果发现ps切下来的@2x比设计稿里的大了，既是出现错误。另外程序端还是建议按设计稿给用到图片的地方设置宽高,这样防止换了大图后图片撑开的问题。h5端解决方案使用rem相对单位而不是pxrem是指相对于根元素的字体大小的单位。那么根据该原理：我们只需能动态获取屏幕的dpr及宽度信息，并改变根元素的font-size，其余的所有页面元素也将会进行改变 。<html data-dpr=\"1\" style=\"font-size: 41.4px;\">\r\n</html>详细原理请点击查看存在问题但是该方案有个问题，rem单位很不直观。比如大小为80px的按钮, 按上面标准换算成rem为1.946rem[这就蛋疼了，你无法直观看出这个按钮多大,修改起来更是蛋疼。如果没有一套优雅的管理方案，后期修改基本靠感觉或者画点时间计算下==]，接下来和大家聊聊如何优雅的使用rem单位。使用sass函数来辅助解决假设对于一个iphone6的视觉稿，我们定义它的基准值就是75 该基准值是根据你的定义变的 关于基准值有问题可见这样我们就可以按照设计稿的大小写进程序,从而便于维护和识别//辅助函数\r\n// 例如: .px2rem(height, 80);\r\n@mixin px2rem(@name, @px){\r\n    @{name}: @px / 75 * 1rem;\r\n}图片的话推荐直接使用@2x 或者 使用矢量图形图片这里因为h5端特殊,既要考虑流量,又要考虑清晰度,这里推荐还是直接使用@2x图吧!别折腾了！小程序端解决方案1.小程序需要使用rpxrpx为小程序自己的单位,会对设备进行适配rpx与[750*1330]设计稿px的关系1px==1rpx,但是在iphone6上0.5px==1rpx 详见2.使用Taro框架[安利一波]Taro 方案的初心就是为了打造一个多端开发的解决方案。目前 Taro 代码可以支持转换到 微信/百度/支付宝/字节跳动小程序 、 H5 端 以及 移动端（React-Native）。Taro.js是京东出品的小程序框架,经使用除了不支持一些react语法外，基本无大槽点[这里不经要吐槽下腾讯官方的wepy，真是坑死人不偿命!请慎用慎用!]该框架直接服务到位,代码直接书写px单位[又不用记多一个rpx单位了:blush:],程序框架自动帮你转换:grin:，那么爽的吗？ 就是这么爽！因为别人Taro的目标是write one, use everyWhere!!"}
{"title": "小程序分享模块超级详解 ", "author": "Rolan", "pub_time": "2019-4-10 00:36", "content": "导语：在小程序项目开发中，分享能力几乎是每个项目必备的要求，但原生的分享能力比较有限，不够灵活，今天就我们就一起来研究下，如何在现有基础上，增强小程序分享的能力，使信息传递更加直观、灵活。示例项目地址: github.com/ycvcb123/sh…本文目录:小程序分享基础 API 介绍基于 canvas 动态绘制分享图片canvas 对不同来源图片的处理（本地图片， 网络图片 ， base64图片 ）canvas 生成图片后如何保存到本地如何生成小程序码及验证小程序码所带信息抽离配置文件，使绘制更加灵活小程序分享基础 API 介绍微信分享的 API 只提供了分享给微信好友的能力，并没有提供分享朋友圈的能力，这是为啥子呢！！！从网上收集的一些咨询来看，主要有如下两点原因:由于微商泛滥，公众号鸡汤泛滥，朋友圈质量已经有所下降，如果小程序再开放分享朋友圈功能，可能会进一步影响到整个微信生态，造成用户活跃度下降，用户流失等问题。微信不让小程序在朋友圈转发，更多是保护朋友圈的”广告位”阵地，不能够让这块”肥肉”变成了公益设施。其实一些童鞋应该留意到了在朋友圈，官方已经推了一些小程序的广告，只不过这项能力还没有完全放开，以后会不会放开先不讨论，智慧的开发小哥哥早已想到了通过生成带有小程序码的海报作为替代方案（撒花！！！），本文后面的部分也会说到，我们先回到正题。用法：Page({\r\n    onShareAppMessage: function(){\r\n         return {\r\n            title: 'xxxxx', //自定义转发标题\r\n            path: '/page/user?id=123', //分享页面路径\r\n            imageUrl: '/common/images/xxx.png' //分享图片 宽高比 5:4\r\n        }\r\n    }\r\n})\r\n//如果只写成如下形式，title默认是小程序名，path为当前页面路径（不带参数），imageUrl为当前页面截图\r\nPage({\r\n    onShareAppMessage: function(){}\r\n})\r\n复制代码触发方法（一定要在 page 中先写入上述方法）:点击小程序的胶囊菜单，会从底部弹出转发选项。<button> 组件 open-type=\"share\" 即 <button open-type=\"share\"> ,点击后触发。触发后效果如下：观察上述结果，不难看出， title 能分享出去的信息非常有限，那我们能不能对分享的图片做些文章，让它带出更多的信息呢？下面进入到我们的第二个部分基于 canvas 动态绘制分享图片基于 canvas 动态绘制分享图片因为每个页面的信息很多都是通过接口返回或者用户输入产生，是在不断变化的，设计师所画的静态图片肯定是不足以去展示这些信息的，那么我们就要想，有没有一种办法，是可以把 静态图片 和 动态信息 绘制在一起后在生成一张 新的图片 ?答案是肯定的！！！把图片和文字画在一起？我们就一定会想到神奇的 canvas ，根据小程序 画布 相关的 API 绘制如下：//创建画布（组件中一定要绑定this,切记！！！）\r\nvar ctx = wx.createCanvasContext('myCanvas', this);\r\n//画布上绘制图片\r\nctx.drawImage(path, 0, 0, width, height);\r\n//画布上绘制文字\r\nctx.setFillStyle('#fff');\r\nctx.setFontSize(32);\r\nctx.fillText(startTime, 24, 54);\r\n//其他信息绘制\r\n//... \r\nctx.draw();\r\n复制代码上述已经通过 canvas 把图片和文字绘制到了一起，那如何把这个画布转成一个图片，供开发者使用呢？强大的小程序给我们提供了原生的方法: wx.canvasToTempFilePath//在上面代码的draw()的回调中使用wx.canvasToTempFilePath\r\nvar that = this;\r\nctx.draw(true, () => {\r\n    setTimeout(() => {\r\n        wx.canvasToTempFilePath({\r\n            canvasId: 'myCanvas',\r\n            success: (res) => { \r\n                that.setData({\r\n                    //res.tempFilePath 生成图片的临时路径\r\n                    picUrl: res.tempFilePath\r\n                });\r\n               \r\n                \r\n            }\r\n        }, that); //在组件中使用这里一定记得要绑定this，切记！！！\r\n    }, 300); //此处加入300毫秒延时是为了解决小程序绘制过程中的渲染问题\r\n});\r\n复制代码把图片路径传递给 <image> 标签,得到下图结果。<image src=\"{{picUrl}}\"/>\r\n复制代码同理：把 picUrl 赋值给 onShareAppMessage 中的 imageUrl ,分享出去后的图片则带有了动态信息！对不同来源图片的处理（本地图片， 网络图片 ， base64图片 ）在上面的例子中，绘制本地图片时直接使用 ctx.drawImage(path, 0, 0, width, height) , path 直接传入图片路径即可。但是如果是 网络图片 或者是 base64 的图片时， drawImage 是无法直接绘制的 ，下面就介绍下针对上述两种情况如何做兼容处理。网络来源图片//将网络图片转换为本地路径\r\nhandleNetImg: function(imagePath) {\r\n    var that = this;\r\n    return new Promise((resolve, reject) => {\r\n        wx.getImageInfo({\r\n            src: imagePath,\r\n            success: function(res) {\r\n                resolve(res);\r\n            }\r\n        });\r\n    });\r\n}\r\n\r\nhandleNetImg('网络图片地址').then((res) => {\r\n    console.log(res.path); //输出转换后的本地图片路径\r\n    ctx.drawImage(res.path, 0, 0, width, height); //此时图片即可在画布上绘制出来\r\n})\r\n复制代码base64 图片使用 ctx.drawImage(base64Data, 0, 0, width, height) 在小程序开发者工具上是可以绘制的， 然而！！！这个大骗纸！！！真机上是失效的！！！（心碎一分钟。。。）跟上面类似的思路，我们把 base64的图片 转为本地的 png图片var handleBase64Img = function() {\r\n    //wx.getFileSystemManager 小程序文件管理器\r\n    var fsm = wx.getFileSystemManager();\r\n    var FILE_NAME = 'base64src';\r\n    var base64src = function(base64data) {\r\n        return new Promise((resolve, reject) => {\r\n            //解析base64，提取出图片类型: imgtype,解析内容bodyData（去掉data:image/png;base64,以后的内容）\r\n            var [, imgType, bodyData] = /data:image\\/(\\w+);base64,(.*)/.exec(base64data) || [];\r\n            if (!imgType) {\r\n                reject(new Error('ERROR_BASE64SRC_PARSE'));\r\n            }\r\n            /**\r\n             *wx.env.USER_DATA_PATH\r\n             *本地用户文件\r\n             *本地用户文件是从 1.7.0 版本开始新增的概念。提供了一个用户文件目录给开发者，开发者对这个目录有完全自由的读写权限。通过 wx.env.USER_DATA_PATH 可以获取到这个目录的路径。\r\n             */\r\n            var filePath = `${wx.env.USER_DATA_PATH}/${FILE_NAME}.${imgType}`;\r\n            //按指定写入文件的字符编码encoding，向地址filepath，写入数据data。\r\n            fsm.writeFile({\r\n                filePath,\r\n                data: bodyData,\r\n                encoding: 'base64',\r\n                success() {\r\n                    resolve(filePath);\r\n                },\r\n                fail() {\r\n                    reject(new Error('ERROR_BASE64SRC_WRITE'));\r\n                },\r\n            });\r\n        });\r\n    };\r\n    return base64src;\r\n}\r\n\r\nvar base64src = that.handleBase64Img();\r\nvar handleBase64src = base64src(base64data);\r\nhandleBase64src.then(res => {\r\n    //res 即为base64 转化为图片后的本地路径，即可在画布上绘制成功\r\n    that.ctx.drawImage(res, left, top, width, height);\r\n});\r\n复制代码通过上述的一些内容，我们已经知道如何利用 canvas 把图片和文字绘制在一起后生成一张新的图片，这里就产生了一个新的问题: 我们如何把生成的图片保存下来呢 ？？？ 我们接着往细看canvas 生成图片后如何保存到本地canvas 生成图片后如何保存到相册中想要保存到相册中第一步首先当然是要获得访问相册的权限！！！//访问相册授权wx.getSetting({\r\n    success: (res) => {\r\n        //检查是否有访问相册的权限，如果没有则通过wx.authorize方法授权(授权只需要一次就好，后面就可以直接访问相册)\r\n        if (!res.authSetting['scope.writePhotosAlbum']) {\r\n            console.log('没有获取授权');\r\n            wx.authorize({\r\n                scope: 'scope.writePhotosAlbum',\r\n                success: (res) => {\r\n                    //用户点击允许获取相册信息后逻辑进入这里,如上图所示\r\n                }\r\n            })\r\n        } \r\n    }\r\n});\r\n\r\n//获取了相册的访问权限，使用 wx.saveImageToPhotosAlbum 将图片保存到相册中\r\nwx.saveImageToPhotosAlbum({\r\n    filePath: that.data.sharePicPath,\r\n    success: (res) => {\r\n        //保存成功弹出提示，告知一下用户\r\n        wx.showModal({\r\n            title: '已保存到手机相册',\r\n            content: '将图片发送到朋友圈，邀请好友加入',\r\n            confirmColor: '#0bc183',\r\n            confirmText: '知道了',\r\n            showCancel: false\r\n        })\r\n    }\r\n})\r\n复制代码如何生成小程序码及验证小程序码所带信息在小程序的分享朋友圈的解决方案中，往往在生成的海报页面中都会有一个小程序码，使得用户有进入小程序的入口，那么这个小程序码如何生成呢？官方文档:获取小程序码注意：因为生成小程序码的接口参数需要 access_token，安全起见，一般都通过后台调用在拿到base64的数据在返回给前端。我们在回到正题:上述三种生成接口，大家根据情况按需使用，因为我的项目里，需要经常生成不同页面对应的小程序码， B 类接口比较符合我的要求，这里就重点描述下 B 类接口的 使用 和 自测B 类接口入参，出参官方说明-- 接口 B：适用于需要的码数量极多的业务场景重点看下 scene : 最大32个可见字符，有页面路径带参数的情况下要尤其注意！！！把 page , scene 等参数传递给后台后，后台调用 B 类接口，返回给前端一个base64的图片数据，我们把这个数据绘制到海报上就好！！！绘制方法上面已经说过canvas 对不同来源图片的处理（本地图片， 网络图片 ， base64图片 ）现在小程序码的图片已经生成了，那么我们要如何自测呢？怎么才能知道小程序码中所携带信息是否正确呢？官方给出的方法:上述方法在开发阶段是比较方便，但是在正式的提测阶段，此种方式显得有些牵强，有人想到真机调试？官方接口只能生成已发布的小程序的二维码也就是说，你扫码就连上生产环境了！！！没有办法调试，那到底怎么办呢？？？解决办法就要借助强大的小程序开发者工具啦！！！首先把生成的小程序码保存到电脑里，方法见上述canvas 生成图片后如何保存到本地部分。然后通过开发者工具选择二维码编译模式，文件夹中选择带有小程序码的图片即可！！！注意： 获取 scene 值时要 decodeURIComponentPage({\r\n  onLoad(query) {\r\n    // scene 需要使用 decodeURIComponent 才能获取到生成二维码时传入的 scene\r\n    const scene = decodeURIComponent(query.scene)\r\n  }\r\n})\r\n复制代码抽离配置文件，使绘制更加灵活我们观察如下一个小程序海报:除了上图红框中的的内容会发生写变化以外，整体的结构大部分是基本已经固定了的，因为海报内容和业务是强相关的，如果我把绘制的逻辑写入组件里，那岂不是换个业务，我的组件就要改一次？这样失去了组件的通用型肯定是不行的，那怎么办呢？下面介绍一个业界比较好的解决方案:小程序海报说白了就是由 canvas 画布上绘制的一些形状，图片，文字，线等等组成的，那我们是不是可以把这些绘制的基本能力封装成方法，通过设计稿量出海报上每个元素的位置大小等信息，当作一个配置文件传递给这些绘制方法，这样就保证组件的通用型，而且绘制信息抽离成一个配置文件也更加方便后期维护。share-config.js:function setShareInfo(time, start, end, imageSrc) {\r\n    return {\r\n        width: 750,\r\n        height: 1300,\r\n        background: '#F2FCF8',\r\n        views: [{\r\n                type: 'rect',\r\n                parent: true,\r\n                radius: true,\r\n                radiusVal: 16,\r\n                left: 40,\r\n                width: 670,\r\n                height: 1140,\r\n                shadow: true,\r\n                background: '#cacacd',\r\n                shadowColor: 'rgba(0,0,0,.6)',\r\n                line: true\r\n            },\r\n            //....\r\n            {\r\n                type: 'text',\r\n                content: '长按或扫描二维码，查看这条线路',\r\n                color: '#9B9BA1',\r\n                top: 1052,\r\n                left: 224,\r\n                fontSize: 28,\r\n                font: 'PingFangSC-Medium',\r\n            },\r\n            {\r\n                type: 'image',\r\n                path: '/common/images/station-flag.png',\r\n                top: 746,\r\n                left: 80,\r\n                width: 32,\r\n                height: 104\r\n            }\r\n        ]\r\n    }\r\n}\r\n\r\nexport {\r\n    setShareInfo\r\n}\r\n复制代码只需要在几个动态信息改变时，传入这些变化的值即可。import { setShareInfo } from '../../common/config/share-config';\r\npage({\r\n    onLoad: function() {\r\n        this.setData({\r\n            shareMessageInfoTimeline: setShareInfo('3月7号 下午16:30发车', '腾讯大厦', '平安国际中心', '')\r\n        });\r\n        //...\r\n    },\r\n});\r\n\r\n复制代码通过 shareMessageInfoTimeline 获取配置信息<view class=\"container\">\r\n    <mod-share-timeline timelineShow=\"{{timelineShow}}\" picContent=\"{{shareMessageInfoTimeline}}\" bindcloseTimelineShow=\"closeTimelineShow\"/>\r\n</view>\r\n复制代码总结本文对小程序分享所需的基础能力进行了拆分详解，把上述能力进行不同的组合，应该可以满足大部分的分享需求。比如:动态绘制分享给微信好友的分享图片。生成并保存小程序海报。"}
{"title": "微信小程序纯css实现刻度尺 ", "author": "Rolan", "pub_time": "2019-4-9 00:35", "content": "最近需要实现一个高度定制的刻度尺，但是网上现成的方案却是极少，最终找到了HaoTian的wx-scale。但是没有实现竖向的效果而且刻度范围大时，在安卓机上无法渲染完全(找了很久没有找到原因，猜测是canvas无法在一瞬间同时刻画多个刻度，知道问题的欢迎留言告知)。于是纯css自己实现一个。\r\n　　1.效果图\r\n\r\n　　微信开发者工具查看效果\r\n　　2.使用\r\n　　在需要引用的json页面添加\r\n\r\n　　然后页面调用\r\n　\r\n　　js\r\n　　\r\n　　3.参数说明style选项\r\n查看完整代码如果我的代码对你帮助，请给分start吧。^-^有不对或者什么问题，都可以留言"}
{"title": "Comi - 小程序 markdown 渲染和代码高亮解决方案 ", "author": "Rolan", "pub_time": "2019-4-10 00:45", "content": "Comi 读 ['kəʊmɪ]，类似中文 科米，是腾讯 Omi 团队开发的小程序代码高亮和 markdown 渲染组件。有了这个组件加持，小程序技术社区可以开始搞起来了。体验感谢【小程序•云开发】提供技术支持。预览Comi 基于下面的 5 个组件进行开发：prismjswxParseremarkablehtml2jsonhtmlparser先看 Comi 使用，再分析原理。使用先拷贝 此目录 到你的项目。js:const comi = require('../../comi/comi.js');\r\n\r\nPage({\r\n  onLoad: function () {\r\n    comi(`你要渲染的 md！`, this)\r\n  }\r\n})\r\n复制代码wxml:<include src=\"../../comi/comi.wxml\" />\r\n复制代码wxss:@import \"../../comi/comi.wxss\";\r\n复制代码简单把！在 omip 中使用先拷贝 此目录 到你的项目。js:import { WeElement, define } from 'omi'\r\nimport './index.css'\r\nimport comi from '../../components/comi/comi'\r\n\r\ndefine('page-index', class extends WeElement {\r\n\r\n  install() {\r\n    comi(`你要渲染的 md`, this.$scope)\r\n  }\r\n\r\n  render() {\r\n    return (\r\n      <view>\r\n        <include src=\"../../components/comi/comi.wxml\" />\r\n      </view>\r\n    )\r\n  }\r\n})\r\n复制代码WeElement 里的 this 并不是小程序里的 this，需要使用 this.$scope 访问小程序 Page或 Component 的 this。css:@import '../../components/comi/comi.wxss';\r\n复制代码原理在开发 Comi 之前，我们进行了预研，是否有必要造这个轮子。代码高亮预研wxParse 只是用标签包括代码，并未处理代码转成 WXML，所以渲染出的代码是没有颜色老牌的 highlightjs 没有 WXML 对应的方案老牌的 highlightjs 对 JSX 高亮支持太差prismjs 是 react 官方使用的高亮插件，对 JSX 支持高亮很好prismjs 支持几乎所有的语言，并且支持自定义扩展语言prismjs 拥有 Line Highlight 插件（目前还未移植到 Comi）综合上面信息，决定基于 prismjs 二次开发。markdown 渲染预研rich-text\r\n<rich-text nodes=\"{{nodes}}\" bindtap=\"tap\"></rich-text>\r\n复制代码Page({\r\n  data: {\r\n    nodes: [{\r\n      name: 'div',\r\n      attrs: {\r\n        class: 'div_class',\r\n        style: 'line-height: 60px; color: red;'\r\n      },\r\n      children: [{\r\n        type: 'text',\r\n        text: 'Hello World!'\r\n      }]\r\n    }]\r\n  },\r\n  tap() {\r\n    console.log('tap')\r\n  }\r\n})\r\n复制代码综合上面信息，放弃 rich-text，决定基于 wxParse + remarkable 二次开发，移除 showdownjs。Comi 需要 remarkable 的高性能和灵活性。markdown 会持久化存在 db， 在小程序内运行时转换成 wxml，所以对性能还是有一定要求。劫持 prismjs tokenstokens: function (text, grammar, language) {\r\n\t\tvar env = {\r\n\t\t\tcode: text,\r\n\t\t\tgrammar: grammar,\r\n\t\t\tlanguage: language\r\n\t\t};\r\n\t\t_.hooks.run('before-tokenize', env);\r\n\t\tenv.tokens = _.tokenize(env.code, env.grammar);\r\n    _.hooks.run('after-tokenize', env);\r\n\r\n\t\tfor (var i = 0, len = env.tokens.length; i < len; i++) {\r\n      var v = env.tokens[i]\r\n      if (Object.prototype.toString.call(v.content) === '[object Array]') {\r\n        v.deep = true\r\n        this._walkContent(v.content)\r\n      }\r\n    }\r\n    return env.tokens\r\n  },\r\n复制代码这段代码增加 tokens 方法到 prismjs 中，原库自带的 prism.highlight 的会把 tokens 转成 html，因为我们的目标的 wxml，所以这里提前把 tokens 作为方法返回值。当然还做了一件事，就是扩展了 token item 的 deep 属性来决定是否需要继续向下遍历生成 wxml。原始的 jsx:render() {\r\n    const { tks } = this.data\r\n    return (\r\n      <view class='pre language-jsx'>\r\n        <view class='code'>\r\n          {tks.map(tk => {\r\n            return tk.deep ? <text class={'token ' + tk.type}>{\r\n              tk.content.map(stk => {\r\n                return stk.deep ? stk.content.map(sstk => {\r\n                  return <text class={'token ' + sstk.type}>{sstk.content || sstk}</text>\r\n                }) : <text class={'token ' + stk.type}>{stk.content || stk}</text>\r\n              })}</text> : <text class={'token ' + tk.type}>{tk.content || tk}</text>\r\n          })}\r\n        </view>\r\n      </view>\r\n    )\r\n  }\r\n复制代码jsx 编译出生成的 wxml，把这段 wxml 嵌入到 wxparse 里:<!-- 千万 不要格式化下面的 wxml，不然 text 嵌套 text 导致换行全部出来了 -->\r\n<template name=\"wxParseCode\">\r\n  <view class=\"pre language-jsx\">\r\n      <view class=\"code\">\r\n          <block wx:for=\"{{item.tks}}\" wx:for-item=\"tk\">\r\n              <block wx:if=\"{{tk.deep}}\"><text class=\"{{'token ' + tk.type}}\"><block wx:for=\"{{tk.content}}\" wx:for-item=\"stk\"><block wx:if=\"{{stk.deep}}\"><text class=\"{{'token ' + sstk.type}}\" wx:for=\"{{stk.content}}\" wx:for-item=\"sstk\">{{sstk.content || sstk}}</text>\r\n              </block>\r\n              <block wx:else><text class=\"{{'token ' + stk.type}}\">{{stk.content || stk}}</text>\r\n              </block>\r\n          </block>\r\n          </text>\r\n  </block>\r\n  <block wx:else><text class=\"{{'token ' + tk.type}}\">{{tk.content || tk}}</text>\r\n  </block>\r\n  </block>\r\n  </view>\r\n  </view>\r\n</template>\r\n复制代码这段 wxml 不能进行格式化美化，不然多出许多换行符，因为 text 嵌套 text 会保留换行符！！修改 wxparse 里的分支逻辑：<block wx:elif=\"{{item.tagType == 'block'}}\">\r\n  <view class=\"{{item.classStr}} wxParse-{{item.tag}}\" style=\"{{item.styleStr}}\">\r\n    <block wx:if=\"{{item.tag == 'pre'}}\">\r\n        <template is=\"wxParseCode\" data=\"{{item}}\" />\r\n    </block>\r\n    <block wx:elif=\"{{item.tag != 'pre'}}\" >\r\n      <block wx:for=\"{{item.nodes}}\" wx:for-item=\"item\" wx:key=\"\">\r\n        <template is=\"wxParse1\" data=\"{{item}}\" />\r\n      </block>\r\n    </block>\r\n  </view>\r\n</block>\r\n复制代码当 item.tag 为 pre 的时候使用 wxParseCode 模板，数据传入 item。item 的数据从哪里来？先修改 md 渲染器为 Remarkable:} else if (type == 'md' || type == 'markdown') {\r\n  var converter = new Remarkable()\r\n  var html = converter.render(data)\r\n  transData = HtmlToJson.html2json(html, bindName);\r\n}\r\n复制代码使用上面的 prism.tokens 计算出代码片段的 tokens，用于 wxparse 的模板渲染：function transPre(transData) {\r\n  transData.nodes.forEach((node, index) => {\r\n    if (node.tag == 'pre') {\r\n      var lan = 'markup'\r\n      if (node.nodes[0].classStr) {\r\n        lan = node.nodes[0].classStr.split(' ')[0].replace('language-', '')\r\n      }\r\n      var tks = prism.tokens(node.nodes[0].nodes[0].text, prism.languages[lan], lan)\r\n      transData.nodes[index].tks = tks\r\n    }\r\n  })\r\n}\r\n复制代码language- 支持多少种呢？目前 comi 默认支持：markupcssclikejavascriptbashjsontypescriptjsxtsx默认使用的主题 css 是 okaidia。如果 comi 默认的配置不支持你的需求，你可以：进 prismjs.com/download.ht… 这里自行下载劫持 prismjs tokens 拷贝进你下载的 prismjs 里把 prismjs 拷贝替换掉 comi 自带的 prismjs精简 comi 使用流程WXML 提供两种文件引用方式 import 和 include。和 import 不同，include 可以将目标文件除了 template 和 wxs 外的整个代码引入，相当于是拷贝到 include 位置，如：<!-- index.wxml -->\r\n<include src=\"header.wxml\" />\r\n<view>body</view>\r\n<include src=\"footer.wxml\" />\r\n复制代码<!-- header.wxml -->\r\n<view>header</view>\r\n复制代码<!-- footer.wxml -->\r\n<view>footer</view>\r\n复制代码comi 利用了 import 和 include 特性简化使用流程：comi.wxml<import src=\"./wxParse.wxml\"/>\r\n<template is=\"wxParse\" data=\"{{wxParseData:article.nodes}}\"/>\r\n复制代码comi.jsvar WxParse = require('./wxParse.js');\r\n\r\nmodule.exports = function comi(md, scope) {\r\n  WxParse.wxParse('article', 'md', md, scope, 5);\r\n}\r\n复制代码comi.wxss@import './wxParse.wxss';\r\n@import './prism.wxss';\r\n复制代码使用时，只需要 ：comi.js\r\ncomi.wxml\r\ncomi.wxss\r\n另外，在 omip 使用 comi 时候发现不会拷贝 include 的文件到 dist，发现 taro/omip 的正则没有去匹配 include 文件，所以，把：exports.REG_WXML_IMPORT = /<[import](.*)?src=(?:(?:'([^']*)')|(?:\"([^\"]*)\"))/gi\r\n复制代码改成:exports.REG_WXML_IMPORT = /<[import|inculde](.*)?src=(?:(?:'([^']*)')|(?:\"([^\"]*)\"))/gi\r\n复制代码搞定。"}
{"title": "基于后端云微信小程序开发 ", "author": "Rolan", "pub_time": "2018-7-25 00:29", "content": "人的一生90%的时间都在做着无聊的事情，社会的发展使得我们的闲暇时间越来越多，我们把除了工作的其他时间放在各种娱乐活动上。程序员有点特殊，他们把敲代码看成娱乐活动的一部分，以此打发时间的不占少数。这不最近无聊搞了一个口袋吉他小程序，使用bmob后端云提供数据存储服务，除吉他谱图片，其他图片存储在七牛。关于bmob小程序开发文档请戳这里，文档详细简练，主要是缩短了开发周期，不过对于复杂的项目，还是推荐使用自己服务器提供数据服务。使用微信扫描二维码预览源码地址： github.com/alex1504/wx…下面分点分享下小程序的开发过程中的关键点及感受，说明：小程序标签统称组件，Html标签统称元素。部分内容会与vuejs及jQuery作对比使用iconfont字体图标新建项目并添加图标在app.wxss中以unicode方式引入@font-face {\r\n  font-family: 'iconfont';  /* project id 431644 */\r\n  src: url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.eot');\r\n  src: url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.eot?#iefix') format('embedded-opentype'),\r\n  url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.woff') format('woff'),\r\n  url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.ttf') format('truetype'),\r\n  url('//at.alicdn.com/t/font_431644_aahynh26y6lp7gb9.svg#iconfont') format('svg');\r\n}\r\n复制代码定义通用icon样式，定义伪元素.icon{\r\n  display: inline-block;\r\n  font-family: 'iconfont';\r\n}\r\n.icon-home::before{\r\n  content: \"\\e600\";\r\n}\r\n复制代码使用<view class=\"icon icon-home\"</view>\r\n复制代码小程序事件绑定及处理器小程序并没有类似vuejs的v-model进行双向绑定，使用bindinput类似jQuery监听input事件在事件处理器中更新数据，通过event对象e.data.value即可获得input的值。// bindconfirm监听键盘回车事件，focus属性聚焦渲染组件时会自动弹出手机软键盘\r\n<input type='text' placeholder='歌曲名 / 歌手' bindinput='bindSearchInput' bindconfirm='onSearch' focus></input>\r\n复制代码bindSearchInput(e) {\r\n  this.setData({\r\n    searchTxt: e.detail.value\r\n  })\r\n}\r\n复制代码小程序中的事件处理器并不能像vue一样传入参数，因为事件处理器只有一个默认的参数event对象，在for循环的组件中如果要想获取元素绑定的id，可以通过和jQuery相同的方式绑定data属性。<!-- 轮播图 -->\r\n<swiper indicator-dots=\"{{indicatorDots}}\" autoplay=\"{{autoplay}}\" interval=\"{{interval}}\" duration=\"{{duration}}\">\r\n  <block wx:for=\"{{banner_list}}\" wx:key=\"{{index}}\">\r\n    <swiper-item bindtap=\"navigateToDetail\"  data-id=\"{{item.href}}\">\r\n      <image src=\"{{item.image}}\" class=\"slide-image\" mode=\"widthFix\"></image>\r\n    </swiper-item>\r\n  </block>\r\n</swiper>\r\n复制代码获取id：//事件处理函数\r\nnavigateToDetail: function (e) {\r\n  const id = e.currentTarget.dataset.id;\r\n}\r\n复制代码阻止事件冒泡bindtap、bindlongtap、bindtouchstart、bindtouchmove、bindtouchend、bindtouchcancle\r\n复制代码对应阻止冒泡事件将bind用catch替代setData小程序的视图更新需要调用setData修改绑定数据，直接对数据进行修改是不会触发视图层更新的。setData接受一个对象，为需要添加或修改的属性。属性名有点特殊，[]中的值会被识别为变量，因此如果要对对象数组中的某个属性进行修改，只能预先拼接好属性名。 错误做法：// 视图不更新\r\nthis.data.searchSongs[index].love_flag': 2\r\n// SyntaxError: unknown: Unexpected token\r\nthis.setData({\r\n  'searchSongs[' + index + '].love_flag': 2\r\n})\r\n复制代码正确做法：setSongFlag(e) {\r\n// 注意setData属性名[]中的非整数值会被识别为变量\r\nlet key = 'searchSongs[' + index + '].love_flag'\r\nthis.setData({\r\n  [key]: 2\r\n})\r\n复制代码关于image组件小程序wxss的background-image及image组件都不支持本地url 在H5的开发中，通常我们会将页面一些不需要根据容器大小来选择显示方式的图片使用img标签，需要一些特殊显示方式的使用background。但小程序只需要image组件便可。它提供的mode属性和背景定义图片及img元素控制图片显示方式对比mode属性background-sizehtml img元素scaleToFill100%,100%(默认)width:100%;height:100%aspectFitcontainjs实现aspectFillcoverjs实现widthFix100%, autowidth: 100%;其他的top、bottom、right、left等不缩放图片调整位置的属性与background-position作用相同，img元素则只能通过定位控制。小程序API异步方案如果没有强迫症，小程序API使用默认回调的方式即可；另外由于小程序只支持es6，不支持async及await，也可以将API封装成promise的方式。function promisify(fn) {\r\n  return function (obj = {}) {\r\n    return new Promise((resolve, reject) => {\r\n      obj.success = function (res) {\r\n        resolve(res)\r\n      }\r\n\r\n      obj.fail = function (res) {\r\n        reject(res)\r\n      }\r\n\r\n      fn(obj)//执行函数，obj为传入函数的参数\r\n    })\r\n  }\r\n}\r\nmodule.exports = {\r\n    promisify: promisify\r\n}\r\n复制代码使用：const promisify = require('./promisify.js')\r\nconst request = promisify(wx.request);\r\n\r\nrequest({\r\n    url: 'some URL'\r\n    method: 'GET',\r\n}).then(res => {   \r\n    console.log(res)                 \r\n}\r\n复制代码小程序问题调试器没有css快捷提示功能和颜色面板，影响布局及颜色调整效率（随性派）无法引入第三方js库内置组件单调，没有考虑字体数量比较多时的自适应情况不支持跳转外部链接背景图片或者image组件不能用本地图片关于小程序审发布或更新小程序上线需要经过审核、发布两个过程。 审核通过后有全量更新、或者分阶段发布，小程序才会更新，首次发布没有选项。全量发布：即时向全量微信用户发布新版小程序。 分阶段发布：新版小程序将在15天内以开发者自定义比例，向微信用户发布更新 详情见知乎： 发布小程序时选择全量发布和分阶段发布是什么意思？不得不说小程序审核速度是非常快的，即便是个人申请（相比以企业账号申请会有应用服务类型限制），通常小程序没有涉及政策不允许的内容或者超过小程序允许的应用服务类型，都是可以顺利通过，初次体验，即便在国庆期间，也是有工作团队进行审核，审核时间通常在几小时内。总结在开发这个小程序时，微信小程序只支持页面级开发，如今小程序已支持组件开发和插件开发。组件的结构和页面并无区别，自定义组件可以引入其他的组件，具体的开发步骤可以参考这边文章 【微信小程序】自定义组件小程序的兴起使得前端开发又多了一个工作任务，但这也使得前端程序员的成就感越来越强，当然没有经历过浏览器刀耕火种年代的工程师难以体会这种辛酸，但也没必要，只要跟上时代的潮流和注重自身的基础建设便已足够了，前端路途艰辛，我在路上与你共勉。"}
{"title": "微信小程序里如何用阿里云上传视频图片 ", "author": "Rolan", "pub_time": "2019-4-9 00:43", "content": "微信小程序里如何用阿里云上传视频，图片。。 纯手写，踩了半天多的坑干出来了。。。网上也有对于阿里云如何在微信小程序里使用，但是很不全，包括阿里云文档的最佳实践里。话不多说上代码了。 1   upvideo(){ 2          var aliOssParams =  util.aliOssParams();//主要是获取上传阿里云的加密策略policy和签名signature;以及上传自己要上传到阿里云的地址,当然还有自己阿里云accessid。 3           //上传视频到阿里云 4           var that = this; 5           wx.chooseVideo({ 6              maxDuration: 10, 7              success: function (res) { 8                var tempFilePath = res.tempFilePath; 9                var stringFilePath = String(tempFilePath);10                var indexType = stringFilePath.lastIndexOf('.');11                var type = stringFilePath.substring(indexType);12                var alikey = 'video/'+new Date().getTime() + 13                 Math.floor(Math.random() * 1000)+ type ;//随机1000内的数加上时间戳作为你存放在阿里云video目录下名字和类型。14                wx.uploadFile({15                  url:aliOssParams.host,16                  filePath: tempFilePath,17                  name: 'file',18                  formData: {19                    name: tempFilePath,20                    key: alikey,//这个是关键它是定义存放在阿里云那个目录下21                    policy:aliOssParams.policy,//上传阿里云的加密策略22                    OSSAccessKeyId: aliOssParams.aid,//自己阿里云的aid23                    success_action_status: \"200\",24                    signature: aliOssParams.signature,//上传阿里云的签名25                  },26                  success: function (res) {27                   var videoUrl = aliOssParams.host+'/'+alikey;//这就是28              刚上传阿里云后的存放的地址链接，通过它打开你刚上传视频。29                   that.videoUrl = videoUrl;30                    console.log('that',that,videoUrl);31                    wx.showToast({32                      title: \"上传成功\",33                      icon: 'success',34                      duration: 100035                    })36                  },37                  fail: function ({ errMsg }) {38                    wx.showToast({39                      title: \"上传失败\",40                      duration: 100041                    })42                  },43                })44              }45            })46         通过代码大家可以看到最关键的是啥，如何获取加密策略和签名了，当然了，阿里云最佳实践里有demo，但是crypto这个库已经废弃了，它demo给你带过来的crypto，你只能自己去提取了。　这里是我提为大家提取的crypto函数,直接copy用。View Code　　有了上面的crypto工具函数了，就去看看具体如何生成签名与加密策略吧。。import base64 from \"base-64\"import {Crypto} from \"./crypto.js\"const util = {    aliOssParams(){        var aid = \"xxxxxxx\";//你自己的阿里云的accessid        var aky=\"xxxxxxxxxx\";//你自己的阿里云的accesskey        var host = \"https://xxxxxxxxx.aliyuncs.com\";//你自己的阿里云域名        var policyText = {                \"expiration\": \"2022-01-01T12:00:00.000Z\",//上传的文件失效日期自己定义                \"conditions\": [                [\"content-length-range\", 0, 10485760000]//上传的内容大小，自己定义                ]        };        var policy = base64.encode(JSON.stringify(policyText));//生成的加密策略        var bytes = Crypto.util.HMAC(Crypto.util.SHA1, policy, aky, { asBytes: true }) ;        var signature = Crypto.util.bytesToBase64(bytes);//生成的签名        return {                        policy: policy,                       signature:signature,                      aid:aid,                      host: host                   }    }}export {util}                                                                               至于如何上传图片，大体如下，请保证以上都已经跑通了，base64记得你上面引到。。多张图片的上传如此upMyImg(){  var aliOssParams =  util.aliOssParams();  var that = this;  wx.chooseImage({     count: 9,  //最多可以选择的图片总数     // sizeType: ['compressed'], // 可以指定是原图还是压缩图，默认二者都有     sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有     success: function (res) {       // 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片       var tempFilePaths = res.tempFilePaths;       //启动上传等待中...       wx.showToast({         title: '正在上传...',         icon: 'loading',         mask: true,         duration: 10000       })       var uploadImgCount = 0;       var tempFilePath;       var stringFilePath = '';       var alikey = '' ;       var type='';       for (var i = 0, h = tempFilePaths.length; i < h; i++) {            // stringFilePath= String(tempFilePaths[i]);            // type = stringFilePath.substring(stringFilePath.lastIndexOf('.'));            alikey = 'imagees/'+new Date().getTime() + Math.floor(Math.random() * 150)+ '.jpg';            that.srcs.push(tempFilePaths[i]);            that.setData({srcs: that.srcs});         wx.uploadFile({           url: aliOssParams.host,           filePath: tempFilePaths[i],//上传图片的路径           name: 'file',           formData: {             key: alikey,             name: tempFilePaths[i],             policy:aliOssParams.policy,             OSSAccessKeyId: aliOssParams.aid,             success_action_status: \"200\",             signature: aliOssParams.signature,           },           success: function (res) {             uploadImgCount++;             console.log('rrrs',res,tempFilePaths[i]);             // var data = JSON.parse(res.data);             //服务器返回格式: { \"Catalog\": \"testFolder\", \"FileName\": \"1.jpg\", \"Url\": \"https://test.com/1.jpg\" }             // console.log('rrr',data);             console.log('ddd222',res,aliOssParams.host,alikey);             // var productInfo = that.data.productInfo;             // if (productInfo.bannerInfo == null) {             //   productInfo.bannerInfo = [];             // }             // productInfo.bannerInfo.push({             //   \"catalog\": data.Catalog,             //   \"fileName\": data.FileName,             //   \"url\": data.Url             // });             // that.setData({             //   productInfo: productInfo             // });             //如果是最后一张,则隐藏等待中             if (uploadImgCount == tempFilePaths.length) {                 // that.srcs.push(tempFilePaths[i]);                 console.log(that.srcs,3222);               wx.hideToast();               wx.showToast({                 title: \"上传成功\",                 icon: 'success',                 duration: 1000               })             }           },           fail: function (res) {             wx.hideToast();             wx.showModal({               title: '错误提示',               content: '上传图片失败',               showCancel: false,               success: function (res) { }             })           }         });       }     }   })// 上传图片完}　　都是自己亲测，亲坑。。。解决了你的问题，就随手一赞。。"}
{"title": "微信小程序开发框架从入门到放弃 ", "author": "Rolan", "pub_time": "2018-7-23 00:40", "content": "用框架是不可能用框架的，这辈子都不可能用框架。微信小程序上手成本低，开发成本低，流量红利，推广成本低等等，很多公司的创业项目都会首选小程序来试水，小程序开发太火爆了,苦逼了前端工程师，又得学习新技术...学习让我快乐半年时间，我已经开发了四个小程序，其中三个微信小程序，一个支付宝小程序。原生开发过，框架也用过。到底最优雅的开发模式是什么呢，聊聊，聊聊。技术方案目前开发微信小程序时，可选的技术方案大概有若干种，分别是：微信小程序原生开发使用wepy框架使用mpvue框架使用taro框架其他框架使用框架来开发，总结起来就干了一件事——加糖，但这糖好不好呢，不好说。框架开发的初(li)衷(xiang)快速迭代减少开发成本跨平台共享提升开发体验框架开发的挑(xian)战(shi)必须同时熟悉微信小程序文档和第三方框架文档，给工程师提出了更大的挑战框架的不完美，只是阉割版或者修改版的前端框架，并没有100%支持框架自身特性框架构建与微信小程序之上，反而导致部分原生支持的特性作废，比如原生组件，模块化等框架生态不健全，文档及相关资源匮乏微信小程序自身处于快速迭代的状态，特性并不稳定，不像web一样有统一的标准理想很美好，现实很残酷wepy框架来说，组件化的支持不成熟，在实际的开发过程中，如果组件嵌套超过两层，面对某些特殊业务场景，翻车几率很高。组件的列表渲染，不支持在 repeat 的组件中去使用 props, computed, watch 等等特性。mpvue框架是基于Vue.js的核心，属于修改版的vue框架，用起来和web端的vue也有些差异。美团小程序框架--mpvue入坑指南我的想法使用第三方框架开发，可以享受框架带来的开发便利，但对于小程序新增的诸多特性和功能，比如WXS模块、自定义组件和插件等，受制于第三方框架，无法使用。而原生小程序的开发模式，又过于简陋，就样式来说，写惯了less，stylus和sass的同学一定无法忍受wxss的这种写法，基于此，决定使用gulp自动化工具来构建一套微信小程序开发的基础模板，在完全保留微信小程序功能和特性的基础上，又可以的使用less来写样式，同时加入图片压缩，命令行快速创建模板等特性，如此开发，快哉，快哉！wx-miniprogram-boilerplate后续会再加入其它工具，持续更新，欢迎各位提意见。"}
{"title": "微信小程序内使用canvas绘制自定义折线图表 ", "author": "Rolan", "pub_time": "2019-4-10 00:54", "content": "话不多说，最终实现效果如下：图中难点：圆角矩形绘制；转载他人帖子：看此处：https://www.jb51.net/article/...最左或者最右边的气泡需要做动态偏移本项目是由mpvue写的小程序：所以用的是vue的书写格式（微信小程序可以自行修改）：使用方法：将下列代码新建linechart.vue文件再项目中调用本组件的drawAll方法传入日期和值即可代码中有少量注解请不懂的给我留言<template>\r\n    <div class=\"linechart\">\r\n        <canvas class=\"circle\"  canvas-id=\"canvasline\" style=\"width: 750rpx;height: 280rpx;\">\r\n        </canvas></div>\r\n</template>\r\n\r\n<script>\r\n     export default {\r\n         data() {\r\n            return {\r\n                canvasWidth: 375,\r\n                canvasHeight: 123,\r\n                date: ['-/-','-/-','-/-','-/-','-/-','-/-','-/-'],\r\n                value: [0,0,8,10,6,0,0,],\r\n                len: 4,\r\n                xcoords: []\r\n            }\r\n         },\r\n        onLoad() {\r\n            this.drawAll()\r\n        },\r\n        methods: {\r\n            drawAll(date, value) {\r\n                this.date = date || this.date\r\n                this.value = value || this.value\r\n                var ctx = wx.createCanvasContext('canvasline')\r\n                this.roundRect(ctx, this.px2PX(10), 0, this.px2PX(this.canvasWidth) - this.px2PX(20), this.px2PX(this.canvasHeight), this.px2PX(8), '#F5F3ED');\r\n                this.drawYLine(ctx, this.px2PX(20), 0, this.px2PX(20), this.px2PX(this.canvasHeight),this.px2PX(55), this.px2PX(1), 'white')\r\n                this.drawXLine(ctx, this.len, this.px2PX(1), 'white');\r\n                this.drawLine(ctx, this.px2PX(1.5), this.px2PX(3))\r\n                ctx.draw()\r\n            },\r\n            px2PX(px) { // px (Int) 375为设计稿宽度，根据屏幕动态设置像素大小解决模糊问题和适配\r\n                return  (wx.getSystemInfoSync().screenWidth / 375) * Number(px)\r\n            },\r\n            /**\r\n              * \r\n              * @param {CanvasContext} ctx canvas上下文\r\n              * @param {number} x 圆角矩形选区的左上角 x坐标\r\n              * @param {number} y 圆角矩形选区的左上角 y坐标\r\n              * @param {number} w 圆角矩形选区的宽度\r\n              * @param {number} h 圆角矩形选区的高度\r\n              * @param {number} r 圆角的半径\r\n              * @param {color} fillColor 填充的颜色\r\n            */\r\n            // 绘制矩形\r\n            roundRect(ctx, x, y, w, h, r, fillColor) {\r\n                if (w < 2 * r) r = w / 2;\r\n                if (h < 2 * r) r = h / 2;\r\n                // 开始绘制\r\n                ctx.beginPath()\r\n                // 因为边缘描边存在锯齿，最好指定使用 transparent 填充\r\n                // 这里是使用 fill 还是 stroke都可以，二选一即可\r\n                // ctx.setFillStyle('transparent')\r\n                // ctx.setStrokeStyle('transparent')\r\n                // 左上角\r\n                ctx.arc(x + r, y + r, r, Math.PI, Math.PI * 1.5)\r\n\r\n                // border-top\r\n                ctx.moveTo(x + r, y)\r\n                ctx.lineTo(x + w - r, y)\r\n                ctx.lineTo(x + w, y + r)\r\n                // 右上角\r\n                ctx.arc(x + w - r, y + r, r, Math.PI * 1.5, Math.PI * 2)\r\n\r\n                // border-right\r\n                ctx.lineTo(x + w, y + h - r)\r\n                ctx.lineTo(x + w - r, y + h)\r\n                // 右下角\r\n                ctx.arc(x + w - r, y + h - r, r, 0, Math.PI * 0.5)\r\n\r\n                // border-bottom\r\n                ctx.lineTo(x + r, y + h)\r\n                ctx.lineTo(x, y + h - r)\r\n                // 左下角\r\n                ctx.arc(x + r, y + h - r, r, Math.PI * 0.5, Math.PI)\r\n\r\n                // border-left\r\n                ctx.lineTo(x, y + r)\r\n                ctx.lineTo(x + r, y)\r\n                ctx.setFillStyle(fillColor);\r\n                // 这里是使用 fill 还是 stroke都可以，二选一即可，但是需要与上面对应\r\n                ctx.fill()\r\n                // ctx.stroke()\r\n                ctx.closePath()\r\n                // 剪切\r\n                // ctx.clip()\r\n            },\r\n            /**\r\n              * \r\n              * @param {CanvasContext} ctx canvas上下文\r\n              * @param {number, number, number, number} x1, y1, x2, y2 第一条线的起始坐标和结束坐标\r\n              * @param {number} spacing 线条直接的间隔\r\n              * @param {number} lineWidth 线条宽度\r\n              * @param {color} color线条的颜色\r\n            */\r\n            // 绘制竖线网格和底部文字\r\n            drawYLine(ctx, x1, y1, x2, y2, spacing, lineWidth, color) {\r\n                ctx.beginPath();\r\n                let width = this.px2PX(this.canvasWidth) - (x1 * 2)\r\n                let len = Math.floor(width /spacing)\r\n                for (let i = 0; i <= len; i++) {\r\n                    let spaced = spacing * i + i;\r\n                    this.xcoords.push(x1 + spaced)\r\n                    ctx.setLineWidth(lineWidth)\r\n                    ctx.setStrokeStyle(color)\r\n                    ctx.moveTo(x1 + spaced, y1);\r\n                    ctx.lineTo(x2 + spaced, y2);\r\n                    /* --- 底部标尺文字 -- */\r\n                    ctx.setFontSize(this.px2PX(12));\r\n                    ctx.setTextAlign('center');\r\n                    ctx.setFillStyle('#DFDACD');\r\n                    ctx.fillText(this.date[i], x1 + spaced, y2 + this.px2PX(14))\r\n                    /* ---- 底部标尺文字 --- */\r\n                }\r\n                ctx.stroke()\r\n            },\r\n            /**\r\n              * \r\n              * @param {CanvasContext} ctx canvas上下文\r\n              * @param {number} len 绘制多少条横线\r\n              * @param {number} lineWidth 线条宽度\r\n              * @param {color} color线条的颜色\r\n            */\r\n            // 绘制横线网格\r\n            drawXLine(ctx, len, lineWidth, color) {\r\n                ctx.beginPath();\r\n                let spaced = this.px2PX(this.canvasHeight) / len\r\n                let x = this.px2PX(this.canvasWidth)\r\n                for (let i = 0; i < len; i++) {\r\n                    let hei = spaced * i + i\r\n                    ctx.moveTo(0, hei);\r\n                    ctx.lineTo(x, hei);\r\n                }\r\n                ctx.setLineWidth(lineWidth)\r\n                ctx.setStrokeStyle(color)\r\n                ctx.stroke()\r\n            },\r\n            /**\r\n              * \r\n              * @param {CanvasContext} ctx canvas上下文\r\n              * @param {number} width 折线的线条宽度\r\n              * @param {number} r 折线拐角的圆的半径\r\n            */\r\n            // 绘制折线，折线区域，气泡，气泡文字\r\n            drawLine(ctx, width,r) {\r\n                let arrMax = Math.max.apply({},this.value)\r\n                let height = this.px2PX(this.canvasHeight)\r\n                let hei = this.px2PX(this.canvasHeight) - this.px2PX(24)\r\n                let average = arrMax <= 0 ? 0 : hei / arrMax\r\n                let len = this.value.length - 1\r\n                ctx.beginPath();\r\n                /* 折线 */\r\n                for (let i = 0; i < len; i++) {\r\n                    let x1 = this.xcoords[i], y1 = height - this.value[i] * average, x2 = this.xcoords[i+1], y2 =  height - this.value[i + 1] * average\r\n                    ctx.moveTo(x1, y1)\r\n                    ctx.lineTo(x2, y2)\r\n                }\r\n                ctx.setStrokeStyle('#F9B213');\r\n                ctx.setLineWidth(width);\r\n                ctx.stroke()\r\n                /* 折线 */\r\n                /* 折线区域 */\r\n                ctx.beginPath();\r\n                for (let i = 0; i < len; i++) {\r\n                    let x1 = this.xcoords[i], y1 = height - this.value[i] * average, x2 = this.xcoords[i+1], y2 = height - this.value[i + 1] * average\r\n                    ctx.moveTo(x1, y1)\r\n                    ctx.lineTo(x2, y2)\r\n                    ctx.lineTo(x2, height)\r\n                    ctx.lineTo(x1, height)\r\n                }\r\n                /* 折线区域 */\r\n                ctx.setFillStyle('rgba(249,178,19,0.08)');\r\n                ctx.fill();\r\n                \r\n                for (let i = 0; i <= len; i++) {\r\n                    let x1 = this.xcoords[i], y1 = height - this.value[i] * average\r\n                    ctx.beginPath();\r\n                    ctx.arc(x1, y1, r, 0, 2 * Math.PI)\r\n                    ctx.setStrokeStyle('#F9B213');\r\n                    ctx.setLineWidth(width);\r\n                    \r\n                    ctx.setFillStyle('white');\r\n                    ctx.fill();\r\n                    ctx.stroke()\r\n                }\r\n                for (let i = 0; i <= len; i++) {\r\n                    let x1 = this.xcoords[i], y1 = height - this.value[i] * average\r\n                    let defaultWidth = this.px2PX(24), defaultHeight = this.px2PX(16)\r\n                    let fontsize = this.px2PX(10)\r\n                    let lense = this.value[i].toString().length\r\n                    if (lense > 1) {\r\n                        defaultWidth = defaultWidth + lense * fontsize / 2.5\r\n                    }\r\n                    let x = x1 - defaultWidth / 2\r\n                    let y = y1 - defaultHeight - r * 2\r\n                    if (i === 0) { // 第一个文字tip向右\r\n                        x = x1 - fontsize / 2\r\n                        ctx.setTextAlign('left');\r\n                    } else if (i === len) { // 最后一个文字tip向左\r\n                        x = x - defaultWidth / 2 + fontsize / 2\r\n                        ctx.setTextAlign('right');\r\n                    } else {\r\n                        ctx.setTextAlign('center');\r\n                    }\r\n                    this.roundRect(ctx, x, y, defaultWidth, defaultHeight, this.px2PX(8), 'white')\r\n                    ctx.beginPath();\r\n                    ctx.setFontSize(fontsize);\r\n                    ctx.setFillStyle('#F9B213');\r\n                    ctx.fillText('+'+this.value[i], x1, y1 - this.px2PX(10))\r\n                    ctx.closePath()\r\n                }\r\n            }\r\n        }\r\n     }\r\n</script>\r\n\r\n<style lang=\"scss\">\r\n    .linechart {\r\n        width: 750upx;\r\n        height: 280upx;\r\n    }\r\n</style>\r\n以上列子如有疑问，请给我留言。"}
{"title": "小程序框架的简单封装 ", "author": "Rolan", "pub_time": "2019-2-27 00:38", "content": "解决的问题app onLaunch 等周期函数以及登录请求和 page 的周期函数的执行是异步的，导致两者不能衔接的问题page 周期函数中 返回页面和进入页面以及挂起后重回页面 onshow 周期函数无法区分的问题第三方埋点操作侵入性过强的问题App.ready - Promise一个 Promise 实例，成功表示登录流程和初始信息加载流程完成；一般不需要显式调用，新增的onCreated和onForward生命周期函数在内部使用该 Promise 实例Frame用于初始化注入，并返回 Main 函数import Frame from './frame/index';\r\nconst Main = Frame({\r\n  env,\r\n  init: () => {},\r\n  loginToSite: () => {},\r\n});\r\nMain({});注入 env, 详见 env注入 init 方法，非必填： App 登录之后需要执行的初始操作； 一般可以在这里做初始信息加载等操作； 每次启动app，该方法都会执行，如果没有登录，该方法会在登录后执行，并接收登录接口的结果作为参数； 返回一个 Promise 实例；注入登录到服务器 loginToSite 方法，非必填： 返回一个 promise 实例；该方法会接收到一个参数：data = {\r\n  code,\r\n  encrypted_data, // 授权后才会有\r\n  iv, // 授权后才会有\r\n}Main对 App 函数的封装添加的功能函数methodCaptured: page实例或component实例中任何函数的执行都会触发该函数的执行，并传递参数到该函数，不包含生命周期函数； 该函数可以实现代码无侵入埋点等操作options = {\r\n  route, // page 里为 this.route comp 里为 this.is\r\n  name, // 函数名\r\n  event, // 事件对象\r\n  result, // 函数执行的返回值\r\n  scope, // page 或者 component 实例\r\n}App.Page - Method对 Page 函数的封装App.Page({});删除的生命周期函数onLoadonShow添加的生命周期函数：onCreated: 替代 onLoad，小程序登陆流程和初始信息加载流程完毕后触发，在内部使用 App.readyonAppear: 替代 onShow，如果想有和onCreated一样的触发时机，则可以使用 App.ready 实例onForward: 页面进入并显示时触发，小程序登陆流程和初始信息加载流程完毕后触发，在内部使用 App.readyonBackward: 返回到当前页面并显示时触发onReappear: 切换到后台又恢复显示时触发注：其他配置和原框架一致App.Comp - Method替代 Component 函数，组件需使用 lifetimes 字段来管理生命周期，写在外部的生命周期函数将不起作用App.Comp({});Network以下方法都进行了 promisify ，除了 App.FC ，其他方法都在 promise 实例上挂载了 task 对象App.FC - Object小程序请求接口的封装，用法类似 axios，提供拦截器和默认设置等操作const FC = App.FC;\r\nFC.defaults = {};\r\n// 拦截器支持链式调用\r\n// middleware: async function | common function | common function with promise\r\n// reqWall callback 参数为 options 请求配置，并且需要返回 options\r\n// resWall callback 参数为 res 请求结果，并且需要返回 res\r\n// callback 返回为 promise 时，promise 的 resolve 必须相应的传递 options 或 res\r\n// callback 绑定了请求实例\r\nFC.reqWall\r\n  .add(middleware)\r\n  .remove(middleware)\r\nFC.resWall\r\n  .add(middleware)\r\n  .remove(middleware)\r\nFC.fetch(options);\r\nconst ins = FC.create(defaults);\r\nins.defaults = {}; // 会覆盖 create 方法里的 defaults\r\nins.reqWall\r\n  .add(middleware)\r\n  .remove(middleware)\r\nins.resWall\r\n  .add(middleware)\r\n  .remove(middleware)\r\nins.fetch(options);\r\n\r\n// 选项\r\noptions = {\r\n  baseURL: '',\r\n  url: '',\r\n  data: Object.create(null),\r\n  header: Object.create(null),\r\n  method: 'GET',\r\n  dataType: 'json',\r\n  responseType: 'text',\r\n  validateStatus: status => status >= 200 && status < 300 || status === 304,\r\n};App.DL - Method小程序下载接口的封装App.UL - Method小程序上传接口的封装App.WS - Method小程序双工通讯接口的封装envAPP_STORE_KEY: '', // 存储app信息的 localStorege key\r\nBASE_TOKEN: '', // 基础 token\r\nLOGIN_URL: '',  // 登录到站点的url\r\nLOGIN_TYPE: '', // 登录类型 both_login | auth_login | silent_login 默认 both_login\r\nINDEX_ROUTE: '', // 主页路径，没有前置/，默认 pages/index/index\r\nCHECK_SESSION_TYPE: '', // 检测session的方式 api | store 默认 api\r\nNAV_BAR_MODE: '', // 自定义组件nav-bar模式 dark | light  默认 darkstoreapp.store 相当于 app.globalData默认有：systemInfo, // wx.getSystemInfoSync 的结果\r\nnavBarInfo, // 导航栏相关布局信息\r\nuserInfo, // 默认为空对象runtime添加了以下内容的支持async function\r\nPromise.prototype.finally\r\n在需要使用 async 函数的文件里顶部添加如下代码：  const regeneratorRuntime = App.regeneratorRuntime;Login在 config 文件里配置登录类型，除 login 方法外的其他三个方法已挂载到 app 实例上authLogin: 授权登录，只有授权后才会调用登录流程，并获取用户微信信息silentLogin: 静默登录，不需要用户授权，执行静默登录bothLogin: 兼容登录，授权情况下，调用authLogin，没有授权，调用silentLoginlogin: 该方法在内部调用，做了是否登录的判断。通过 config 来配置登录方式 (both_login | auth_login | silent_login)，并默认调用 both_login注意：自定义登陆态下，当前页面请求时，session_key 过期，则会重新登录并重新加载页面在做授权登录时，如果需要自行调用上述三个登录函数，则需要按照下面的方式操作：  App.ready = app.authLogin();\r\n  // or\r\n  App.ready = app.silentLogin();\r\n  // or\r\n  App.ready = app.bothLogin();\r\n  App.ready\r\n    .then()\r\n    .catch();Methods各种工具函数，已挂载到 app 实例上// 对 wx.xxxSync 同步api的封装\r\ngetStorage,\r\nsetStorage,\r\nremoveStorage,\r\nclearStorage,\r\n\r\ngetKey, // 获取app存储的某一个数据\r\nsetKey, // 设置app存储的某一个数据\r\nremoveKey, // 删除app存储的某一个数据\r\n\r\ngetSession, // 获取 token\r\nsetSession, // 设置token\r\nremoveSession, // 删除token\r\n\r\nstoreCheckSession, // 基于是否存储 token 判断是否过期\r\nwxCheckSession, // 基于 wx.checkSession 接口判断token是否过期\r\ncheckSession, // 上两个方法的封装\r\n\r\nupdateApp, // 更新app\r\ngetSystemInfo, // 获取系统信息\r\ngetPage, // 获取当前page\r\nrpx2px, // rpx 转换到 px\r\n\r\ngetUserInfo, // promisify 'wx.getUserInfo' api\r\ncheckAuth, // promisify 权限鉴定\r\nloginToWx, // promisify 登陆到 微信服务器\r\nloginToSite, // promisify 登陆到自家服务器内部组件以下两个组件均已添加到全局组件nav-bar: 自定义导航组件@props title // 非必填，标题\r\n@props color // 非必填，标题颜色\r\n@props background // 非必填，导航栏背景\r\n@props fill // 非必填，是否占据空间\r\n@props back // 非必填，是否显示 back 按钮\r\n@props home // 非必填，是否显示 home 按钮\r\n@props mode // 非必填，按钮样式，dark | light\r\nuser-info: 授权 getUserInfo 组件@props visibility // 非必填，外部控制是否显示\r\n@event userinfo // 点击授权按钮事件\r\n@event success // 授权成功事件\r\n@event fail // 授权失败事件\r\n注意登录流程和初始信息加载流程在 App 启动时，只会执行一次，因此除了初始显式的页面，其他页面的 onCreated 等有类似启动时机的周期函数将会很快被执行，因此无需担心新的周期函数会增加页面打开时间；对于全局数据，建议只在app启动时调用一次获取接口，并把数据放到全局数据中，然后其他接口更新相关数据后，也一并更新全局数据即可，好处是不需要每个页面都要获取数据，加快页面显示；"}
{"title": "[微信小程序开发]如何去掉或隐藏小程序顶部栏navigationBar ", "author": "Rolan", "pub_time": "2018-7-30 00:12", "content": "小程序全局配置app.josn增加选项：\"navigationStyle\": \"custom\",具体如下：原生小程序开发打开 app.json：{    \"pages\": [        \"pages/index/index\",        \"pages/logs/index\"    ],    \"window\": {        \"backgroundTextStyle\": \"light\",        \"navigationBarBackgroundColor\": \"#000\",        \"navigationStyle\": \"custom\",        \"navigationBarTitleText\": \"WeChat\"    }}mpvue方式开发小程序>打开 /src/main.js：export default {  config: {    pages: [      'pages/logs/main',      '^pages/index/main'　　],    window: {      backgroundTextStyle: 'light',      navigationBarBackgroundColor: '#666',      navigationStyle: 'custom',      navigationBarTitleText: 'WeChat',      navigationBarTextStyle: '#fff',      enablePullDownRefresh: false,      disableScroll: true    }  }}"}
{"title": "微信小程序开发之从“跳伞”到“吃鸡” ", "author": "Rolan", "pub_time": "2018-7-26 00:28", "content": "写在前边微信小程序随着官方开放越多越多的接口，也是变的越来越火了，越来越多的企业已经开始布局小程序生态。所以，对于我们开发者来说，掌握小程序开发显得分外重要。如果点亮了该技能，那么离升职加薪赢取白富美的日子就又近了一步啦！关于我笔者算是一个野生的程序猿吧，没有什么大厂经验，搞开发就是一个字，干！从不来虚的。因此，随性的性格造就了我全栈（一窍不通）的本事，做项目那就是一把抓，前后端全包，什么前后端撕逼的问题统统没有了，哈哈哈（想想心里还有点小激动）。不过本文笔者只重点分享小程序开发相关的东西，想了解后端的话，可以坐等我下一次的分享哈哈哈（可能会遥遥无期）。准备工作话不多说，进入正题。现在开始分享我是怎么开发完一款小程序的。小程序的官方文档其实写的是很详细很清晰的，相比微信公众号的开发文档来说真的是非常非常的良心，所以开发前浏览一遍开发文档非常关键。下边我分享一下其他准备工作。1. 开发工具工欲善其事，必先利其器，首选的就是把开发环境给弄好咯，我推荐如下：开发工具官方微信开发者工具visio studio code调试工具官方微信开发者工具当然开发工具什么的只要自己习惯就好，我的推荐只是参考。笔者最后习惯是直接在官方的开发者工具上编辑加调试。2. 小程序配置这块的内容官方文档都有详细的教程，我就不多补充啦。总体来说就是需要去申请一个开发者账号，然后配置小程序的基本信息，比较值得重点说的就是小程序api的配置，官方要求必须是https。说到这里，如果读者你的api接口已经了https可以跳过了，如果不是，然后你也像笔者一样是全栈开发，那么笔者将告诉你如何快速让接口踏上https的航班。是的，没错， 就是它！Certbot在官网上选好http服务器和linux系统后，按照命令一个一个敲，就ok了，简直不要太简单。哈哈哈，至于想深入了解这个东东的话，可以去了解下Let's Encrypt开发总算可以正式的开始撸功能了！因为考虑到现在程序猿找对象是真的太难了，所以笔者撸的小程序是一个脱单交友的小程序（单身汪的福音哦），小程序页面也不多，核心就是让用户填写个人信息然后展示出来。是的，就是这么简单！授权登录小程序的授权登录其实可以看作是两件事情，授权和登录，这两者是可以单独分开处理的（个人观点，允许反驳）。授权对于授权，其实官方已经有讲到，就是换成微信内的授权询问，就是如下这个东西。这个微信授权的询问弹窗之前的版本中只要调用获取用户信息的api，是会自动弹出的，现在小程序做了调整需要自行通过按钮触发，所以这个很蛋疼。那么需要怎么去设计呢，这里也有两个方案，一个是做个单独的页面，另一个方案是做弹窗。个人建议是选方案一，因为这样可以把授权逻辑从页面逻辑里独立出来，方便所有页面渲染前调用。具体coding如下：在app.js中，判断是否已经授权，如果未授权则跳转到授权页面App({\r\n  onLaunch: function () {\r\n    ...\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          console.log('已经授权')\r\n        } else {\r\n              // 未授权，跳转到授权页面，必须要用reLauch进行跳转\r\n          wx.reLaunch({\r\n            url: '/pages/auth/index',\r\n          })\r\n          console.log('需要授权')\r\n        }\r\n      }\r\n    })\r\n  },在'pages/auth/index.wxml'页面中，使用button做授权按钮<button open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\">微信账号授权登录</button>'pages/auth/index.js'中定义绑定的回调方法，重新跳转回上一页Page({\r\n  ...\r\n  // 点击授权后跳回首页\r\n  bindGetUserInfo (e) {\r\n    wx.reLaunch({ url: '../index/index' })\r\n    // 用户已经同意小程序使用获取用户信息功能，后续调用 wx.startRecord 接口不会弹窗询问\r\n  }\r\n})\r\n这样，一个授权逻辑就完成了。登录登录的目录其实是和后端交互，需要在服务器端存储当前用户的标识，以便用户下一次登录时服务器知道是谁登录了。做过微信公众号开发的朋友应该都知道，能承担这个作用的角色就是open_id了，所以要实现登录的话，其实就是需要获取当前用户的open_id，官方文档中是这么介绍的：1.小程序调用wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。2.开发者服务器以code换取 用户唯一标识openid 和 会话密钥session_key。之后开发者服务器可以根据用户标识来生成自定义登录态，用于后续业务逻辑中前后端交互时识别用户身份。所以完成登录的前提就是需要后端提供一个接口，咱们把code传给后端就行了，剩下的工作就是后端去完成啦App({\r\n  onLaunch: function () {\r\n    // 授权判断\r\n    wx.getSetting({\r\n      success: res => {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称，不会弹框\r\n          console.log('已经授权')\r\n        } else {\r\n              // 未授权，跳转到授权页面，必须要用reLauch进行跳转\r\n          wx.reLaunch({\r\n            url: '/pages/auth/index',\r\n          })\r\n          console.log('需要授权')\r\n        }\r\n      }\r\n    })\r\n  },\r\n  // 登录\r\n  wx.login({\r\n      success: res => {\r\n        // 发送 res.code 到后台换取 openId, sessionKey, unionId\r\n        if (res.code) {\r\n          api.post('/user/mplogin', { 'code': res.code }).then(res => {\r\n              wx.setStorageSync('access_token', res.access_token)\r\n          }).catch(error=>{\r\n            console.log(error)\r\n          })\r\n        } else {\r\n          console.log('登录失败！' + res.errMsg)\r\n        }\r\n      }\r\n    })这里需要多提的一点是关于会话维持的方案，就是如何让服务器端知道访问接口的是谁。笔者提供两个办法：通过wx.request()在header中强行组装cookie字符串，来实现传统浏览器上用cookie维持会话的效果使用access_token的方式，比如jwt笔者选择的是第二种，通过后端的登录接口返回token，然后将token存入Storage，然后在发起请求的时候将token封装到http请求体中。 两种方案都可行，读者们可根据自己情况自行实现。 由于wx.request()方法发起请求比较麻烦，还需要处理会话逻辑，所以建议读者们还是进行一次封装，下边贴上笔者的代码：在utils文件夹中创建request.js文件const domain = \"https://cdx.tyhub.com\"\r\nfunction GET(url, params) {\r\n  return request('GET', url, params)\r\n}\r\nfunction POST(url, params) {\r\n  return request('POST', url, params)\r\n}\r\nfunction request(method, url, params) {\r\n  return new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: domain + url,\r\n      data: params,\r\n      method: method, // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\r\n      header: {\r\n        'Content-Type': 'application/x-www-form-urlencoded',\r\n        'Authorization': 'bearer' + ' ' + wx.getStorageSync('access_token'),\r\n      },\r\n      success(res) {\r\n        if (res.data.code === 100) {\r\n          let resData = res.data.data\r\n          if (!resData) {\r\n            resData = ''\r\n          }\r\n          resolve(resData)\r\n        } else {\r\n          let err = {\r\n            code: res.data.code,\r\n            msg: res.data.msg\r\n          }\r\n          reject(err)\r\n        }\r\n      }\r\n    })\r\n  })\r\n}\r\n\r\nmodule.exports = {\r\n  get: GET,\r\n  post: POST\r\n}使用const api = require('../../utils/request')\r\n...\r\napi.post('/user/mplogin', { 'code': res.code }).then(res => {\r\n     wx.setStorageSync('access_token', res.access_token)\r\n }).catch(error=>{\r\n   console.log(error)\r\n })至此，登录逻辑便已完成，是不是觉得小程序开发也不过如此呢？由于篇幅有限，今天就分享到这啦，后续我将继续和看官们一起探究以下小程序开发的话题图片上传表单提交级联选择器的实现如何使用iconfont图标微信支付模板消息....欢迎笔者持续关注，也欢迎笔者私信告知我其他疑问，我尽量都一一分享，知无不言，言无不尽。不是结束的结语打波小小的广告，个人开发的找对象小程序“佛系处对象”已经顺利上线，欢迎笔者看官们扫码体验，如果脱单了记得通知我哟！最后祝大家在事业和爱情的“战场中都能脱颖而出，顺利吃鸡！"}
{"title": "微信小程序开发，如何优雅地兼容 ", "author": "Rolan", "pub_time": "2018-9-19 00:02", "content": "关于单个 API 如何兼容，微信官方提供了兼容文档，因此我们这里不再赘述。下面主要讨论在整个项目如何优雅地处理兼容问题。问题如果在每处需要兼容的地方都写上一堆兼容相关的代码，随着代码量增加，会出现以下问题：代码难以阅读兼容方案有变动时，需要改动多处随着时间推移，你的代码才是最需要并且是最难兼容的思考最理想的情况是不需要任何兼容处理，因此可以反推出兼容性处理的代码并不是代码正常流程中的一部分，基于此：兼容的细节不必暴露兼容的方案应该统一兼容的方案可方便地变动解决方案1.将兼容方案隐藏，对外提供接口即可比如 wx.showLoading 是在 1.1.0 版本之后才提供的，对于之前的版本需要兼容。我们选择将其放在 show-loading.js 中，内部进行兼容性相关处理，并对外提供 showLoading 方法。这样调用者只需调用 showLoading 方法即可，不用考虑兼容性的问题，而且如果兼容的方式有变动，只需改动 show-loading.js 一处即可。2.兼容的处理还有共性可以抽象兼容处理多了之后我们会发现，对兼容所做的处理无非两方面：支持该方法时，直接使用对应方法不支持该方法时，做一些兼容处理因此这种模式我们又可以抽离出来，这样做当然有一些好处：减少重复代码做一些共性的处理时，我们又只用改动一处（比如当不兼容官方 API 时加上对应统计，用于分析当前应用跨版本的情况）比如我们抽离出这样一个简单的 compatible.js 用于处理兼容时的共性问题：之前的 showLoading.js 我们可以这样写：简单吧 :)，这种写法的意思是兼容时正常展示 loading 即可，不兼容时则不展示。当然可能有完美主义者会觉得『怎么能不展示呢？我就是要展示！』 那么我们可以这样写：用 wx.showToast 伪造了一个 showLoading。3.文件组织兼容性的文件可能会越来越多，对于我这种有收拾的人，看到所有东西散乱地扔在一个抽屉里肯定是不能忍的...因此我们可以多用几个小盒子把它们分门别类地装起来。小盒子怎么选呢？其实官方已经给出了答案，官方 API 是按照不同的功用分组的，因此我们拿分组当『盒子』即可。最终的文件组织像这样："}
{"title": "微信小程序开发中遇到的问题及解决办法（一） ", "author": "Rolan", "pub_time": "2019-3-18 00:32", "content": "1、整个页面覆盖的自定义弹窗，滑动弹窗中的内容，页面内容也会滑动。如果快速滚动弹窗，页面内容和弹窗中的内容有时会错乱。这个问题大多出现在苹果手机上，类似事件事件穿透的效果。自定义弹窗截图如下：解决办法：再最外层元素上添加事件： catch:touchmove=\"notDo\"事件代码：/**\r\n   * @desc not do\r\n   */\r\n  notDo: function () {\r\n    // not do\r\n  }wxml截图：注意：加上这个事件后，对侧滑效果有所影响，如果需要侧滑切换页面，建议使用其他方法。2、使用了fixed定位的元素，会出现随页面滚动而移动的现象。社区中的说法大概是：这个是因为小程序架构的原因导致 scroll 事件有一定的延迟，最终使 fixed 的改变不够及时导致的。解决办法：在fixed定位的元素上，添加样式： transform: translate3d(0, 0, 0);3、使用canvas绘制分享图，有的时候绘制错误，导致整张分享图空白。折中解决办法：隐藏canvas，使用html结构，重新渲染分享图。这样方便找出到底是哪里绘制错误倒是整张图绘制不出来，也会有更好的交互效果。还有一点好处，如果分享图只有一屏的内容，可以直接截图分享（如果是苹果，不支持截长图）。注意：如果分享图中并没有大量的动态内容，并不建议使用这种折中方案。因为这需要维护两套代码，而且当html结构渲染出来的时候，canvas可能还未绘制完毕或者绘制错误，会误导用户操作。截图：4、开发者工作模拟小程序不同进入场景，比如：扫描二维码，长按识别二维码的启动参数处理。解决办法：应该通过encodeURIComponent来编码启动参数，在当前页面获取页面参数的时候，再通过decodeURIComponent来解码。截图：代码截图：注意：区别于encodeURI和decodeURI的编解码，encodeURIComponent和decodeURIComponent的组合使用范围更广。encodeURI对在 URI 中具有特殊含义的 ASCII 标点符号，不会进行转义的：;/?:@&=+$,#, 而encodeURIComponent会转义这些。遇上encodeURI不会转义的标点符号，URI会直接被截取掉。随记 ：最近，太阳不再流浪；最近，想遇见更好的自己~"}
{"title": "如何使用微信小程序云函数发送短信验证码 ", "author": "Rolan", "pub_time": "2019-3-13 00:11", "content": "其实微信小程序前端和云端都是可以调用短信平台接口发送短信的，使用云端云函数的好处是无需配置域名，也没有个数限制。本文使用的是榛子云短信平台( http://smsow.zhenzikj.com) ，SDK下载:  http://smsow.zhenzikj.com/doc...安装下载后的SDK在cloudfunctions文件夹下会包含3个云函数文件夹，如下:由于目前IDE没有云函数导入功能，您需要手工创建同名的云函数，然后将云函数下的文件手工拷进去注：下载的SDK是一个完整的工程，包含SDK和使用示例，可实际运行演示2.申请账号,获取AppId、AppSecret免费注册地址: http://sms_developer.zhenzikj...使用注册账号登录用户中心，在\"我的应用\"-> \"详情\"中可以查询AppId、AppSecretAppId、AppSecret是用于开发者使用账号和秘钥, 以下的所有api中都需要用到3.发送短信wx.cloud.callFunction({\r\n      // 云函数名称\r\n      name: 'zhenzisms_send',\r\n      // 传给云函数的参数\r\n      data: {\r\n         apiUrl: '你的apiUrl',\r\n        appId: '你的appId',\r\n        appSecret: '你的appSecret',\r\n        message: '你的验证码为:1234',\r\n        number: '15811111111',\r\n        messageId: ''\r\n      },\r\n      success(res) {\r\n        console.log(res.result.body)\r\n      },\r\n      fail: console.error\r\n    })\r\n  }apiUrl为请求地址，个人开发者使用 https://sms_developer.zhenzik... ，企业开发者使用 https://sms.zhenzikj.comsend方法用于单条发送短信参数message:发送的短信内容参数number:接收者手机号码参数messageId:该条信息的唯一标识，可用于查询返回结果是json格式的字符串, code: 发送状态，0为成功。非0为发送失败，可从data中查看错误信息4.查看余额通过该接口可查看当前剩余的短信条数wx.cloud.callFunction({\r\n      // 云函数名称\r\n      name: 'zhenzisms_balance',\r\n      // 传给云函数的参数\r\n      data: {\r\n        apiUrl: '你的apiUrl',\r\n        appId: '你的appId',\r\n        appSecret: '你的appSecret'\r\n      },\r\n      success(res) {\r\n        console.log(res.result.body)\r\n      },\r\n      fail: console.error\r\n    })\r\n  }返回结果是json格式的字符串, code: 查询状态，0为成功，data为剩余短信条数。非0为查询失败，可从data中查看错误信息错误代码表错误码 原因 解决方案100 参数格式错误 检查请求参数是否为空105 appId错误或应用不存在 请联系工作人员申请应用或检查appId是否输入错误106 应用被禁止 请联系工作人员查看原因107 ip错误 如果设置了ip白名单，系统会检查请求服务器的ip地址，已确定是否为安全的来源访问110 应用秘钥(AppSecret)错误 检查AppSecret是否输入错误，或是否已在用户中心进行了秘钥重置1000 系统位置错误 请联系工作人员或技术人员检查原因5.查询短信接口描述根据messageId查询已发送短信wx.cloud.callFunction({\r\n      // 云函数名称\r\n      name: 'zhenzisms_findSmsByMessageId',\r\n      // 传给云函数的参数\r\n      data: {\r\n        appId: '你的appId',\r\n        appSecret: '你的appSecret',\r\n        messageId: 'messageId信息'\r\n      },\r\n      success(res) {\r\n        console.log(res.result.body)\r\n      },\r\n      fail: console.error\r\n    })请求参数参数名称 必选 类型 描述messageId 是 string 信息id，对应发送短信接口的messageId字段返回结果返回结果是json格式的字符串, code: 查询状态，0为成功。非0为失败，可从data中查看错误信息{\r\n            \"code\":0,\r\n            \"data\":{}\r\n        }返回结果是json格式的字符串, code: 查询状态，0为成功，data短信信息的json字符串"}
{"title": "个税计算器 / 微信小程序开发 ", "author": "Rolan", "pub_time": "2019-1-2 00:36", "content": "019年1月1日即将到来，码农们除了关心自己的技能之外，还有薪资是不是可以多拿点。 每次算的时候 都要百度一下个人所得税，但是很多都是老的税率计算，找一个新的出来还是比较麻烦，所以个人开发了一个最新税率的小程序。解决和我有着一样痛苦的码农们的问题。根据最新税改后计算个人所得税的计算器。目前支持南京，后续开放 杭州 上海 北京等城市。 如果有疑问的可以加最下方 开发者微信。首先在微信官网下载微信小程序开发工具 https://mp.weixin.qq.com在https://mp.weixin.qq.com 注册小程序账号，完成个人实名认证。在小程序后台拿到appid，下面就可以开发了。实例查看二维码：先使用weui 小程序ui框架就行页面布局<button block type=\"dark\" bindtap='calculationBindtap'>计算</button>其次写JS代码（计算按钮逻辑代码）import data from './data'\r\n\r\nconst app = getApp;\r\n\r\nPage({\r\n    data: {\r\n        options1: data,\r\n        value: '1',\r\n        checked: true,\r\n        standard: 1,\r\n        marking: 5000,\r\n        beforetaxCount: 0,\r\n        specialitemCount: 0\r\n    },\r\n    \r\n\r\n    calculationBindtap:function(){\r\n        // 开始计算  计算完成把计算结果放在result对象中\r\n        var beforetaxCount = this.data.beforetaxCount;\r\n        var specialitemCount = this.data.specialitemCount;\r\n        var marking = this.data.marking;\r\n        if (beforetaxCount == null || beforetaxCount == 0 || beforetaxCount == ''){\r\n            wx.showToast({\r\n                title: '输入正确薪资',\r\n                mask: true,\r\n                icon: 'loading'\r\n            })\r\n            return;\r\n        }\r\n        if (specialitemCount == null || specialitemCount == ''){\r\n            specialitemCount = 0;\r\n        }\r\n        // 开始计算\r\n\r\n        var oldNum = 0.08;\r\n        var medNum = 0.02;\r\n        var unemNum = 0.005;\r\n        var workNum = 0;\r\n        var giveNum = 0;\r\n\r\n        var providentfundNum = 0.08;\r\n\r\n        var insuranceBase = 19935;\r\n        var providentfundBase = 25300;\r\n\r\n        var oldcount = 0;\r\n        var medcount = 0;\r\n        var unemcount = 0;\r\n        var workcount = 0;\r\n        var givecount = 0;\r\n\r\n        var providentfundcount = 0;\r\n\r\n        var privateFee = 0;\r\n        var plusFee = 0;\r\n\r\n        if(this.data.checked){\r\n            if (parseFloat(beforetaxCount) > parseFloat(insuranceBase)) {\r\n                oldcount = parseFloat(insuranceBase) * parseFloat(oldNum);\r\n                medcount = parseFloat(insuranceBase) * parseFloat(medNum);\r\n                unemcount = parseFloat(insuranceBase) * parseFloat(unemNum);\r\n                workcount = parseFloat(insuranceBase) * parseFloat(workNum);\r\n                givecount = parseFloat(insuranceBase) * parseFloat(giveNum);\r\n            } else {\r\n                oldcount = parseFloat(beforetaxCount) * parseFloat(oldNum);\r\n                medcount = parseFloat(beforetaxCount) * parseFloat(medNum);\r\n                unemcount = parseFloat(beforetaxCount) * parseFloat(unemNum);\r\n                workcount = parseFloat(beforetaxCount) * parseFloat(workNum);\r\n                givecount = parseFloat(beforetaxCount) * parseFloat(giveNum);\r\n            }\r\n\r\n            if (parseFloat(beforetaxCount) > parseFloat(providentfundBase)) {\r\n                providentfundcount = parseFloat(providentfundBase) * parseFloat(providentfundNum);\r\n            } else {\r\n                providentfundcount = parseFloat(beforetaxCount) * parseFloat(providentfundNum);\r\n            }\r\n        }\r\n\r\n        // 保险总费用\r\n        var totalInsuranceFee = parseFloat(oldcount) + parseFloat(medcount) + parseFloat(unemcount) + parseFloat(workcount) + parseFloat(givecount);\r\n        // 公积金费用 \r\n        var totalProvidentfundFee = providentfundcount;\r\n\r\n        // 下面的钱 交税\r\n        console.log(this.data.marking);\r\n        var otherFee = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(this.data.marking) - parseFloat(specialitemCount);\r\n        \r\n        if (parseFloat(otherFee) <= 3000 && parseFloat(otherFee) > 0) {\r\n            privateFee = parseFloat(otherFee) * 0.03;\r\n            plusFee = 0;\r\n        }\r\n        if (parseFloat(otherFee) <= 12000 && parseFloat(otherFee) > 3000) {\r\n            privateFee = parseFloat(otherFee) * 0.1;\r\n            plusFee = 210;\r\n        }\r\n        if (parseFloat(otherFee) <= 25000 && parseFloat(otherFee) > 12000) {\r\n            privateFee = parseFloat(otherFee) * 0.2;\r\n            plusFee = 1410;\r\n        }\r\n        if (parseFloat(otherFee) <= 35000 && parseFloat(otherFee) > 25000) {\r\n            privateFee = parseFloat(otherFee) * 0.25;\r\n            plusFee = 2660;\r\n        }\r\n        if (parseFloat(otherFee) <= 55000 && parseFloat(otherFee) > 35000) {\r\n            privateFee = parseFloat(otherFee) * 0.3;\r\n            plusFee = 4410;\r\n        }\r\n        if (parseFloat(otherFee) <= 80000 && parseFloat(otherFee) > 55000) {\r\n            privateFee = parseFloat(otherFee) * 0.35;\r\n            plusFee = 7160;\r\n        }\r\n        if ( parseFloat(otherFee) > 80000) {\r\n            privateFee = parseFloat(otherFee) * 0.45;\r\n            plusFee = 15160;\r\n        }\r\n\r\n        var result = {};\r\n        \r\n        result.insuranceCount = totalInsuranceFee;\r\n        result.providentfundCount = totalProvidentfundFee;\r\n        result.providentfundNum = parseFloat(providentfundNum) * 100;\r\n        result.money = parseFloat(beforetaxCount) - parseFloat(totalInsuranceFee) - parseFloat(totalProvidentfundFee) - parseFloat(privateFee) + parseFloat(plusFee);\r\n        result.privateFee = privateFee - parseFloat(plusFee);\r\n        result.specialitemCount = specialitemCount;\r\n        result.oldNum = parseFloat(oldNum) * 100;\r\n        result.medNum = parseFloat(medNum) * 100;\r\n        result.unemNum = parseFloat(unemNum) * 100;\r\n        result.workNum = parseFloat(workNum) * 100;\r\n        result.giveNum = parseFloat(giveNum) * 100;\r\n\r\n        result.oldcount = parseFloat(oldcount);\r\n        result.medcount = parseFloat(medcount);\r\n        result.unemcount = parseFloat(unemcount);\r\n        result.workcount = parseFloat(workcount);\r\n        result.givecount = parseFloat(givecount);\r\n\r\n        wx.setStorage({\r\n            key: 'result',\r\n            data: result,\r\n            success:function(){\r\n                wx.navigateTo({\r\n                    url: '../calculation/calculationResult',\r\n                })\r\n            }\r\n        })\r\n        \r\n    },\r\n\r\n})把计算好的结果放在result对象中 通过wx.setStorage 放在缓存中，传到下一个页面。最后展示出来。"}
{"title": "微信小程序开发之多图片上传+服务端接收 ", "author": "Rolan", "pub_time": "2019-3-19 10:16", "content": "目录导航：前言： 使用技术： wx.chooseImage() 概述： wx.uploadFile()概述： 废话不多说，上代码： .Wxml code： .Js code: 后端图片接收保存 code（.Net WEBAPI） 效果图展示（美女哟，嘻嘻）： 总结：前言：　　业务需求，这次需要做一个小程序同时选中三张图片一起上传到服务端，后端使用的.NET WEBAPI接收数据保存。使用技术：　　在这章中将会使用到微信小程序wx.uploadFile(Object object) 和wx.chooseImage(Object object)接口，对图片大小和来源进行上传wx.chooseImage() 概述： 　　从本地相册选择图片或使用相机拍照，详细了解请阅读微信小程序开发文档（https://developers.weixin.qq.com/miniprogram/dev/api/wx.chooseImage.html?search-key=wx.chooseimage）参数 Object objectwx.uploadFile()概述：　　将本地资源上传到服务器。客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data，详细了解请阅读微信小程序开发文档（https://developers.weixin.qq.com/miniprogram/dev/api/wx.uploadFile.html?q=wx.uploadFile）。参数废话不多说，上代码：.Wxml code： class='form-s2'>门店照片(请选择三张) class=\"weui-uploader__files\" id=\"uploaderFiles\"> wx:for=\"{{files}}\" wx:key=\"*this\"> class=\"weui-uploader__file\" bindtap=\"previewImage\" id=\"{{item}}\" style='margin-top:11px;'> class=\"weui-uploader__img\" src=\"{{item}}\" mode=\"aspectFill\" /> class=\"weui-uploader__input-box\" style='top:11px;'> class=\"weui-uploader__input\" bindtap=\"chooseImage\">.Js code:Page({  /**   * 页面的初始数据   */data:{  files: [], //门店图片信息,数组图片保存作为数据源}，,  /**   * 多图片上传   */chooseImage: function(e) {var that = this;if (that.data.files.length > 2) { resource.notishi(\"抱歉最多只允许上传三张图片哟~\"); return false;}wx.chooseImage({count: 3, //默认9张，这里设置三张sizeType: ['original', 'compressed'], // 可以指定是原图还是压缩图，默认二者都有sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有success: function(res) {wx.showLoading({title: '上传中,请稍等...',})// 返回选定照片的本地文件路径列表，tempFilePath可以作为img标签的src属性显示图片var tempFilePaths = res.tempFilePaths; //多图片上传，tempFilePaths本地图片地址为一个数组，遍历调用服务器图片上传接口即可实现多图保存for (var i = 0; i < tempFilePaths.length; i++) {console.log('图片地址名称' + tempFilePaths[i]);wx.uploadFile({ url: app.globalData.hostUrl + \"/api/PictureUpload/Upload\", //此处为实际接口地址filePath: tempFilePaths[i], //获取图片路径header: {'content-type': 'multipart/form-data'}, name: 'upload',success: function(res) {wx.hideLoading();let Result = JSON.parse(res.data);console.log(Result);//接收返回来的服务器图片地址if (Result.code == 1) {let picurl = app.globalData.hostUrl + Result.picurl;console.log(picurl); that.setData({files: that.data.files.concat(picurl)});} else { resource.notishi(\"网络异常，请稍后再试\");}},fail: function(res) {wx.hideLoading()wx.showToast({title: '上传失败，请重新上传',icon: 'none',duration: 2000})},})}}})}, //图片预览previewImage: function(e) {wx.previewImage({current: e.currentTarget.id, // 当前显示图片的http链接urls: this.data.files // 需要预览的图片http链接列表})},})后端图片接收保存 code（.Net WEBAPI）/// /// 图片上传保存/// /// [HttpPost]public IHttpActionResult Upload(){ try{var content = Request.Content;//获取http设置的消息和内容var tempUploadFiles = \"/Images/Wechatimages/\";//保存路径var newFileName = \"\";string filePath = \"\";string extname = \"\";string returnurl = \"\";var sp = new MultipartMemoryStreamProvider();Task.Run(async () => await Request.Content.ReadAsMultipartAsync(sp)).Wait();foreach (var item in sp.Contents){if (item.Headers.ContentDisposition.FileName != null){var filename = item.Headers.ContentDisposition.FileName.Replace(\"\\\"\", \"\");FileInfo file = new FileInfo(filename);string fileTypes = \"gif,jpg,jpeg,png,bmp\";if (Array.IndexOf(fileTypes.Split(','), file.Extension.Substring(1).ToLower()) == -1){throw new ApplicationException(\"不支持上传文件类型\");}//获取后缀extname = System.IO.Path.GetExtension(filename);//获取文件的拓展名称newFileName = Guid.NewGuid().ToString().Substring(0, 6) + extname;string newFilePath = DateTime.Now.ToString(\"yyyy-MM-dd\") + \"/\";if (!Directory.Exists(HostingEnvironment.MapPath(\"/\") + tempUploadFiles + newFilePath)){Directory.CreateDirectory(HostingEnvironment.MapPath(\"/\") + tempUploadFiles + newFilePath);}filePath = Path.Combine(HostingEnvironment.MapPath(\"/\") + tempUploadFiles + newFilePath, newFileName); returnurl = Path.Combine(tempUploadFiles + newFilePath, newFileName);//图片相对路径var ms = item.ReadAsStreamAsync().Result;using (var br = new BinaryReader(ms)){var data = br.ReadBytes((int)ms.Length);File.WriteAllBytes(filePath, data);//保存图片}}}return Json(new {code=1,picurl= returnurl,msg=\"success\" }) ;}catch (Exception ex){return Json(new { code =0,msg=ex.Message});}}总结：　　其实做完回过头来想想，无论是微信小程序图片上传还是html页面图片上传原理其实都是差不多，都是通过content-type 为 multipart/form-data 标识，通过http post将图片资源文件以二进制的编码格式传往后台，然后后台获取对应文件流进行数据图片保存。总结的不够到位，有什么没做好的望各位大佬指点。"}
{"title": "从产品角度，看小程序的设计 ", "author": "Rolan", "pub_time": "2019-4-9 10:15", "content": "带你了解“后APP”时代近一年利用业余时间，帮朋友设计了一款小程序，大大小小的迭代也有10多个了，今天就来聊聊关于小程序的设计思考。引用微信之父张小龙的观点：“小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或搜一下即可打开应用。也体现了“ 服务用户、不打扰用户、用完即走 ”的产品理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。”一.小程序和APP在设计上的本质区别是什么？大家在使用小程序和APP的时候，可能觉得并没有什么不一样，反正都是手机端，实际上有很多本质上的区别，主要有以下11个方面：1.获取渠道APP：必须通过应用商店（如 App Store）里下载小程序：通过微信（扫描二维码、搜索...）直接获得2.下载安装APP：安装在手机内存中，就像自己买了辆车放在车库里随时开小程序：不需要安装，就像免费用嘀嘀打车，召之即来 用完拜拜3.占用空间APP：一直存在手机中会占用空间，太多的APP可能会导致内存不足，总是清理缓存小程序： 因为不需要安装，占用内存空间忽略不计4.广告推送APP：会隔三差五给用户推送广告，太多未读提示会逼死强迫症小程序：不允许主动给用户发送广告，仅能回复模版消息5.市场机会APP：市场已接近饱和，几乎所有的领域都已经被覆盖小程序：是一片蓝海，在新的使用场景下有很多瓜分蛋糕的好机会，尤其是线上+线下的模式6.适配APP：需要适配市场上很多款的主流手机，开发成本大小程序：一次开发就可以自动适配所有手机7.开发周期APP：一款完善的双平台APP平均的开发周期约3个月小程序：平均开发周期约2周，仅为APP的六分之一8.发布APP：需要向十几个应用商店提交审核，且每个应用商店要求的资料都不一样，非常繁琐小程序：只需要提交到微信公众平台审核，审核周期短9.用户群APP：面向所有智能手机用户，截止2018年，约13亿人次小程序：面向所有微信用户，截止2019年，月活10.82亿10.功能APP：可以实现完整功能小程序：仅限微信提供的接口功能11.推广难度APP：需要用户主动下载十几M的程序包，在没有Wi-Fi的情况下推广艰难小程序：可以通过二维码、微信搜索等方式直接获得，推广难度大大降低二.小程序的价值体现轻量让用户便捷、迅速、简单、高效的获取服务，无需下载/安装/卸载、无需注册、用完既走：一是用户使用没有心里负担，二是省了APP下载的漏斗转化过程，要知道一个产品从广告展示→到下载安装→到注册激活的漏斗路径，很多时候是惨不忍赌的。同时小程序具有出色的使用体验， 页面加载速度比H5页面会更快，获取用户成本相对较低；社交必须和微信生态融入，那就必须考虑到微信的生态基因，这是最核心的价值，比如：你在小程序里玩游戏 ，你会想让朋友家人知道你有多厉害，所以 小程序比APP更容易让周围的人参与进来，这个流程可以触发更多的可能；主动小程序本身不是为了哗众取众，必须对用户有切实的价值，能够让用户 在有需要时主动进入，主动唤醒 。所以很多小程序在设计的时候，都通过一些界面内的引导手段，抢占“我的小程序”的黄金位置，就是为了培养用户的主动；引流对于第三方来说，微信必须是重要的流量入口（月活用户10亿左右），在微信允许的范围内，用可能的手段获取用户流量，是我们需要着重考虑的；数据即便没有引流成功，至少可以获取用户数据，支持自有产品开展业务。比如小程序登录时需要微信授权，有的还需要手机验证码等等；生态结合微信自身的生态系统，小程序可以和公众号、订阅号相互依托，引入种子用户，并且在微信好友和朋友圈的传播中，不会有割裂感。三.小程序有哪些玩法1. 小程序+公众号随着公众号体系和小程序体系互通，更多场景可以直接触达小程序。如“豆芽作文公众号”关联了“豆芽作文小程序”，并在公众号内部的主入口强推，为其引流。2. 小程序+小程序小程序轻量化的产品形态体现在灵活、快捷的使用中，因此当有功能桥接时，可选择关联其他小程序。例如“豆芽作文”的“爱学习”模块就关联了其他3个功能入口，为同类产品提供不同服务的小程序给予跳转支持。微信小程序团队有这样的设计理念： 每个小程序最好只专注一个服务场景。因为这样才能“用完即走”。才能让用户 在小程序的体验过程中，不会觉得层级过深、流程过长，避免出现小程序和微信聊天交替使用 ，因为小程序的复杂而带来糟糕体验。但是很多公司又有多个业务场景，如果按做APP的思路做小程序，自然是会做出一个多层级/多功能的小程序。于是，微信小程序团队期望的结果是： 多个业务场景多个小程序来实现，允许小程序间跳转 ，来实现“公司层多业务，产品层多小程序”的愿景。3. 小程序+二维码 (线上+线下)线上线下的结合更常见，比如进入餐厅点餐时，扫描二维码进入小程序，直接点餐，不用排队，也不用下载APP或关注公众号，对用户来说极为便利。同时可以利用登录授权，获取用户的信息四.小程序基础知识汇总1.场景入口微信官方为小程序提供了69个场景入口，便于小程序在更多的场景下被用户触达，作为产品经理也要充分利用各种场景，增加小程序被触达的机会，同时可以结合这些场景，增加小程序运营的曝光率。依托于微信场景的 小程序增长六大入口：聊天窗口分享、APP分享、“搜一搜”、“扫一扫”、首页下拉窗口、公众号 。2.有哪些开放接口？除了扩大小程序的线上入口，小程序还提供了很多开放接口，帮助开发者更快速地实现一些功能。3.模板消息小程序的模版消息相当于APP中的消息推送。微信公众平台为小程序的“消息推送”设了很多规则：（1） 需要用户行为来触发 ，不管用户在何种场景下触发，单次触发最多可带来一条消息，且最多可以连续七天发送；（2）所有的消息都要在微信公众平台提供的消息模版中选择，不能自定义模板。当然这也很 符合微信一贯的特性，不能“流氓式”的打扰用户。4.小程序数据助手数据分析对于产品的运营至关重要，小程序主不仅可以在微信公众平台的后台看到小程序的数据，也可以在微信搜索“小程序助手”，在手机端随时查看小程序的数据变化。5.小程序不可随意跳出小程序依附于微信生态，不可以像传统APP一样实现随意跳转。如果希望小程序跳转小程序，那么可以在代码配置中进行声明，跳转的小程序数量是有限的，目前是10个。还有一种解决小程序外跳和在小程序扫码的操作是通过客服消息，小程序主可以通过给小程序添加客服消息，让用户回复指定内容，可以给用户发送文章链接，实现跳转和扫码。6.小程序有特定的开发框架各大平台都有自己的小程序开发框架，技术可以学习这种新的框架，一般上手也较快；当然也有别的解决方案，技术可以使用一些转码框架，例如京东的taro和去哪儿的nanachi。7.适配问题小程序毕竟是一个新技术，因此适配也有一定的局限性。官方有提供标准的顶部导航和底部导航的方案，使用起来一般没什么问题，但如果希望根据自己的产品特性对顶部导航和底部导航进行一些个性化调整，就要小心适配问题了。有些产品的做法就比较取巧，这里举个“知乎热榜”的例子：本身小程序顶部栏是 不可以做个性化设计 的，但“知乎热榜”为了给内容区更多曝光的空间（毕竟移动端寸土寸金嘛），将顶部栏的icon按钮做成了搜索框的样式，点击进入到搜索页面，这样做既避开了小程序的局限性，也不影响正常的搜索流程（本身搜索也需要跳到新页面），同时也符合用户的使用认知。五.设计规则微信小程序的设计指南提供了很多页面的设计规则，可以帮助产品经理和交互设计师更好的设计页面。在设计小程序时建议认真看一看， 文档中的内容不仅仅适用于设计小程序，对于APP的页面设计也可复用。除了对产品的设计要求，为了让小程序和微信的视觉统一，小程序制定了UI设计规范，在设计UI时需要严格遵守规则，否则无法上线。虽然小程序为了让服务完善，正在逐步开放更多功能，但是现在小程序代码包要限制在2M以内，所以在设计小程序时，功能一定要尽量简单。文章最后会把“小程序设计指南”和“UI设计基础控件库”的地址和源文件分享给大家，供大家下载，见附件。六.小程序如何影响我们的生活1.对普通用户（1）首先是卸载低频APP对于像旅游、租房等低频使用的APP（所以这类APP为什么要做社区和社交），普通用户可能更倾向于卸掉本地APP而选择小程序来使用，这能够节省一部分手机空间，同时也不用考虑更新迭代。最重要的是 可以获得更“短、平、快”的服务路径 ，减少不必要的时间消耗，扩大自己的有效时间。小程序希望为普通用户提供这样的服务路径： 用户到达服务目的的环节越少越好，缩短用户使用路径，通过这样的方式让越来越多用户更好地留在小程序或是微信构造的生态链里。（2）微信变成巨无霸应用，用户停留时间更长：通讯（IM）+社交+工具和服务用户把省下来的一部分空间，留给微信使用。原本已经很长的使用时间因为所提供的工具和服务的多元化而变得更长。小程序涵盖的服务类别非常多，可见微信在起初设计的时候就想建立更大的生态圈。2.对行业应用和服务提供者（1）体验不佳的服务号会快速转移阵地（2）给本地生活和电商的应用带来便利先是给本地生活和电商的应用带来很大的便利，尤其是有战略合作关系的应用服务商，这些APP的核心功能会得到进一步的强化（建立壁垒），对用户的触及面会很广，使用频率会提高，他们肯定会成为享有小程序的第一批红利者。（3）商家入驻随着商家开发小程序，微信会逐步变成商家入驻平台，这会给本地生活/电商等应用带来巨大的冲击，到那个时候我们更习惯于在微信里完成闭环的任务，基本上不会再想起来用别的APP。不过， 这一点还是需要时间来验证的，毕竟APP是互联网生态圈中最重要的一环。可以说，微信小程序的出现，会推动进入“后APP时代”的节奏。七.小程序的未来个人拙见：首先，小程序的未来是代表微信线下入口，最担心的不是小程序，而是微信越来越强大。微信已经霸占了整个线上市场，但线下市场，微信一直没有太多的涉及。阿里为了搞社交，出了阿里旺旺、来往、支付宝等等，支付宝也上线很多社交功能及游戏，可成效并不理想。整个社交空间被微信、QQ占据绝大部分。我们很多人应该不希望微信做成一家独大， 正如淘宝的一家独大导致整个实体市场的萎靡，以及1号店、国美等发展艰难。如果微信想要与支付宝竞争，竞争的重点不会放在支付这块，更多的是“服务”和场景的搭建。至于支付宝也要上线小程序，实属正常防卫策略。阿里的天猫上线比较晚，是来自于对京东的防御。其次， 小程序的重点是提供更便捷和更优质的服务，而不是内容 。小程序应该不会像公众号那样引爆一波自媒体，应该是引爆一波优秀的服务提供商。"}
{"title": "微信小程序拉起登录的操作 ", "author": "Rolan", "pub_time": "2019-3-26 00:37", "content": "第一步，前端调用wx.login()接口把token数据请求过来，第二部，把tok嗯发送到总计的服务器，然后进行微信openid和assession的获取第三部验证session是否过期，过期重新拉起授权登录，未过期直接进行下一步第四部：getUserInfo，获取用户的个人信息，// pages/authorize/authorize.js\r\nPage({\r\n  data:{\r\n    img:'',\r\n    pri:'',\r\n    city:'',\r\n    nickname:''\r\n  },\r\n  login(){\r\n    wx.login({\r\n      success:res=>{\r\n        // 可以获取code\r\n        console.log(res)\r\n        wx.request({\r\n          url: 'http://flyxin.com.cn/login.php', // 仅为示例，并非真实的接口地址\r\n          data: {\r\n            code:res.code\r\n          },\r\n          header: {\r\n            'content-type': 'application/json' // 默认值\r\n          },\r\n          success(res) {\r\n            console.log(res)\r\n          }\r\n        })\r\n      }\r\n    })\r\n  },\r\n  checksession(){\r\n    wx.checkSession({\r\n      success:function(red){\r\n        console.log(red,'未过期');\r\n        wx.showToast({\r\n          title: '登录未过期',\r\n        })\r\n      },\r\n      fail:function(res){\r\n        console.log(res)\r\n        wx.showModal({\r\n          title: '提示',\r\n          content: '登录已过期',\r\n        })\r\n        // 再次调用login\r\n\r\n      }\r\n    })\r\n  },\r\n  // 获取用户信息\r\n  info(){\r\n    wx.getUserInfo({\r\n      success:(res)=>{\r\n        console.log(res.userInfo)\r\n        var json=res.userInfo;\r\n        this.setData({\r\n          nickname:json.nickName,\r\n          pri: json.province,\r\n          city:json.city,\r\n          img:json.avatarUrl\r\n        })\r\n      }\r\n    })\r\n  }\r\n}) 希望自己写的东西能够对大家有所帮助！谢谢"}
{"title": "全国首例微信小程序侵权案已判决，腾讯要承担责任吗？ ", "author": "Rolan", "pub_time": "2019-4-8 00:11", "content": "摘要： 微信小程序开发者服务器数据不保存在腾讯公司处，而是在每一位开发者自己的服务器上，因此腾讯公司对小程序开发者提供的，仅仅是架构与接入的基础性网络服务。图片来源@视觉中国钛媒体注：本文来自微信公众号刺猬公社 （ID: ciweigongshe），作者：陈彬，钛媒体经授权发布。2月27日，国内第一起小程序侵权案件，在浙江杭州互联网法院拉下了帷幕。被告方是百赞公司，它未经版权方许可，在其所经营的微信小程序“在线听阅”、“咯咯呜”、“回播”上提供了《武志红的心理学课》的在线播放服务。受版权方委托，原告刀豆公司将百赞公司与腾讯公司告上了法庭。刀豆公司在诉讼请求判令中认为，腾讯公司应当有审核的义务，却放任了百赞公司的侵权行为，属于帮助侵权行为。刀豆公司要求百赞公司立刻停止侵权行为，腾讯公司删除侵权的3个微信小程序，两者共同赔偿刀豆公司5万元的经济损失，承担全部诉讼费用。在诉讼期间，百赞公司主动删除了侵权的作品内容。经过6个月的审理，杭州互联网法院最终下达判决，百赞公司需赔偿刀豆公司15000元的经济损失，原告其余的申诉被全部驳回，腾讯公司无需承担责任。法院的判决依据在于，微信小程序开发者服务器数据不保存在腾讯公司处，而是在每一位开发者自己的服务器上，因此腾讯公司对小程序开发者提供的，仅仅是架构与接入的基础性网络服务。2006年国家颁布的《信息网络传播权保护条例》中第14条规定，“通知—删除”的规则适用于“提供信息存储空间或者提供搜索、链接服务的网络服务提供者”。没有开发者服务器数据的腾讯也就不适用上述的规则，没有刀豆公司所说“通知—删除”的义务。为此，刀豆公司表示，如果腾讯公司不适用“通知—删除”规则的话，那么小程序的侵权行为又该如何快速解决呢？也有网友提出质疑，腾讯既然对小程序进行广告抽成，那么是否就应该有监管的责任呢？目前，刀豆公司已针对“腾讯无责”的判决提交上诉状，法院正式受理。同样情况，苹果被罚2012年，国内曾发生过一起类似的侵权案件。一处细节的不同，让当时的被告苹果公司和如今的腾讯公司遇上了完全相反的结果。当时，某个第三方开发商未经原告李承鹏的允许，便把其创作的作品《李可乐抗拆记》发布到AppStore，提供有偿下载服务。原告李承鹏一纸诉状将苹果公司告上了法庭，要求其刊登30日的道歉声明，并且赔偿30.5万元的经济损失。和腾讯公司一样，苹果公司认为自己作为网络服务的提供者，并不存在任何的侵权行为。最终，苹果公司却遭遇了败诉，被判定需要赔偿原告李承鹏大量的经济损失。其原因就在于，法院认为，“苹果公司作为综合性的网络服务平台应用程序商店AppStore的运营者，对应用程序商店AppStore网络服务平台具有很强的控制力和管理能力。所有开放商的应用程序，在AppStore内上线前，都必须由苹果公司进行筛选，同意是否分销。”在这之后，苹果公司选择了上诉，经过法院审理之后，依旧被驳回了请求，以失败告终。正是因为有着许多类似于上述案件的判决，杭州互联网法院在审理之初，便认为腾讯公司和苹果公司一样，是一般的网络服务提供者，依法适用简易程序进行处理。在审理中，腾讯公司的代理律师张延来，选择花费大量的时间与精力，来介绍微信小程序平台的技术原理，将本次案件与前者做出区分。“小程序表现为开发者独立开发运营的类似网站的组合页面，开发者利用小程序提供的页面架构程序和通用模块，编辑出自己想要的小程序移动页面，这一技术特征跟PC端的网页编程技术高度一致，不可能要求网页技术服务提供者去审查页面上的侵权内容。”这场官司结束后，张延来接受人民网采访时说，小程序开发者的服务器数据并不在腾讯手中，腾讯公司也无法做到一一审核检查。面对国内第一例小程序侵权案，张延来认为法院现在的判决非常有意义，“（可以让）这类服务提供者日后在侵权处理方面更加有章可循”。不然，一旦像微信小程序这类基础性技术服务提供者也要承担“帮助侵权”和连带责任的巨大压力，难免会出现为了规避风险而肆意“封杀”第三方用户的行为，对整个互联网业态都会产生非常消极的影响。“一旦法院认定小程序平台应当按照‘通知—删除’规则处理权利投诉，会导致只能删除整个小程序而不是其中的具体侵权链接的结果，这会导致广大小程序开发者将随时面临‘灭顶之灾’。”张延来在人民网的采访时补充说。不过张延来律师也说道，基础性技术服务提供者并非不承担任何法定义务，对于明显违法信息的处理等仍然是其应尽的注意义务，从业者应当遵守。问题是出在侵权方身上，还是平台？伴随着这几年微信小程序的快速发展，各种小程序侵权现象也接踵而至。互联网时代，各种侵权行为就像是除不尽的杂草，流量走到哪儿，它就跟到哪儿。腾讯公司曾对外公布，2018年全年关于微信小程序侵权的投诉就有近4000件。这些投诉主要集中在两种类型的侵权上，一方面是小程序的昵称、头像和功能简介；另一方面则是小程序的内容，前面提到的侵权案就属于这一类。这些侵权的小程序一旦被分享到社群当中，会迅速引起传播裂变，对版权方造成巨大的损失。而曾经一起小程序侵权事件挑动了大部分内容创业者的神经。2017年12月，作为人物传记类公众号运营者的赵恩彪，参考改良了自己公众号内将名人的足迹标在地图上的玩法，创作出了“脚步地图”这一微信小程序，并进行了计算机软件著作权的登记。“脚步地图”发布之初，没有产生太大的影响。等到6个月之后，“脚步地图”却突然日活量暴增到7000多人，一天之后用户更是涨到了30万人，直接导致了服务器的崩溃，“脚步地图”不得不维护数日。而在“脚步地图”维护的第一天，同样是公众号运营者戴宏民开发的微信小程序“西瓜足迹”上线，短短3天竟收获了过千万的访问量。不过这款“西瓜足迹”，却和赵恩彪的“脚步地图”在玩法和美术素材上几乎完全一致。左为“西瓜足迹”，右为“脚步地图”“辛辛苦苦创了两年业，马上就要看到希望了，没想到就这样泡汤了。”赵恩彪一气之下，将戴宏民的“西瓜足迹”告上了法庭。一周之后，腾讯公司下线了“西瓜足迹”这一小程序，此时赵恩彪已经损失了千万的流量。专注版权服务的维权骑士与鲸版权的创始人陈敛在接受刺猬公社访谈时认为，面对侵权现象，微信小程序平台方需要采取有效机制来遏制侵权行为，减少版权方的损失。“不要一切托以司法诉讼的名义去人为去抬高维权门槛，更何况司法诉讼本身也会占用司法资源，平台把大量的权属明确，侵权事实明显，证据确凿侵权case推给司法机关，我认为也是企业把自身本应承担的合规成本转嫁给社会的体现。”在陈敛看来，微信作为一款国民级App，保护版权是其本应承担起的责任。但针对如今的状况，也有不同的看法。茶几（化名）是一个小程序开发运营，他向刺猬公社表示，目前微信小程序的生态其实没啥问题，“高速发展的前期，所谓的山寨算是中国特色了，挺健康”。茶几说，目前小程序的门槛低，但是要做得好，就需要靠实力来打造自己的壁垒，因此在一定程度上也是一种公平。在茶几看来，在小程序的架构开发上，即便对方完全抄袭了他的交互界面和设计，也不会觉得这是抄袭。“我感觉就像餐饮店，你不会觉得互相有抄袭（有）很大问题。你可以把所有抄的东西，看成是标准化的东西，大家容易上手 ，符合用户习惯。（实际上）比拼的是能抄的以外的东西。”至于小程序内容侵权的乱象，茶几则认为这和小程序本身没有关系。“小程序只是个工具，侵权的课程搬到别的地方照样是侵权。”他偏向于认为，内容侵权乱象的出现和平台无关，问题是出在侵权方身上。艰难维权，哪招最管用？侵权成本远低于维权成本，这一直是内容行业的痛点。对此，陈敛表示乐观。“创业三年，我们和业内越来越多内容生态参与方一起推动版权保护和应用，这本身就是向好的。”维权骑士发布的“2018内容行业版权报告”中写道，被侵权的创作者数量占整体创作者的比例已经下降，从2016年到2018年由59%下降至41%，且内容创作者单篇内容的平均侵权次数也由8次下降到7次。但摆在眼前的事实依旧十分严峻。在陈敛看来，想要打破“侵权乱象”，光是版权方主动维权还不够，需要社会多方的共同推进。对于平台方来说，对于版权侵权的治理态度和机制十分重要，需要主动遏制侵权行为；而对于司法来说，针对一些代表性平台上频发的侵权情况，也需要综合考虑法律法规对平台责任的界定和案件社会导向性的因素。实际上，腾讯公司对于微信小程序的侵权行为以及其他乱象，也并非是完全放任自由。目前腾讯公司针对微信小程序，通过《服务条款》《运营规范》《常见拒绝情形》和《开放的服务类目》建立起了四大运营规则，进行整治。对于小程序资质不合格的开发者，腾讯会将其纳入黑名单并起诉索赔；而内容侵权与昵称、头像和功能简介山寨的情况，腾讯公司也会根据侵权投诉进行评估，从而采取包括但不限于搜索限制、处理侵权元素以及下架的处罚措施。但对于“下架”这一处罚措施，腾讯公司非常谨慎。如果在进行侵权的评估时，开发者自行删除了侵权投诉的内容，例如第一起小程序版权案中的被告百赞公司，那么腾讯公司就会避免对整个小程序进行下架处理，保护小程序的整体权益。目前，刀豆公司与腾讯公司的第二局比拼已经开始，最终的结果会偏向于谁呢？"}
{"title": null, "author": null, "pub_time": null, "content": ""}
{"title": "小程序性能优化的几点实践技巧 ", "author": "Rolan", "pub_time": "2019-4-2 00:21", "content": "大家好，我叫张文轩，这是我的第6篇分享我们都知道，性能的好坏直接影响用户的体验。本文首先论述下如何评判一个小程序页面的性能情况，之后通过具体的案例重点讲解下几点实践技巧，最后再讲讲key值在渲染一个列表时发挥了一个怎么样的作用，以此来论述为啥key值对性能提升有帮助。评判小程序页面性能由于小程序开发环境的特殊性，我们不能像普通网页那样通过chrome开发工具或者一些成熟的性能测试工具（例如Lighthouse）来了解一个页面的性能，但微信官方提供了一个性能评分的工具，点击这里可以查看工具详情。体验评分是一项给小程序的体验好坏打分的功能，它会在小程序运行过程中实时检查，分析出一些可能导致体验不好的地方，并且定位出哪里有问题，以及给出一些优化建议。后面我会以一个实际的例子来展示如何通过该工具来优化页面性能，我们先看下我们页面优化前的一个评分情况。存在setData的数据过大我们的功能里面有个滚动到底部加载的功能，优化前我们的做法是这样的<!--只阐述逻辑，非真实代码-->\r\n\r\n// 1: 初始一个list，存储列表数据\r\ndata = startList\r\n// 2: 监听滚动事件，滚动到底部获取新数据，并追加到list尾部,最后重新setData\r\nonReachBottom:()=>{\r\n    const {list} = this.data\r\n    fetchNewData().then((res)=>{\r\n        list.push(res.list);\r\n        this.setData({list})\r\n    }\r\n}\r\n复制代码我估计大部分人面对长列表滚动的时候，一开始的处理方式都是这样的，如果数据不多，只有几页可能不会太暴露问题，如果页数过多，几十页甚至上百页的情况，list的数据会越来越大，每次setData的数据就会越来越多，因而每次页面重新渲染的节点就会越来越多，从而导致滚动到后面，加载越来越慢。另外，由于小程序的视图渲染层和数据逻辑处理层是分开的，不是在同一个线程上面的，从用户触发页面交互，到处理数据逻辑，最后层现页面，数据到视图是需要传输的，因而小程序本身对数据大小也有限制，不能超过1M。setData数据路径怎么解决呢？小程序setData里面的key支持数据路径的写法，比如let o = obj;\r\nthis.setData({\r\n    'o.属性'：value\r\n})\r\n\r\n或者\r\nlet a = array;\r\nthis.setData({\r\n    'array[0].text':value\r\n})\r\n复制代码所以我们可以通过数据路径的写法，来将数据分批的传输到视图层中，减少一次性setData的数据大小。具体写法如下// 1.通过一个二维数组来存储数据\r\nlet feedList = [[array]];\r\n\r\n// 2.维护一个页面变量值，加载完一次数据page++\r\nlet page = 1\r\n\r\n// 3.页面每次滚动到底部，通过数据路径更新数据\r\nonReachBottom:()=>{\r\n    fetchNewData().then((newVal)=>{\r\n        this.setData({\r\n            ['feedList[' + (page - 1) + ']']: newVal,\r\n        })\r\n    }\r\n}\r\n// 4.最终我们的数据是[[array1],[array2]]这样的格式，然后通过wx:for遍历渲染数据\r\n复制代码存在短时间内发起太多图片请求（图片懒加载）这个应该好理解，就是渲染页面时，一次性发送了过多的图片请求，导致了同一时间发起了过多的http请求，http连接是非常耗时的，尤其是一次性发起这么多，并且一次性发起的http链接也是有限制的，比如chrome浏览器就限制一次性最多6个。所以在渲染页面时，不在视图范围内的图片我们不加载，只有元素出现在视图范围内了，再渲染。常规的做法是，通过 getBoundingClientRect() 获取元素的位置，然后与页面滚动位置比较，如果出现在视图内，就将 img 显示。这种方式有2个问题getBoundingClientRect()方法调用本身容易引起页面重排监听滚动事件本身就频繁触发，虽然可以通过节流的方式来减少，但还是容易增加无谓代码处理IntersectionObserver其实，微信提供了 IntersectionObserver 对象。IntersectionObserver 对象，用于推断某些节点是否可以被用户看见、有多大比例可以被用户看见通过这个api我们不用再主动去监听元素位置了，在页面渲染一开始，通过这个api指明需要监听的元素，系统会自动去监听了元素位置。let data = list;\r\n\r\n<img class=\"img-{{index}}\" wx:for=\"{{data}}\"></img>\r\n\r\ndata.forEach((item,index)=>{\r\n    this.createIntersectionObserver().relativeToViewport.observe(`.img-${index}`,res=>{\r\n        if (res.intersectionRatio > 0){\r\n            this.setData({\r\n                item.imgShow:true\r\n            })\r\n        }\r\n    })\r\n})\r\n\r\n复制代码intersectionRatio值大于0，说明元素出现在视图中了，重新setData数据，显示图片组件。存在图片太大而显示区域过小这个问题就是指图片尺寸太大了，而页面上我们显示的尺寸又太小了，图片尺寸大，请求图片就越慢，导致页面渲染速度下降。CDN图片处理对于页面里面的图片，最好都把图片存储在cdn服务器上，一个是能充分利用cdn缓存来加快请求速度，另外一个就是cdn上能够将图片进行一定的处理，比如裁剪。我司就是通过cdn来响应图片处理，然后请求图片时告诉cdn服务器需要什么要的尺寸图片，由cdn服务器响应对应尺寸图片。key值在列表渲染中的作用key值在列表渲染的时候，能够提升列表渲染性能，为什么呢？首先得想想小程序的页面是如何渲染的，主要分为以下几步：将wxml结构的文档构建成一个vdom虚拟数页面有新的交互，产生新的vdom数，然后与旧数进行比较，看哪里有变化了，做对应的修改（删除、移动、更新值）等操作最后再将vdom渲染成真实的页面结构key值的作用就在第二步，当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。key值如果不指明，默认会按数组的索引来处理，因而会导致一些类似input等输入框组件的值出现混乱的问题。相关测试代码可以查看：wxkey可以看到不加key,在数组末尾追加元素，之前已渲染的元素不会重新渲染。但如果是在头部或者中间插入元素，整个list被删除重新渲染，且input组件的值还出现了混乱，值没有正常被更新添加key，在数组末尾、中间、或者头部插入元素，其它已存在的元素都不会被重新渲染，值也能正常被更新因而，在做list渲染时，如果list的顺序发生变化时，最好增加key，且不要简单的使用数组索引当做key。最后看看我们的成果：体验码：希望今天我的分享能对您优化小程序页面有一定的启示，创造出性能更好更流畅的页面。最后如果喜欢我的文章，欢迎点击关注，我会不定期的分享自己的一些所看所想，和大家一起成长，持续学习。"}
{"title": "微信小程序搭建mpvue+vant+flyio ", "author": "Rolan", "pub_time": "2019-4-4 00:08", "content": "上一篇文章 微信小程序搭建mpvue+vant 已经介绍了如何搭起mpvue项目及引入vant，本篇文章继续在它的基础上，引入flyio，并做一些封装，目的是为了在小程序发起请求。这时读者会有些疑问，小程序已经有了request，为什么还用flyio？这不是造轮子吗？我是这么想的，其实现在不管是mpvue，还是wepy都好像还不能完美编译出微信小程序和h5版本。为了以后应对老板有创建h5版本的想法，我们应该为以后复用小程序代码做好准备工作。既然h5也会有ajax，flyio也支持小程序和h5的，所以干脆把flyio引进来，再做一些封装，两边都能用，岂不美哉？第一步：将flyio加入项目我的项目路径：/Users/hrz/myworkspace/lawyer-card-wxss$ cd /Users/hrz/myworkspace/lawyer-card-wxss\r\n$ cnpm install flyio\r\n复制代码第二步：二次封装创建 api 文件夹，并在下面新建两个文件 api.js ， httpRequest.jsapi.js 用来给各页面调用，是一个汇总各类ajax方法的集合import requestService from './httpRequest'\r\n\r\nconst PROD_SERVICE = 'https://我的线上产品域名/lawyer-card-service'\r\nconst DEV_SERVICE = 'http://localhost:8081/lawyer-card-service'\r\n\r\n/**\r\n * 根据开发环境返回接口url\r\n * @returns {string}\r\n */\r\nfunction getSerive () {\r\n  if (process.env.NODE_ENV === 'production') {\r\n    return PROD_SERVICE\r\n  } else {\r\n    return DEV_SERVICE\r\n  }\r\n}\r\n\r\n/** wx.request服务封装 */\r\nexport default {\r\n\r\n  /**\r\n   * 检查微信Token是否还生效\r\n   * @param data\r\n   * @param callBack\r\n   */\r\n  checkToken (data, callBack, failCallBack) {\r\n    requestService.sendRequest().url(getSerive() + '/auth/checkToken').method('GET').data(data).success(res => {\r\n      callBack(res)\r\n    }).fail(res => {\r\n      failCallBack(res)\r\n    }).send()\r\n  }\r\n\r\n复制代码httpRequest.js是对flyio对二次封装，是ajax的核心import {getStorageSync, hideLoading, showLoading, showNotify} from '../utils/index'\r\n\r\nvar Fly = require('flyio/dist/npm/wx')\r\nvar fly = new Fly()\r\n// 设置超时\r\nfly.config.timeout = 7000\r\n\r\n// 添加请求拦截器\r\nfly.interceptors.request.use((request) => {\r\n  // 给所有请求添加自定义header\r\n  const token = getStorageSync('token')\r\n  request.headers['token'] = token\r\n  return request\r\n})\r\n\r\n/**\r\n * request服务封装\r\n */\r\nexport default {\r\n  sendRequest\r\n}\r\n\r\nfunction sendRequest () {\r\n  return {\r\n    _sucCallback: null,\r\n    _failCallback: null,\r\n    _method: 'GET',\r\n    _data: {},\r\n    _header: {'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'},\r\n    _url: '',\r\n    send: function () {\r\n      showLoading({\r\n        title: '加载中...'\r\n      })\r\n\r\n      fly.request(this._url, this._data, {\r\n        method: this._method,\r\n        headers: this._header\r\n      })\r\n        .then(res => {\r\n          hideLoading()\r\n          let error = httpHandlerError(res, this._failCallback)\r\n          if (error) return\r\n          this._sucCallback(res)\r\n        })\r\n        .catch((res) => {\r\n          hideLoading()\r\n          httpHandlerError(res, this._failCallback)\r\n        })\r\n\r\n      return this\r\n    },\r\n    success: function (callback) {\r\n      this._sucCallback = callback\r\n      return this\r\n    },\r\n    fail: function (callback) {\r\n      this._failCallback = callback\r\n      return this\r\n    },\r\n    url: function (url) {\r\n      this._url = url\r\n      return this\r\n    },\r\n    data: function (data) {\r\n      this._data = data\r\n      return this\r\n    },\r\n    method: function (method) {\r\n      this._method = method\r\n      return this\r\n    },\r\n    header: function (header) {\r\n      this._header = header\r\n      return this\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * info 请求完成后返回信息\r\n * callBack 回调函数\r\n * errTip 自定义错误信息\r\n */\r\nfunction httpHandlerError (info, callBack) {\r\n  hideLoading()\r\n  /** 请求成功，退出该函数 可以根据项目需求来判断是否请求成功。这里判断的是status为200的时候是成功 */\r\n  let haveError = true\r\n  let errTip\r\n  if (info.status === 200) {\r\n    if (info.data.code === undefined) {\r\n      haveError = true\r\n    } else if (info.data.code === 'success' || info.data.code === 0) {\r\n      haveError = false\r\n    } else {\r\n      haveError = true\r\n      errTip = info.data.msg\r\n    }\r\n  } else {\r\n    errTip = '网络请求出现了错误【' + info.status + '】'\r\n    haveError = true\r\n  }\r\n\r\n  if (haveError) {\r\n    /** 发生错误信息时，如果有回调函数，则执行回调 */\r\n    if (callBack) {\r\n      callBack(info)\r\n    } else {\r\n      showNotify(errTip)\r\n    }\r\n  }\r\n  return haveError\r\n}\r\n复制代码大家看到， httpRequest.js 里引用一些工具类，其实里面主要是一些加载的提示，及弹框。为什么我要把他放在工具类里？正如我最开头导语说的，为了方便以后应对h5版本，H5版本的加载、弹框、操作缓存和小程序的代码不一样，所以我统一放在工具类里管理了，以后要做h5开发，我只要改工具类就行了。下面是小程序里工具类的代码。import Notify from 'vant-weapp/dist/notify/notify'\r\n\r\n/**\r\n * 显示顶部红色通知\r\n * 使用方法：调用时确保界面上有：\r\n * <van-notify id=\"van-notify\"/>\r\n * @param msg\r\n * @param showTime\r\n */\r\nexport function showNotify (msg, showTime) {\r\n  if (!showTime) {\r\n    showTime = 3000\r\n  }\r\n  Notify({\r\n    text: msg,\r\n    duration: showTime\r\n  })\r\n}\r\n\r\n/**\r\n * 从缓存里获取数据\r\n * @param key\r\n * @return value\r\n */\r\nexport function getStorageSync (key) {\r\n  return wx.getStorageSync(key)\r\n}\r\n\r\n/**\r\n * 显示加载中\r\n * @param data\r\n */\r\nexport function showLoading (data) {\r\n  wx.showLoading(data)\r\n}\r\n\r\n/**\r\n * 隐藏加载中\r\n */\r\nexport function hideLoading () {\r\n  wx.hideLoading()\r\n}\r\n\r\n/**\r\n * 将数据保存到缓存\r\n * @param key\r\n * @param value\r\n */\r\nexport function setStorageSync (key, value) {\r\n  wx.setStorageSync(key, value)\r\n}\r\n\r\nexport default {\r\n  getStorageSync,\r\n  setStorageSync,\r\n  showLoading,\r\n  hideLoading,\r\n  showNotify\r\n}\r\n\r\n复制代码第三步：写个Demo发送请求<template>\r\n <div>\r\n   {{msg}}\r\n </div>\r\n</template>\r\n\r\n<script>\r\n import Api from '../../apis/api'\r\n\r\n export default {\r\n   data () {\r\n     return {\r\n       msg: null\r\n     }\r\n   },\r\n\r\n   methods: {},\r\n\r\n   onLoad () {\r\n     let that = this\r\n     let token = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJzdWIiOiIxIiwiaWF0IjoxNTU0MjA0NDI0LCJleHAiOjE1NTQ4MDkyMjR9.VdlhGXOxIA97_G_u_a3GJxmWdD9t_jb_a1aodTJ75ESNgxchx8M0mRBSx-s_er8Da4MzZY1zBW4UfY5ELC9fgA'\r\n     Api.checkToken({'token': token}, function (res) {\r\n       console.log(res)\r\n       that.msg = res.data.msg\r\n     })\r\n   }\r\n }\r\n</script>\r\n\r\n<style scoped>\r\n</style>\r\n\r\n复制代码运行 npm run dev 起来，去小程序开发工具看效果已经成功发送请求，还是不错的！"}
{"title": "小程序侵权“生死局” ", "author": "Rolan", "pub_time": "2019-4-4 00:01", "content": "产品越小，越经不起侵权的威胁，也越容易被快速复制。至少在小程序这块，大体如此。在湖南长沙的一间小茶馆里，小程序创业者王磊说起一年多来追逐风口的经历，就颇为神伤。“原本团队里有三五个人，也做成了几款小程序。可没一款成功的，大家过年前就散伙了。”王磊宣称，自己参与的几款小程序，上线后都无声无息，倒是其中一款诗词的，很快见到了高仿小程序。结果，似乎那个高仿火了好一阵子。“人家一火，我们几个刚毕业决定创业小程序大风口的小伙伴，就凉了。”王磊也试过举报、申诉，但用处都不太大。“一个小程序往往就火那么十天半个月，等申诉成功，黄花菜都凉了。”在老家过完春节，准备找工作的王磊突然看到了一则报道，这似乎重新燃烧起了他的斗志。小程序侵权，不仅是“山寨”王磊看到的新闻发生在2月27日。其实，作为小程序创业者，这则消息之前他也有看到过相关报道，但并没关注。在那一天，杭州互联网法院一审公开宣判了一起网络信息传播权纠纷案。被告之一长沙某网络公司因侵害原告作品信息网络传播权，被判赔偿原告杭州某互联网企业经济损失15000元。这是杭州互联网法院审理的首例涉微信小程序案件。“外行看重首例二字，同乡看见了长沙，我则看到了‘内容’。”说到此，王磊颇有点自得。“这个事，之前小程序圈子里谈的比较多。关键就在于报道中的一段话，‘法院经审理查明，长沙某网络公司在腾讯公司微信上注册开发了微信小程序，其未经原告许可，在小程序中传播原告享有信息网络传播权的作品。’”王磊说，整个侵权，其实就是这个小程序未经许可，传播了一个网红作家的心理学课程。过去谈到小程序侵权，大多集中在技术上的借鉴或玩法上的山寨上。“那种很难抓实，算是互联网顽疾。但这个案例则不同，小程序作为产品没有问题，但它提供的内容侵权了，结果一抓一个准。”王磊如是分析。这似乎给了王磊一个新的创业方向，“我还没想明白，等想通了立刻会着手试试。”王磊信心满满：那几个走了的伙伴，也都想再试一试。小程序一火爆，就带着“原罪”几乎所有的互联网风口，一开始都会泥沙俱下，出现大面积山寨的景象，但危也是机。互联网从业者许如惠有着和王磊相似的观点：在体量很小、技术门槛不高的小程序领域，你要想用创意作为护城河，本质上很难。难道不允许创意撞衫吗？但如果内容做护城河，就不一样了。许如惠用了2个案例，来说明小程序“创意撞衫”的难以评判，其一是很多人都玩过的《跳一跳》，其二是现在很多人已经不记得的《西瓜足迹》。2018年6月1日，很多人在朋友圈上看过这幅图：一张中国地图，只要去过的地方，就点亮成为黄色，展示出你的朋友去了多少城市、超过了多少用户。这是彼时一夜爆红的小程序《西瓜足迹》。就在第二天凌晨0时，该小程序开发者戴宏民兴奋地发布了朋友圈，宣告该程序一天的访问量达到一千万。随后，争议也来了——就在戴宏民发完朋友圈的当天，一位名叫赵恩彪的小程序开发者也发了条朋友圈，声称西瓜足迹和他半年前开发的脚步地图，实在是太像了，要维权。一时间，这个疑似“侵权”事件闹得沸沸扬扬。但很快也就如同许多热门的互联网侵权案例一样，悄无声息了。“界定太难，哪怕你觉得它们都用了同样的地图，同样的界面，同样的玩法。但地图难道还有不一样的吗？”许如惠说：“《西瓜足迹》一周后被微信官方下架，也就划上了句号。”但在王磊看来：《西瓜足迹》暴露出的一个更大的问题：爆红了之后又如何？就算没有这个侵权的问题，又该如何把流量变现呢？似乎，小程序只是提供了广告和导流这样的极简变现手段。“小程序一出世，其实就带着山寨的原罪。”许如惠称：2018年初，让本来问世许久不温不火的小程序突然成了风口的《跳一跳》，就是始作俑者。当时，就有人指出，《跳一跳》和另一款名为《欢乐跳瓶》的iOS游戏高度撞脸。“欢乐跳瓶”的英文名字为“Bottle Flip”，这是国外团队Ketchapp开发的小游戏，于2016年底上线，曾在国外十分火爆。然而，这样的议论尽管被媒体广泛报道之后，依然很快消失。“没有人关心到底是山寨还是撞衫，本身《跳一跳》的热度也就那么长。”许如惠称：而后，在小程序领域中，不出所料的出现了一股复活风。小程序“复活”，过把瘾就走但凡走工具路线的小程序，只要是个体户，都难长久，此处需要内容做护城河。许如惠口中的复活风，指的是：小游戏带出小程序风口后，在2018年春天，出现的大量复活游戏。曾在2018年大火过的黑咖相机负责人姜文一对媒体就说过一段话：有些人进来就是赚钱的，他们不会管你生态怎么样，想要造纸就伐木头，这其实是在对整个生态进行破坏。”而这种破坏最集中的体现，就是三四月涌现的那批复活类小游戏。“三四天上线一个小游戏，那是说的审核速度。”游戏从业者鲁日昱则直言不讳的指出：其实当时许多小游戏，不存在任何设计难度。过去在单机游戏里出现过，后来网游时代复活一轮、页游时代复活一轮、手游时代又复活一轮，在小程序火热前，这一波游戏还在H5游戏里复活过一轮。这种复活模式本质上也是山寨。游走在侵权的边缘。但危害却不仅仅只是侵权。“对创意的伐害才是最大的伤害。”王磊对复活游戏颇为深恶痛觉：“当时复活小游戏一出来，我就知道要坏事，我们在后台数据中就能看到，用户分享小程序的热情，明显被一盆冷水给浇灭了。”“这波都是机会主义蝗虫，每一次肆虐风口，都会快进快出、留下一地鸡毛。但也并非一无是处。”有着近二十年从业经验的鲁日昱则总结道。很多小程序创业者也随后退场，理由很简单，工具类的小程序没有前途，毕竟这些工具在大型App上都有分担，比如：美图、文档处理、个税公式、经期排卵期计算等，那些垂直类的App一旦和微信小程序打通互通口，也就达成了清场。或许，WPS在2018年6月通过小程序，快速完成了办公业态在移动互联网和移动社交的新蝶变，最终达成亿级用户量的激活，则可看做一个老牌工具的小程序成功路径。“同时，各种所谓文档处理、扫描、协同办公之类的小程序，不管之前火不火，都活不成。”王磊感慨道：还是要有护城河，而不是光靠脑洞。最易侵权，也是最不易侵权内容最容易被抓取到各种应用里，几乎没有技术难度；但一旦被抓包，就是铁证。在杭州互联网法院首例涉微信小程序的侵权案中，“腾讯公司作为微信小程序服务提供者首次被起诉”，这个梗颇为引人注目。但最终，原告对被告腾讯公司的所有诉讼请求被驳回。法院认为，小程序平台不存储开发者具体服务内容，并非信息存储服务空间。小程序上的内容由开发者直接向用户提供，小程序平台技术上无法针对实际由开发者提供的具体服务内容采取处理措施，这一技术服务属性决定了腾讯公司无法做到一般网络服务提供者所能采取的删除、屏蔽等必要措施。因此，该案涉及小程序平台的情形不适用“通知—删除”规则。然而，无法删除、屏蔽，并不代表无法解决。据微信官方在2019微信公开课上公布的数据显示：2018年全年微信小程序侵权投诉近4000件。从投诉类型看，主要分为两大类：一是小程序的昵称、头像、功能简介；二是小程序内容。从投诉内容来看，涉及著作权侵权、商标侵权及专利侵权等，其中，著作权侵权投诉颇多。“显然，这一问题代表着小程序下一阶段的风向：内容致胜。”王磊坦言：都知道工具类不可为、小游戏难持久，而创业者的内容从哪来？最容易的方式是扒别人的内容。但小程序平台肯定很快就要加大力度；最合适的方式是找到新的内容生成空间，但在内容巨头环伺的情况下，何其难。“但难也未必不能实现。”王磊笑了笑，颇神秘的说。他打算从之前做过的诗词小程序入手，而刘慈欣的一则科幻小说则给了他一个很好的灵感。“让大家都能撩出一首好诗，不就是原创内容了吗？”显然，王磊的思路来自于大刘的短篇《诗云》：一个用大数据穷算一切诗词的故事，能否在小程序中成功，也是个生死局。还好，唐诗宋词怎么用，都和侵权无关……#专栏作家#张书乐，微信公众号：zsl13973399819 ，人人都是产品经理专栏作家。关注互联网和游戏产业，专注产业分析与网络营销，著有《实战网络营销》《榜样魔兽》等书。本文由@张书乐 原创发布于人人都是产品经理，未经许可，禁止转载。题图来自Unspalsh, 基于CC0协议。"}
{"title": "使用weixin-java-miniapp配置进行单个小程序的配置 ", "author": "Rolan", "pub_time": "2019-4-4 00:34", "content": "在进行小程序后端接口开发方面，使用weixin-java-tools中的weixin-java-miniapp模块，往往可以事半功倍。引入weixin-java-tools在 https://mvnrepository.com/ 中搜索 weixin-java-miniapp ，进入微信小程序 Java SDK这个项目中。选择相应正式版本来进行使用。maven中在依赖中添加如下配置项：<dependency>\r\n    <groupId>com.github.binarywang</groupId>\r\n    <artifactId>weixin-java-miniapp</artifactId>\r\n    <version>3.3.0</version>\r\n</dependency>gradle中添加如下配置项：compile(\"com.github.binarywang:weixin-java-miniapp:3.3.0\")注意：以上我用的版本是3.3.0，实际中根据你要使用的版本来用。配置文件配置文件中主要配置四项参数，分别是：appIdsecrettokenaesKey配置初始化：weixin-java-miniapp可以使用注解来进行配置，具体步骤如下：在config包中创建WxMaConfiguration类。使用@Configuration注解来进行小程序相关的参数配置，可参考以下代码。该代码示例中是单个小程序配置示例，如果需要配置多个小程序的参数，请参考官方案例 点击进入 。package com.diboot.miniapp.config;\r\n\r\nimport cn.binarywang.wx.miniapp.api.WxMaService;\r\nimport cn.binarywang.wx.miniapp.api.impl.WxMaServiceImpl;\r\nimport cn.binarywang.wx.miniapp.config.WxMaInMemoryConfig;\r\nimport dibo.framework.config.BaseConfig;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\n\r\n@Configuration\r\npublic class WxMaConfiguration {\r\n\r\n    // 此处获取配置的方式可以改成你自己的方式，也可以注解等方式获取配置等。\r\n    private static final String appId = BaseConfig.getProperty(\"wechat.appId\");\r\n    private static final String secret = BaseConfig.getProperty(\"wechat.secret\");\r\n    private static final String token = BaseConfig.getProperty(\"wechat.token\");\r\n    private static final String aesKey = BaseConfig.getProperty(\"wechat.aesKey\");\r\n\r\n    private static WxMaService wxMaService = null;\r\n\r\n    @Bean\r\n    public Object services(){\r\n        WxMaInMemoryConfig config = new WxMaInMemoryConfig();\r\n        config.setAppid(appId);\r\n        config.setSecret(secret);\r\n        config.setToken(token);\r\n        config.setAesKey(aesKey);\r\n\r\n        wxMaService = new WxMaServiceImpl();\r\n        wxMaService.setWxMaConfig(config);\r\n\r\n        return Boolean.TRUE;\r\n    }\r\n\r\n    public static WxMaService getWxMaService(){\r\n        return wxMaService;\r\n    }\r\n}开始使用在需要使用小程序相关接口的地方，只需要通过该配置类中的静态方法getWxMaService()来获取到wxMaService即可开始使用，如：// 获取小程序服务实例\r\nWxMaService wxMaService = WxMaConfiguration.getWxMaService();\r\n// 获取小程序二维码生成实例\r\nWxMaQrcodeService wxMaQrcodeService = wxMaService.getQrcodeService();\r\n// 便可以开始使用wxMaQrcodeService来进行二维码相关的处理了\r\n...."}
{"title": "小程序开发实用技巧——扩展 Page 页面对象 ", "author": "Rolan", "pub_time": "2018-7-25 00:18", "content": "小程序是通过调用 Page 函数来注册一个页面的：//index.js\r\nPage({\r\n  data: {\r\n    text: \"This is page data.\"\r\n  },\r\n  onLoad: function(options) {\r\n    // Do some initialize when page load.\r\n  },\r\n  // Event handler.\r\n  viewTap: function() {\r\n    this.setData({\r\n      text: 'Set some data for updating view.'\r\n    }, function() {\r\n      // this is setData callback\r\n    })\r\n  }\r\n})\r\n复制代码这里 Page 的作用相当于构造函数， Page 会初始化页面对象（实例），然后将配置参数中的属性 merge 到页面对象上。假设你封装了个 http 模块负责发出请求，你想在页面对象中直接通过 this.http 引用这个模块，就需要扩展页面对象。要扩展一个对象，在 JavaScript 中的常见做法是扩展构造函数的 prototype 属性，这是 Vue 很多插件的实现：import axios from 'axios'\r\nVue.prototype.axios = axios\r\n// 在 vue 组件中\r\nthis.axios.get(api).then(callback)\r\n复制代码很不幸，在小程序中这个办法无效。 Page 并不是普通的构造函数，底层还做了很多其他事情，没办法直接通过 Page.prototype 扩展页面对象。我们可以转变思路，扩展传进 Page 的配置对象。既然始终要通过调用 Page 注册页面，可以定义一个函数，这个函数会将收到的配置对象参数进行处理，然后再传给 Page 。// wxPage.js\r\nimport http from '../utils/http'\r\n\r\nconst wxPage = function(config) {\r\n  config.http = http\r\n  return Page(config)\r\n}\r\n\r\nexport default wxPage\r\n复制代码注册页面的时候改用这个 wxPage ：import Page from './wxPage'\r\n\r\nPage({\r\n  data: {\r\n    text: \"This is page data.\"\r\n  },\r\n  onLoad: function(options) {\r\n    console.log(this.http) // 打印 http 模块变量\r\n    this.http.get(api).then(callback) // 直接调用 http 的方法\r\n  },\r\n})\r\n复制代码直接修改 Page 函数为了增强页面对象，每个需要的页面都得引入 wxPage 是一件不太省心的事；更多时候我们是在维护一个老项目，需要扩展每个原有的页面对象，这时可以直接修改 Page ：const originalPage = Page //保存原来的Page\r\nPage = function(config) { // 覆盖Page变量\r\n  config.http = http\r\n  return originalPage(config)\r\n}\r\n复制代码一般来说，修改 Page 的时机是在 App onLoad 的时候。这样原有的页面不用修改，直接就能通过 this.http 拿到 http 。通过扩展 Page 页面对象实现常见需求1. 给生命周期方法增加通用逻辑有时我们希望在页面注册的 onLoad 阶段执行一些通用的逻辑，例如埋点，打 log 等，这时可以改写配置对象中的 onLoad 方法：const originalPage = Page\r\nPage = function(config) {\r\n  const { onLoad } = config\r\n  config.onLoad = function(onLoadOptions) {\r\n    // 打 log、埋点……\r\n    console.log('每个页面都会打出这个log')\r\n    if (typeof onLoad === 'function') {\r\n      onLoad.call(this, onLoadOptions)\r\n    }\r\n  }\r\n  return originalPage(config)\r\n}\r\n复制代码2. 获取上一页页面对象小程序中的页面跳转会形成一个页面栈，栈中存放着每个页面对象，可以通过getCurrentPages 方法获得这个页面栈。可以在页面 onLoad 的时候获取这个页面栈，然后取出倒数第二个对象，就是当前页上一页的页面对象：// 接上...\r\n  const { onLoad } = config\r\n  config.onLoad = function(onLoadOptions) {\r\n    const pages = getCurrentPages()\r\n    this.__previousPage = pages[pages.length - 2] // 将上一页的页面对象赋为this.__previousPage\r\n    if (typeof onLoad === 'function') {\r\n      onLoad.call(this, onLoadOptions)\r\n    }\r\n  }\r\n  return originalPage(config)\r\n复制代码这样在页面对象中可通过引用 this.__previousPage 获取上一页页面对象的data及所有方法，这样在一些只需要两个页面互动的情景下，当前页直接调用上一个页面对象的方法（相当于回调）后再返回，比通过全局状态管理上一页的数据要方便。3. 跳转页面并传递数据到下一页这个不多说了，直接看代码吧：// 接上\r\nconfig.navigateTo = function(url, params) { // 实现一个navigateTo方法，参数包括跳转url和要传递的参数\r\n  this.__params = params\r\n  wx.navigateTo({ url })\r\n}\r\n\r\nconfig.onLoad = function(onLoadOptions) {\r\n  const pages = getCurrentPages()\r\n  this.__previousPage = pages[pages.length - 2] // 将上一页的页面对象赋为this.__previousPage\r\n  if (this.__previousPage) {\r\n    onLoadOptions.params = this.__previousPage.__params // 获取上一页面的__params赋给onLoad函数的options\r\n    delete this.__previousPage.__params\r\n  }\r\n  if (typeof onLoad === 'function') {\r\n    onLoad.call(this, onLoadOptions)\r\n  }\r\n}\r\n\r\n// A 页面跳转 B 页面\r\nthis.navigateTo('urlToB', { foo: 'bar' })\r\n\r\n// B 页面的 onLoad\r\nPage({\r\n  onLoad(options) {\r\n    console.log(options.params) // { foo: 'bar' }\r\n  }\r\n})\r\n复制代码就写到这里吧，在使用原生方案开发的时候，这些技巧还是挺实用的。以后再写写怎样构建小程序，使小程序支持文件预编译、require npm 包等。"}
{"title": "微信小程序上线“页面收录”功能，真正的SEO时代来了！ ", "author": "Rolan", "pub_time": "2019-4-4 00:03", "content": "“搜索一直应该是小程序的一个主要流量来源，小程序和APP的一个很大不同，APP是一个个的信息孤岛，互相之间没法交换信息。但小程序是可以被系统统一检索到，是可以直接搜索到小程序里面的内容的。”——张小龙于2019微信公开课Pro靴子终于落地。3月29日，不少小程序开发者在后台收到了一条通知，通知表示，小程序新增页面收录功能，开发者可以设置小程序是否能被收录，或者通过配置实现特定页面被收录。乍一看有些云里雾里，实际上，这项能力在微信安卓7.0.4版中曾灰度测试过，让我们能一睹真容：只要开启了该功能，小程序每一个页面都能被直接搜索到，比如搜索“计算器”，在内容一栏中就会展示页面中含有“计算器”的小程序，点击之后直达该页面。也就是说，理论上所有小程序页面都能被用户搜索，上百万个小程序的内容全部被打开，连成了一片信息的汪洋大海。1小程序SEO时代来了对于这项能力，有开发者用了“太震撼”三个字来形容，并且认为它的重要性不亚于去年的下拉“小程序桌面”。为了更深入了解它，我们不妨以搜索巨头百度作为参考。在搜索框里输入某个关键词，结果页就会展现出某个网站中含有该关键词的页面，点击就直达该页面，这就是页面收录功能的基本形式。我们可以就把小程序理解为网站，以前只能搜索整个网站，现在也可以搜索到里面的页面了。百度小程序前段时间推出了一项能力（点我阅读），就是把小程序拆分为一个个网页，并被搜索引擎抓取。微信此项新能力与此类似，也是通过搜索直达小程序页面。但百度智能小程序接入搜索的方式比较复杂，需在开发者工具中将小程序Web化，然后上传审核发布。而以前尽管微信也推出过搜索直达页面功能，即“服务直达”和“好物圈”，但都需要开发者主动申请配置，对于中小商家而言，有一定的技术门槛。而这一门槛现已不复存在，因为小程序“页面收录设置”默认开启，所以商家不需要任何操作，就能被收录到微信搜索中。然而，收录仅仅是开始，更重要的是，此后所有商家都能通过对页面结构的优化，使小程序的排名更加靠前，获取更多搜索流量。正如微信团队给我们的回复所说：“这一体验优化，可以帮助用户缩短寻找服务的路径，提升搜索效率，也可以帮助开发者的小程序获得更多曝光。”换句话说，小程序SEO时代从这一刻真正到来了。2微信搜索是小程序的下一站不过，在晓程序观察（yinghoo-tech）的调查中，也有商家表示质疑，用户有在微信里搜索的习惯吗？微信搜索的流量大吗？做小程序SEO有意义吗？商家的疑惑情有可原，毕竟“流量”是所有商家都关心的话题，也是最原始驱动力之一。确实，我们采访过的案例大都表示“功能直达”、“好物圈”等入口的量并不大，使用习惯尚待养成。但我们认为，搜索未来必定成为微信小程序的重要入口，理由有两点：1. 内容才是养成习惯的关键从用户侧来说，互联网从PC端走到移动端，在交互体验、使用场景上都发生巨大变化，而搜索的习惯却继承了下来，像搜索巨头百度，每日需要响应60亿次的搜索请求，可见搜索依旧是获取信息和服务的重要方式。并且，搜索行为往往与需求相伴，这与小程序“即用即走，触手可得”的特性也天然契合：需求产生——搜索小程序——使用服务——离开小程序，这条路格外顺畅。但有人会说，“搜索是日常行为不假，但习惯在微信里搜索的人却不多，抢占搜索流量有意义么？”我们不妨逆向思考这个问题，许多开发者表示，现在微信搜索最大的问题反倒不是使用习惯，而是缺乏内容，比如搜“羊毛大衣如何清洗”，完全得不到任何结果。但未来小程序页面收录功能全面上线后，所有有关“羊毛大衣如何清洗”的小程序页面都会被抓取到，可能是一篇文章，也可能就是羊毛大衣清洗服务，由此实现了搜—看—买的过程。所以有理由相信，未来搜索结果的内容丰富度不再是问题，用户习惯的养成也就水到渠成。2. 搜索将带来下一波流量红利从商家侧看，搜索将带来下一波微信的流量红利。以前，微信小程序的社交属性被过度放大，众多运营者们通过各种方式诱导用户转发分享，从而实现数据短时间内的爆炸增长，这对用户体验是巨大伤害。所以我们发现，微信一直在通过诸如限制跳转数量、收回分享回调等方式，逐步规范小程序的社交裂变行为，2019年第一季度，确实没有再看到现象级小程序的刷屏事件。有开发者表示，“社交流量带来的第一波红利期已经渐渐褪去，下一个取而代之的流量洼地应该是搜索”。因为搜索能让所有商家不论大小，都站在同一起跑线上，流量获取更加平等化。意思是在相同的搜索规则下，小团队开发的小程序通过页面结构的优化，提供更优质的服务，一样有机会排在头部小程序前面。比如，在除去使用过、好友用过、功能直达等客观因素外，搜索“北京天气”依旧是“墨迹天气”排第一，但在未来，大家公平角逐时，「北京天气查询」这样的小程序，也有机会通过页面优化排在最前面，因为提供的服务更加精准。这对于中小开发者而言无疑一大助推。如何让优质的小程序被更好的发现，这是微信一直关注的问题，目前来看，让服务与产品质量更高的小程序通过搜索入口自然涌现，这是微信给出的答案。3小程序SEO，需要提前这几点那么，商家如何提前落子，布局微信搜索呢？或许从传统搜索引擎的SEO方法中，可以获得一些思路。“过去做SEO 的方法是：结合站点属性和需求词数据，根据搜索引擎平台提供的索引规范和页面结构标准指引，不断进行调优化，从而提高索引收录排名的可能性”飞虎商联产品负责人周圣伟说到，他有着多年的建站以及SEO经验。但目前小程序页面收录能力仍处于内测，没有明确的索引规范，所以我们只能提出一些值得商家注意的地方。1.先考虑清楚哪些页面允许被收录需要强调，小程序页面收录开关是全局性的，意思是开启后小程序每个页面都能被搜索到，但有的小程序页面中包含开发者不想暴露的内容。此时就要选择“关闭收录”，然后单独进行sitemap配置，sitemap配置就是注明哪些页面可以被收录，哪些不能被收录。2.根据索引规范优化页面结构一般而言，索引规范会说明标题摘要、关键词的相关规则，例如“北京天气如何北京今天天气怎么样”这种关键词堆砌都是在禁止之列。另外，像页面内功能按钮的易用性，音频视频的使用情况，都要考虑在内。（百度智能小程序的索引规范）3.原创保护与抓取周期也要注意周圣伟告诉我们，格外需要注意的是品牌词与原创保护，比如，现在有许多小程序就是各类公号文章的集合，但这些小程序未来都有可能违反了原创保护，导致权重的下降。最后，索引的周期性也值得关注，搜索引擎的抓取一般有周期性，如果周期内页面没有更新，就不容易被抓取到，所以及时更新页面就成为一个关键。当然，上周推出的小程序评测能力，或许也与搜索排名有千丝万缕的联系，还有微信特有的社交关系，相信也是影响权重的重要指标。由此可见，未来小程序SEO将成为一门全新的产业，据我们了解，有很多小程序服务商已经嗅到了商机，都摩拳擦掌等待着在小程序SEO领域大干一场。当然，更具体的细则以及一些疑问，都要等这项新能力正式上线时才能揭晓。"}
{"title": "微信小游戏好友排行榜快速开发教程 ", "author": "Rolan", "pub_time": "2018-7-19 00:58", "content": "要做这个好友排行榜.必然要有好友的战绩比分,然后再做排序,最后将数据呈现在UI上 , 可以分为下面几个步骤:保存每个用户的分数获取好友列表,并获取好友的分数渲染排行榜保存每个用户的分数保存每个用户的分数,需要调用微信的云存储API,将用户的分数持久化的存起来 .// 保存用户数据,注意限制单条数据容量不得超过1024字节,\r\n// 单个用户数据总条数不得超过128条\r\nwx.setUserCloudStroage(Object)复制代码//存储最高分\r\nvar score = 100;\r\nvar kvScore = {\"key\":\"score\",\"value\":score};\r\nwx.setUserCloudStroage({\"KVDataList\":[kvScore]},\"success\":function(){\r\n    //\r\n});复制代码获取好友列表,并获取好友的分数​ 游戏中将玩家的分数保存起来以后,需要调用微信的云存储API wx.getFirendCloudStorage, 获取玩家的微信好友数据,这样就拿到了每个好友的最高分.值得一提的是,微信的这个接口在内部隐蔽的使用其微信的社交关系链 .返回列表中的包含的 调用过wx.setUserCloudStroage 这个接口的用户.渲染排行榜对分数进行排序 , 得到一个排行榜let sharedCanvas = wx.getSharedCanvas()\r\n\r\nfunction drawRankList (data) {\r\n  data.forEach((item, index) => {\r\n    // ...\r\n  })\r\n}\r\n\r\nwx.getFriendCloudStorage({\r\n  success: res => {\r\n    let data = res.data\r\n    drawRankList(data)\r\n  }\r\n})复制代码注意这个 sharedCanvas , 这是独有的画布 ,与小游戏中的画布不是同一个东东.使用sharedCanvas来自定义显示玩家的用户排行榜重要说明​ 上述所涉及的微信接口 , 都只能在微信小游戏的 子域 使用 , 微信官网也称之为开放数据域 , 其实应该称之为 封闭数据域 . ​ 为什么这么说呢?​ 因为子域的js代码执行环境和小游戏本身的代码执行环境是隔离的. 两者之间不能相通 , 子域只能接收外部的消息(如游戏的最高分),不能往外发消息(不能把用户的好友关系链数据发给开发者服务器) , 内存不共享,也就意味着,开发者拿不到微信的社交关系链数据 . 在这样的封闭条件下,开发者能做的只能是在子域的画布上将排行榜数据以个性化的UI元素展示出来 。"}
{"title": "官方问答精选《六》this.setData，动态改变navigationBarTitleText值 ", "author": "天下雪", "pub_time": "2016-12-25 02:35", "content": "本系列是我为小程序联盟的会员特别聚合，以便观看最新官方动态及学习已经解决问题以便跳坑；本系列仅供参考，如果发现已经不再适用，请优先查看官方文档或发帖咨询；\r\n问题一：\r\n地图会支持画线吗？ \r\n答：\r\npolyline 属性\r\n问题二：\r\nWebSocket 开发工具和手机预览实现结果不同 我在开发工具上进行 websocket调试 本地ip访问可以， 能够双向通信， 但是传到手机预览发现， 无法正常连接到本地的websocket服务器上。\r\n答：\r\n手机只支持公网域名的Websocket，本地IP是访问不到的。微信小程序不能建立两个（含）以上的WebStock连接。\r\n问题三：\r\n能否通过JS动态 改变navigationBarTitleText的值 能否通过JS动态改变navigationBarTitleText的值？\r\n\r\n答：\r\n1：可以在onLoad方法中通过wx.setNavigationBarTitle来设置，如下：\r\n  onLoad:function(options){    wx.setNavigationBarTitle({      title: '修改后的导航栏标题',      success: function(res) {        // success      }    })  },\r\n2：不过不建议这种做法，最好在对应page的josn文件中配置，会自动覆盖全局的标题{     \"navigationBarTitleText\": \"修改后的导航栏标题\"}\r\n\r\n问题四：\r\n小程序如何用多个手机进行预览我写的小程序只有管理员有权限进行体验，不知道如何布置才能让其他用户进行体验。而且我只有一个手机型号，我想多试几个手机型号。编辑器里面的和我手机里的差别还是比较大的。\r\n答：\r\n绑定多个体验者就好了。\r\n问题五：\r\nonPullDownRefresh 方法不执行 \r\n答：\r\n需要在app.json配置才生效的\r\n问题六：\r\n怎么用JS更改css的display属性？ \r\n答：\r\nstyle=\"display:{{这里放个变量}}\"；这个变量，，后面通过setData({这个变量:赋值})来实现更改\r\n问题七：\r\n动态设置image组件的src，是不是不可以呀 \r\n我这样做的时候，图片不能正常显示出来\r\n答：\r\n是可以的，最好是http完整路径，其它例如上传，选择等是不能的，上传是预览可以是使用image src=\"选择成功临时路径\"\r\n问题八：\r\nwx.saveFile保存的文件在哪里 \r\n\r\n\r\n不知道那个下载的文件在哪里？\r\n答：\r\n不需要关心下载到哪里（每个环境都不一样），只需要知道根据这个地址可以读取到文件即可\r\n问题九：\r\nwx.navigateBack问题 \r\nA  wx.navigateTo B \r\nB  wx.navigateTo C \r\nC怎么直接到A 释放 堆栈\r\n在 C wx.navigateBack(2)？ 用了怎么还是返回到B 。。到不了A 。如果在C页面用wx.redirectTo 返回就乱了 怎么解决答：https://mp.weixin.qq.com/debug/wxadoc/dev/api/ui-navigate.html?t=20161222#wxnavigatebackobject\r\nwx.navigateBack({delta: 2})\r\n问题十：关于success回调函数中调用this.setData方法的问题。 \r\n\r\n答：\r\n原因是你的this.setData中的this用得不对。\r\n解决方法：\r\n在你的那个函数（uploadFile）外面函数外边定义： var that=this；\r\n将你的this.setData改为 that.setData。\r\n\r\n\r\n问题十一：\r\n小程序登录发送code请求问题 \r\n\r\napi登录发送code时，一直报这个错误，对比了设置数据等，应该不是我程序问题吧。请大神们赐教下图配置里面已经都配置没问题，访问相应的接口已经有数据返回的答：处理code应该在后端进行，或者把https://api.weixin.qq.com加入到你域名列表中"}
{"title": "微信小程序：漫画小程序项目总结 ", "author": "Rolan", "pub_time": "2018-7-30 00:15", "content": "项目考察点：1、wx:for 循环的使用。 2、this.setData 内获取动态数组数据的方式。 3、难点：在有旁白内容时，点击旁白隐藏内容，点击图片不处理事件（通过自定义 data-tag 区分，用e.currentTarget.dataset 选取子节点）。 4、e.currentTarget.dataset、e.target.dataset 用法，console.log(e) 调试技巧。 5、难点：数组数据下标为动态数据时的取值方法。项目要求：1、构建 WXML 模板。 2、使用 wx:for 循环输出四个图片，每个图片包含一个 view 组件。每个 view 中又包含一个 image 组件展示图片和一个 text 组件展示漫画旁白。 3、循环结构通过 template 形成独立模板文件。 4、为 view 组件绑定事件（其它组件不做事件绑定），默认不展示旁白，当点击图片时可以查看旁白；而在有旁白内容时，点击旁白隐藏内容，点击图片不处理事件。 5、旁白内容在 WXML 里展示，需要使用 WXS 处理，把所有半角逗号 , 改为全角逗号 ，，WXS 以独立的文件存在。wx:for 循环的使用index.js：Page({  data: {    images: [{      src: '/images/dov-1.png',      text: '',      aside: false,      unique: '0'    }, {      src: '/images/dov-2.png',      text: '过年浪一浪,爆竹好,棒棒',      aside: false,      unique: '1'    }, {      src: '/images/dov-3.png',      text: '突然一个想不开,原地爆炸好心塞',      aside: false,      unique: '2'    }, {      src: '/images/dov-4.png',      text: '吓死白熊宝宝,变成熊猫大佬',      aside: false,      unique: '3'    }]  },//......})index.wxml： <import src=\"template.wxml\"/> <view class=\"container\"> <template is=\"imgItem\" data=\"{{images}}\" /> </view>由于循环结构通过 template 形成独立模板文件，因此 wxml 文件只需引入模板。{{images}} 为 js 文件data中的 images。imgItem 对应模板文件中的 name 属性。模板template：<block wx:for=\"{{images}}\" wx:for-item=\"item\" wx:for-index=\"index\" wx:key=\"unique\"></block>wx:for-item 指定当前项变量名，wx:for-index 指定数组下标变量。如果不指定 wx:for-item 和 wx:for-index，数组当前项的变量名默认为 item，默认数组的当前项的下标变量名默认为 index。（文档戳这：小程序列表渲染）因此项目中 images[index] 可以用 item 代替。template.wmxl：<wxs src=\"index.wxs\" module=\"tools\" /><template name=\"imgItem\"> <view wx:for=\"{{images}}\" wx:key=\"unique\" bind:tap=\"toggleText\" data-value=\"{{item.aside}}\" data-unique=\"{{item.unique}}\"> <image src=\"{{item.src}}\" data-tag=\"image\" /> <text class=\"{{item.aside?'textShow':'textHide'}}\" data-tag=\"text\">{{tools.commaReplace(item.text)}}</text> </view></template>项目要求通过 wxs 处理半角变全角逗号问题，引入 wxs 用法是，其中 tools 是 wxs 的名称，通过 module 定义。在{{tools.commaReplace(item.text)}}中，.commaReplace 由 wxs 定义，() 中传入 js 数据。半角变全角逗号wxs：在小程序中， 由于运行环境的差异，在 iOS 设备上小程序内的 wxs 会比 javascript 代码快 2 ~ 20 倍。index.wxs：function commaReplace(some_msg){  while (some_msg.indexOf(\",\") != -1) {//寻找每一个英文逗号，并替换     some_msg = some_msg.replace(\",\", \"，\");  }   return some_msg;}module.exports = {   commaReplace: commaReplace };使用 while 循环遍历字符串中每个字符的是否与半角逗号 , 匹配，如匹配使用 replace(\",\", \"，\") 方法替换，module.exports 输出模板数据供 wxml 调用。旁白的显示与隐藏index.js： toggleText: function (e){   console.log(e);   var tag = e.target.dataset.tag;   var index = e.currentTarget.dataset.unique;   var value = (!e.currentTarget.dataset.value);   var aside = 'images[' + index + '].aside';//设置images数组动态变量aside   console.log(value);   if (tag === 'image'){     if (!this.data.images[index].aside){       value = true;       this.setData({         [aside]: value       })     }   } else if (tag === 'text'){       value = false; this.setData({         [aside]: value       })   } }在小程序里，想要更新页面的数据，必须使用 this.setData 对数据进行更新。在知道数组下标或属性字段名称的情况下，可以这样写： this.setData({ 'images[0].aside': this.data.images[@].aside})数组数据下标为动态数据时的取值方法：项目中我采用的方式是给 aside 赋值，然后在 this.setData 中输出 [aside] 的方式。 var aside = 'images[' + index + '].aside';//设置images数组动态变量aside还有另一种更高级的写法，使用 JSON. stringify 把要设置的数据进行序列化，或者使用字符串拼接的方法拼出 json ，然后再重新JSON.parse 传给 setData： let json ='{\"images[' + index +'].aside\":'+ this .data .images[index] .aside.toString() +'}';this.setData(JSON.parse(json));console.log(e) 调试技巧：立正小歪牙e.target 触发事件的组件的一些属性值集合，e.currentTarget 则是当前组件的一些属性值集合。在不知道什么情况使用 e.currentTarget.dataset 还是 e.target.dataset 时，可以通过控制台打印 console.log(e) ，然后分别查看 .target 和 .currentTarget 来找到想要的属性值。触发 toggleText 时的 console.log(e) 打印信息."}
{"title": "多人对战游戏开发实例之《组队小鸡射击》（附源码） ", "author": "Rolan", "pub_time": "2018-7-24 00:37", "content": "前言：该游戏项目主要是基于前端引擎Cocos Creator开发，涉及后端联网的部分，则通过接入Matchvs SDK完成快速开发工作。准备工作Matchvs JavaScript SDK 下载地址Matchvs JavaScript 的Cocos Creator 插件使用手册Cocos Creator 下载地址《组队小鸡射击》玩法简介：双方通过控制各自小鸡，通过不断点击屏幕进行空中飞行射击，被击中者将消耗以爱心为单位的生命值，游戏支持四人同时实时对战。点击并拖拽以移动​实现步骤游戏实现部分可拆分为三个步骤来实现：用户登录、随机匹配和创建房间及同屏游戏。用户登录​使用Cocos Creator(以下简称CC)创建游戏登录场景​ 使用CC 拖动控件, 还原设计稿 , 依托CC的良好的工作流,使得这部分的工作可以由游戏策划或者UI设计者来完成,程序开发者只需要在场景中挂载相应的游戏逻辑脚本. 举个例子,在登录按钮挂在一个uiLogin.js的脚本完成用户登录功能.uilogin.fire新建js脚本文件选中场景任一控件添加组件,选中刚新建的脚本,在脚本的onLoad函数中给按钮添加点击监听,触发登录操作uiLogin.js​onLoad() {this.nodeDict[\"start\"].on(\"click\", this.startGame, this);},startGame() {Game.GameManager.matchVsInit();}实现this.startGame函数. 登录之前需要初始化Matchvs SDK:uiLogin.jsuiLogin.jsvar uiPanel = require(\"uiPanel\");cc.Class({extends: uiPanel,\r\nproperties: {},​onLoad() {\r\n    this._super();\r\n    this.nodeDict[\"start\"].on(\"click\", this.startGame, this);\r\n},​startGame() {\r\n    Game.GameManager.matchVsInit();\r\n}});​​Game.GameManager.jsmatchVsInit: function() {mvs.response.initResponse = this.initResponse.bind(this);\r\nmvs.response.errorResponse = this.errorResponse.bind(this);\r\n// 用户登录之后的回调\r\nmvs.response.loginResponse = this.loginResponse.bind(this); ​var result = mvs.engine.init(mvs.response, GLB.channel, GLB.platform, GLB.gameId);\r\nif (result !== 0) {\r\n    console.log('初始化失败,错误码:' + result);\r\n}}初始化需要的几个参数在Matchvs官网注册即可得到,注册地址 http://www.matchvs.comchannel: 'MatchVS',\r\nplatform: 'alpha',\r\ngameId: 201330,\r\ngameVersion: 1,\r\nappKey: '7c7b185482d8444bb98bc93c7a65daaa',\r\nsecret: 'f469fb05eee9488bb32adfd85e4ca370',注册成功后,登录Matchvs游戏云,返回UserID,登录成功.gameManager.js​registerUserResponse: function(userInfo) {var deviceId = 'abcdef';\r\nvar gatewayId = 0;\r\nGLB.userInfo = userInfo;​console.log('开始登录,用户Id:' + userInfo.id)​var result = mvs.engine.login(\r\n    userInfo.id, userInfo.token,\r\n    GLB.gameId, GLB.gameVersion,\r\n    GLB.appKey, GLB.secret,\r\n    deviceId, gatewayId\r\n);\r\nif (result !== 0) {\r\n    console.log('登录失败,错误码:' + result);\r\n}},​loginResponse: function(info) {if (info.status !== 200) {\r\n    console.log('登录失败,异步回调错误码:' + info.status);\r\n} else {\r\n    console.log('登录成功');\r\n    this.lobbyShow();\r\n}},随机匹配和创建房间使用CC创建大厅场景(uiLobbyPanel.fire)给用户选择匹配方式,创建匹配场景(uiMatching1v1.fire) 给用户反馈比配进度和登录功能的实现步骤类似:写一个 uiMatching1v1.js脚本挂在到场景中的控件上.uiMatching1v1.jsjoinRandomRoom: function() {var result = mvs.engine.joinRandomRoom(GLB.MAX_PLAYER_COUNT, '');\r\nif (result !== 0) {\r\n    console.log('进入房间失败,错误码:' + result);\r\n}},通过监听joinRoomResponse和joinRoomNotify匹配结果gameManager.jsjoinRoomResponse: function(status, roomUserInfoList, roomInfo) {if (status !== 200) {\r\n    console.log(\"失败 joinRoomResponse:\" + status);\r\n    return;\r\n}\r\nvar data = {\r\n    status: status,\r\n    roomUserInfoList: roomUserInfoList,\r\n    roomInfo: roomInfo\r\n}\r\n// 把事件发给关心这个事件的节点脚本\r\nclientEvent.dispatch(clientEvent.eventType.joinRoomResponse, data);},​joinRoomNotify: function(roomUserInfo) {var data = {\r\n    roomUserInfo: roomUserInfo\r\n}\r\nclientEvent.dispatch(clientEvent.eventType.joinRoomNotify, data);},同屏游戏 , 实现游戏同步还是按照上面的套路,新建场景(uiGamePanel.fire),在playerManager.js中,加载了player.js.在player.js中,攻击的动作使用Matchvs 的 sendEventEx发出,player.jshurt: function(murderId) {var msg = {\r\n    action: GLB.PLAYER_HURT_EVENT,\r\n    playerId: this.userId,\r\n    murderId: murderId\r\n};\r\nGame.GameManager.sendEventEx(msg);}另一方的客户端收到后处理事情;gameManager.js​// 玩家行为通知--sendEventNotify: function(info) {if (info.cpProto.indexOf(GLB.PLAYER_HURT_EVENT) >= 0) {\r\n    if (Game.GameManager.gameState !== GameState.Over) {\r\n        player = Game.PlayerManager.getPlayerByUserId(cpProto.playerId);\r\n        if (player) {\r\n            player.hurtNotify(cpProto.murderId);\r\n        }\r\n        // 检查回合结束--\r\n        var loseCamp = Game.PlayerManager.getLoseCamp();\r\n        if (loseCamp != null) {\r\n            Game.GameManager.gameState = GameState.Over\r\n            if (GLB.isRoomOwner) {\r\n                this.sendRoundOverMsg(loseCamp);\r\n            }\r\n        }\r\n    }\r\n}}​开发完成后， 再通过CC的微信小游戏一键发布功能上线微信即可。"}
{"title": "初探微信小程序 ", "author": "Rolan", "pub_time": "2019-3-18 00:07", "content": "最近的项目中，需要学生端使用微信小程序，所以这两天做了一下小程序的原型。在这里总结一下踩过的坑。组件库的选择上来遇到的第一个大问题就是组件的选择。因为微信原生的实在是又不好看，又不好用。虽然有官方文档，但不得不说，不适合新手使用。第一次选择: WeUI。这是以前老师提到过的一个组件库，所以先尝试了它。但是效果不大好。有两个问题：1.组件库不强大。虽然涉及的种类挺全面的，但是一旦想去实现某个功能时，总会有不顺手的地方。2.没有文档。WeUI本身是有较完善的文档的，但是小程序版的就没有了，所以就造成了想去实现一个功能，就只能根据他给的Demo去扒代码了。第二次选择：ZanUI。一个第三方组件库，相较上面的来说，最大的提升就是文档完善。组件方面也是种类比较齐全的。基本上可以满足开发的需求。第三次选择：VantUI。它是ZanUI的升级版本，功能上更加齐全，而且同种的功能有了更多的选择，可以适应更多变的场景。文档方面也是极其优秀的，不仅有适合新手的入门教程，最大的亮点就是可以同步展示，可以更快的找到想要的效果。最终使用了VantUI进行原型的制作，虽然过程中还是有些地方没法更设想的完全一样，但是好在还能找到替代的解决办法。总体上比较满意。返回键基本上我们看到的小程序，上面的返回键都是不可缺少的。最开始，路由跳转，使用官方给的API进行路由跳转：wx.redirectTo({\r\n    url: '/pages/personal/changePassword/changePassword'\r\n})然后就是添加返回按钮了。找到组件文档，添加个返回键：<van-nav-bar\r\n  title=\"标题\"\r\n  left-text=\"返回\"\r\n  left-arrow\r\n  bind:click-left=\"onClickLeft\"\r\n/>结果是这样的，好像还行，到是感觉有点别扭。打开微信，发现人家的样式都是只有一行的，我的就显得有点怪异。google一下，发现是我路由跳转的方法用错了。wx.navigateTo({\r\n  url: 'changePassword/changePassword'\r\n})使用这个可以直接出现返回的按钮：上面两种方法的区别是，第一个是关闭当前页面，然后跳转；后一种是保留当前页面，然后跳转。所以可以看到上面的url也有一些区别。第一个我写了完整的路径，而后一种我只写了相对路径（当然完整的也可以）。使用后面的好处，还可以利用API:wx.navigateBack实现返回，也省却了不少麻烦。界面风格在这次做原型的过程中，看了好多个别人的小程序，发现其中cell这个组件被用的很频繁。它的效果是这样的：它的大面积使用，代替了按钮的使用，所以我也借鉴了这一点，不得不说，效果确实比按钮要好。先看一下按钮实现的风格：再对比一下cell的风格：虽然按钮好像也不差，但是后面的给人感觉要更好一点。不仅如此，我还利用他解决了table的问题。因为小程序本身是没有table的，各大组件库中也没有看到，所以最后便用VantUI库中的两个组件panel和cell组合实现：<van-panel title=\"2018-2019学年第一学期\" use-footer-slot>\r\n  <view slot=\"footer\">\r\n    <van-cell-group wx:for=\"{{ scores }}\" wx:for-item=\"score\">\r\n      <van-cell title=\"{{ score.name }}\"/>\r\n      <van-cell title=\"平时成绩\" value=\"{{ score.usualScore }}\" />\r\n      <van-cell title=\"期中成绩\" value=\"{{ score.middleScore }}\" />\r\n      <van-cell title=\"期末成绩\" value=\"{{ score.finalScore }}\" />\r\n      <van-cell title=\"总评\" value=\"{{ score.totalScore }}\" />\r\n    </van-cell-group>\r\n  </view>\r\n</van-panel>实现效果如下：尽管没有达到我的预期，但是作为第一版也可以了。安利VantUI库中添加了很多图标，但如果还不能满足你的需求，可以去这里找找灵感：https://www.iconfont.cn/最后附上VantUI的地址：https://github.com/youzan/van...https://youzan.github.io/vant..."}
{"title": "Taro实践 - TOPLIFE小程序 开发体验 ", "author": "Rolan", "pub_time": "2018-7-5 00:32", "content": "前阵子，来自我们凹凸实验室的遵循React 语法规范的 多端开发方案 - Taro 终于对外开源了，欢迎围观 star （先打波广告）。作为第一批使用了 Taro 开发的TOPLIFE小程序的开发人员之一，自然是走了不少弯路，躺了不少坑，也帮忙找过不少bug。现在项目总算是上线了，那么，也是时候给大家总结分享下了。与WePY比较当初开发TOPLIFE第一期的时候，用的其实是 WePY （那时Taro还没有开发完成），然后在第二期才全面转换为用 Taro 开发。作为两个小程序开发框架都使用过，并应用在生产环境里的人，自然是要比较一下两者的异同点。相同点组件化开发npm包支持ES6+特性支持，Promise， Async Functions 等CSS预编译器支持，Sass/Stylus/PostCSS等支持使用Redux进行状态管理…..相同的地方也不用多说什么，都2018年了，这些特性的支持都是为了让小程序开发变得更现代，更工程化，重点是区别之处。不同点开发风格实现原理WePY支持slot，Taro暂不支持直接渲染children开发风格最大的不同之处，自然就是开发风格上的差异， WePY 使用的是类Vue开发风格， Taro 使用的是类React 开发风格，可以说开发体验上还是会有较大的区别。贴一下官方的demo简单阐述下。WePY demo<style lang=\"less\">\r\n    @color: #4D926F;\r\n    .userinfo {\r\n        color: @color;\r\n    }\r\n</style>\r\n<template lang=\"pug\">\r\n    view(class='container')\r\n        view(class='userinfo' @tap='tap')\r\n            mycom(:prop.sync='myprop' @fn.user='myevent')\r\n            text {{now}}\r\n</template>\r\n\r\n<script>\r\n    import wepy from 'wepy';\r\n    import mycom from '../components/mycom';\r\n\r\n    export default class Index extends wepy.page {\r\n        \r\n        components = { mycom };\r\n        data = {\r\n            myprop: {}\r\n        };\r\n        computed = {\r\n            now () { return new Date().getTime(); }\r\n        };\r\n        async onLoad() {\r\n            await sleep(3);\r\n            console.log('Hello World');\r\n        }\r\n        sleep(time) {\r\n            return new Promise((resolve, reject) => setTimeout(resolve, time * 1000));\r\n        }\r\n    }\r\n</script>Taro demoimport Taro, { Component } from '@tarojs/taro'\r\nimport { View, Button } from '@tarojs/components'\r\n\r\nexport default class Index extends Component {\r\n  constructor () {\r\n    super(...arguments)\r\n    this.state = {\r\n      title: '首页',\r\n      list: [1, 2, 3]\r\n    }\r\n  }\r\n\r\n  componentWillMount () {}\r\n\r\n  componentDidMount () {}\r\n\r\n  componentWillUpdate (nextProps, nextState) {}\r\n\r\n  componentDidUpdate (prevProps, prevState) {}\r\n\r\n  shouldComponentUpdate (nextProps, nextState) {\r\n    return true\r\n  }\r\n\r\n  add = (e) => {\r\n    // dosth\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <View className='index'>\r\n        <View className='title'>{this.state.title}</View>\r\n        <View className='content'>\r\n          {this.state.list.map(item => {\r\n            return (\r\n              <View className='item'>{item}</View>\r\n            )\r\n          })}\r\n          <Button className='add' onClick={this.add}>添加</Button>\r\n        </View>\r\n      </View>\r\n    )\r\n  }\r\n}可以见到在 WePY 里， css 、 template 、 script 都放在一个wpy文件里， template 还支持多种模板引擎语法，然后支持 computed 、 watcher 等属性，这些都是典型的Vue风格。而在 Taro 里，就是彻头彻尾的 React 风格，包括 constructor ， componentWillMount 、 componentDidMount 等各种 React 的生命周期函数，还有 return 里返回的 jsx ，熟悉 React 的人上手起来可以说是非常快了。除此之外还有一些细微的差异之处：WePY 里的模板，或者说是 wxml ，用的都是小程序里原生的组件，就是小程序文档里的各种组件；而Taro里使用的每个组件，都需要从 @tarojs/components 里引入，包括 View ， Text 等基础组件（这种做其实是为了转换多端做准备）事件处理上Taro 中，是用 click 事件代替 tap 事件WePY使用的是简写的写法@+事件；而Taro则是on+事件名称阻止冒泡上WePY用的是@+事件.stop；而Taro则是要显式地使用 e.stopPropagation()来阻止冒泡事件传参WePY可以直接在函数后面传参，如 @tap=\"click({{index}})\" ；而Taro则是使用 bind 传参，如 onClick={this.handleClick.bind(null, params)}WePY使用的是小程序原生的生命周期，并且组件有 page 和 component 的区分；Taro 则是自己实现了类似React 的生命周期，而且没有 page 和 component 的区分，都是 component总的来说，毕竟是两种不同的开发风格，自然还是会有许多大大小小的差异。在这里与当前很流行的小程序开发框架之一 WePY 进行简单对比，主要还是为了方便大家更快速地了解 Taro ，从而选择更适合自己的开发方式。实践体验Taro 官方提供的demo 是很简单的，主要是为了让大家快速上手，入门。那么，当我们要开发偏大型的项目时，应该如何使用 Taro 使得开发体验更好，开发效率更高？作为深度参与TOPLIFE小程序开发的人员之一，谈一谈我的一些实践体验及心得如何组织代码使用taro-cli生成模板是这样的├── dist                   编译结果目录\r\n├── config                 配置目录\r\n|   ├── dev.js             开发时配置\r\n|   ├── index.js           默认配置\r\n|   └── prod.js            打包时配置\r\n├── src                    源码目录\r\n|   ├── pages              页面文件目录\r\n|   |   ├── index          index页面目录\r\n|   |   |   ├── index.js   index页面逻辑\r\n|   |   |   └── index.css  index页面样式\r\n|   ├── app.css            项目总通用样式\r\n|   └── app.js             项目入口文件\r\n└── package.json假如引入了redux，例如我们的项目，目录是这样的├── dist                   编译结果目录\r\n├── config                 配置目录\r\n|   ├── dev.js             开发时配置\r\n|   ├── index.js           默认配置\r\n|   └── prod.js            打包时配置\r\n├── src                    源码目录\r\n|   ├── actions            redux里的actions\r\n|   ├── asset              图片等静态资源\r\n|   ├── components         组件文件目录\r\n|   ├── constants          存放常量的地方，例如api、一些配置项\r\n|   ├── reducers           redux里的reducers\r\n|   ├── store              redux里的store\r\n|   ├── utils              存放工具类函数\r\n|   ├── pages              页面文件目录\r\n|   |   ├── index          index页面目录\r\n|   |   |   ├── index.js   index页面逻辑\r\n|   |   |   └── index.css  index页面样式\r\n|   ├── app.css            项目总通用样式\r\n|   └── app.js             项目入口文件\r\n└── package.jsonTOPLIFE小程序整个项目大概3万行代码，数十个页面，就是按上述目录的方式组织代码的。比较重要的文件夹主要是 pages 、 components 和 actions 。pages里面是各个页面的入口文件，简单的页面就直接一个入口文件可以了，倘若页面比较复杂那么入口文件就会作为组件的聚合文件， redux 的绑定一般也是在这里进行。组件都放在 components 里面。里面的目录是这样的，假如有个 coupon 优惠券页面，在 pages 自然先有个 coupon ，作为页面入口，然后它的组件就会存放在 components/coupon 里面，就是 components 里面也会按照页面分模块，公共的组件可以建一个 components/public 文件夹，进行复用。这样的好处是页面之间 互相独立 ， 互不影响 。所以我们几个开发人员，也是按照页面的维度来进行分工，互不干扰，大大提高了我们的开发效率。actions这个文件夹也是比较重要，这里处理的是拉取数据，数据再处理的逻辑。可以说，数据处理得好，流动清晰，整个项目就成功了一半，具体可以看下面***更好地使用redux***的部分。如上，假如是 coupon 页面的 actions ，那么就会放在 actions/coupon 里面，可以再一次见到，所有的模块都是以页面的维度来区分的。除此之外， asset 文件用来存放的静态资源，如一些icon类的图片，但建议不要存放太多，毕竟程序包有限制。而 constants 则是一些存放常量的地方，例如 api 域名，配置等等。只要按照上述或类似的代码组织方式，遵循规范和约定，开发大型项目时不说能提高多少效率，至少顺手了很多。更好地使用reduxredux大家应该都不陌生，一种状态管理的库，通常会搭配一些中间件使用。我们的项目主要是用了 redux-thunk 和 redux-logger 中间件，一个用于处理异步请求，一个用于调试，追踪 actions 。数据预处理相信大家都遇到过这种时候，接口返回的数据和页面显示的数据并不是完全对应的，往往需要再做一层预处理。那么这个业务逻辑应该在哪里管理，是组件内部，还是 redux 的流程里？举个例子：例如上图的购物车模块，接口返回的数据是{\r\n\tcode: 0,\r\n\tdata: {\r\n        shopMap: {...}, // 存放购物车里商品的店铺信息的map\r\n        goods: {...}, // 购物车里的商品信息\r\n        ...\r\n\t}\r\n\t...\r\n}对的，购车里的商品店铺和商品是放在两个对象里面的，但视图要求它们要显示在一起。这时候，如果直接将返回的数据存到 store ，然后在组件内部 render 的时候东拼西凑，将两者信息匹配，再做显示的话，会显得组件内部的逻辑十分的混乱，不够纯粹。所以，我个人比较推荐的做法是，在接口返回数据之后，直接将其处理为与页面显示对应的数据，然后再 dispatch 处理后的数据，相当于做了一层拦截，像下面这样：const data = result.data // result为接口返回的数据\r\nconst cartData = handleCartData(data) // handleCartData为处理数据的函数\r\ndispatch({type: 'RECEIVE_CART', payload: cartData}) // dispatch处理过后的函数\r\n\r\n...\r\n// handleCartData处理后的数据\r\n{\r\n    commoditys: [{\r\n        shop: {...}, // 商品店铺的信息\r\n        goods: {...}, // 对应商品信息\r\n    }, ...]\r\n}可以见到，处理数据的流程在render前被拦截处理了，将对应的商品店铺和商品放在了一个对象了.这样做有几个好处一个是组件的渲染 更纯粹 ，在组件内部不用再关心如何将数据修修改改而满足视图要求， 只需关心组件本身的逻辑 ，例如点击事件，用户交互等二是数据的流动 更可控 ，假如后续后台返回的数据有变动，我们要做的只是改变 handleCartData 函数里面的逻辑，不用改动组件内部的逻辑。后台数据——>拦截处理——>期望的数据结构——>组件实际上，不只是后台数据返回的时候，其它数据结构需要变动的时候都可以做一层数据拦截，拦截的时机也可以根据业务逻辑调整，重点是要让组件内部本身不关心 数据与视图是否对应，只专注于内部交互的逻辑 ，这也很符合 React 本身的初衷，数据驱动视图。connect可以做更多的事情connect 大家都知道是用来连接 store 、 actions 和组件的，很多时候就只是根据样板代码复制一下，改改组件各自的 store 、 actions 。实际上，我们还可以做一些别的处理，例如：export default connect(({\r\n  cart,\r\n}) => ({\r\n  couponData: cart.couponData,\r\n  commoditys: cart.commoditys,\r\n  editSkuData: cart.editSkuData\r\n}), (dispatch) => ({\r\n  // ...actions绑定\r\n}))(Cart)\r\n\r\n// 组件里\r\nrender () {\r\n\tconst isShowCoupon = this.props.couponData.length !== 0\r\n    return isShowCoupon && <Coupon />\r\n}\r\n上面是很普通的一种 connect 写法，然后 render 函数根据 couponData 里是否数据来渲染。这时候，我们可以把 this.props.couponData.length !== 0 这个判断丢到 connect 里，达成一种 computed 的效果，如下：export default connect(({\r\n  cart,\r\n}) => {\r\n  const { couponData, commoditys, editSkuData  } = cart\r\n  const isShowCoupon = couponData.length !== 0\r\n  return {\r\n    isShowCoupon,\r\n    couponData,\r\n    commoditys,\r\n    editSkuData\r\n}}, (dispatch) => ({\r\n  // ...actions绑定\r\n}))(Cart)\r\n\r\n// 组件里\r\nrender () {\r\n    return this.props.isShowCoupon && <Coupon />\r\n}\r\n可以见到，在 connect 里定义了 isShowCoupon 变量，实现了根据 couponData 来进行 computed 的效果。实际上，这也是一种数据拦截处理。除了 computed ，还可以实现其它的功能，具体就由各位看官自由发挥了。项目感受要说最大的感受，就是在开发的过程中， 有时会忘记了自己在写小程序，还以为是在写React页面 。是的，有次我想给页面绑定一个滚动事件，才醒悟根本就没有 doucment.body.addEventListener 这种东西。在使用 WePY 过程中，那些奇奇怪怪的语法还是时常提醒着我这是小程序，不是h5页面，而在用 Taro 的时候，这个差异化已经被消磨得很少了。尽管还是有一定的限制，但我基本上就是用开发React的习惯来使用 Taro ，可以说极大地提高了我的开发体验。一些需要注意的地方那 Taro ，或者是小程序开发，有没有什么要注意的地方？当然有，走过的弯路可以说是非常多了。页面栈只有10层估计是每个页面的数据在小程序内部都有缓存，所以做了10层的限制。带来的问题就是假如页面存在循环跳转，即A页面可以跳到B页面，B页面也可以跳到A页面，然后用户从A进入了B，想返回A的时候，往往是直接在B页面里点击跳转到A， 而不是点返回 回到A，如此一来，10层很快就突破了。所以我们自己对 navigateTo 函数做了一层封装，防止溢出。页面内容有缓存上面说到，页面内容有缓存。所以假如某个页面是根据不同的数据渲染视图，新渲染时会有上一次渲染的缓存，导致页面看起来有个闪烁的变化，用户体验非常不好。其实解决的办法也很简单，每次在 componentWillUnmount 生命周期中清理一下当前页面的数据就好了。小程序说到底不是h5，不会说每次进入页面就会刷新，也不会离开就销毁，刷新"}
{"title": "WePY - 小程序敏捷开发实践丨掘金开发者大会 ", "author": "Rolan", "pub_time": "2018-9-20 00:14", "content": "本主题虽然在其它地方讲了很多次，但还是有非常多新内容。因为很多东西正在做或者想要做。本次分享主要分为以下几个部分：WePY 的介绍WePY 的用户上面展示的 WePY 用户不是全部的数据。因为没有办法让 WePY 用户主动上报自己在使用 WePY，所以我只列了我知道的在使用 WePY 的公司，数据比较有限。就我所知道的，最近有一个刷爆朋友圈的小程序 —— 腾讯疫苗，前端采用的 WePY，后端用了腾讯开源的 TARS 项目。微信支付内部也有大量小程序在使用 WePY 框架。右边贴的聊天记录是我在 WePY 交流群收集到的用户反馈，就反馈的内容来看，有很多感谢的话，说明 WePY 这个框架确实能帮助开发者提高自己的开发效率。嘿嘿，我没有贴 WePY 的负面反馈，因为我担心一页 PPT 不够贴 :eyes:。WePY 的数据WePY 项目在 Github 上现在有13900多个 Star。拿其它前端框架对比，Vue、React 等 Star 数可能达到了 10W+，但是它们都是国际的项目。WePY 这个项目由于微信小程序的原因，算是一个国内项目，能有13000多个 Star 还是相当不错的。Star 数多不一定代表 WePY 这个框架好，但是能表明小程序这块流量很大，开发小程序也非常有前景。 开发者们需要 WePY 这样的框架来提供帮助。这也是为什么后来出现了 Taro、mpvue 等类似的非常优秀的框架。issues 目前有1300多个。这意味着我每天起床都有超过10条 to-do list 需要处理。加上每天还有公司的其它事情需要处理，比较头大。pull requests 目前有320多条。相比其它开源项目，这个 PR 数量相当不错，非常感谢为 WePY 作贡献的开发者们。用户数有4000多。这个数据的来源我是统计的我建立的 WePY 交流群，目前这个交流群里有 4000 多人。WePY 是什么将 Web App 和小程序进行对比。Web App 和小程序在功能上类似， Web App 在开发的时候，可能使用 Vue.js 作为其核心库，用 Webpack 进行打包。在微信小程序中，大家可以简单的将 WePY 理解为 Web App 里的 Vue.js + Webpack 的合体。WePY 的特点WePY 在开发中到底帮助开发者做了什么事情呢？WePY 又有哪些特点呢？脚手架：它提供了一个相当于 vue-cli 的脚手架，一行命令生成简单的 demo 项目。用户可以基于这个 demo 进行开发，省去了启动项目前繁琐的配置。编译打包：原生开发小程序缺失了许多能力，比如 LESS、SASS。很多用户面对这个问题都是做一个简单的 Gulp 编译。WePY 自带了编译打包能力，想用 LESS、SASS、NPM 等可以直接使用 WePY 的打包工具输出小程序可以运行的代码。核心库：核心库类似 Vue、React 等。WePY 核心库包含一些简单的 API 封装帮助处理一些事情。特性与优化：开发上，WePY 提供了一些语法糖，可以简单方便的实现一些复杂功能。性能上，小程序本身的性能有一些问题，WePY 把性能上的问题抹平了，开发者不用关心性能这部分。复用与扩展：复用方面，原生小程序使用 npm 资源需要将相对应的资源下载并放到代码目录中，利用 WePY 可以直接安装 npm 包并使用。扩展方面，在编译过程中，可以随意添加和扩展编译手段，比如 LESS、SASS、编译插件等。多端：利用 WePY 可以将一份代码运行在小程序、H5 等端。WePY 的规划16年8月参加小程序内测，10月份开始着手代码转换相关的工作。在不停的迭代中，我发现还有很多事情可以做。比如可以将相关的工作抽象出来提供给其它开发者。于是在11月我对代码进行了重构，将 Gulp 编译部分抛弃重写并于 Github 开源1.1版本。开源之后有很多人关注到这个项目，说明还是有不少人遇到了相应的问题。因此我做了更加具体的优化，在1.1版本上又一次重构，把编译流程抽象，提出了编译器和插件两个概念，方便用户进行扩展。17年1月份发布1.4版本，对整个开发流程和开发者使用框架时的体验进行了更多优化，包括性能优化等。1.6 版本开始考虑多端问题：小程序一套代码多端复用。17年11月左右，小程序推出了原生组件。WePY 本身就是为了解决小程序组件的问题，原生组件发布之后，WePY 的使用场景就没有以前那么强了，所以我开始思考， WePY 需要做一个完全重构的版本。18年2月份启动了该重构版本，这个版本主要是为了解决小程序原生组件相关的问题，是一个全新的重构版本。但由于各种原因，这个版本还没有正式公布。敬请期待！WePY 的实现原理接下来我会讲一下 WePY 在技术上的实现原理。WePY 解决的问题任何一个项目都是发现问题，解决问题的过程，WePY 要解决的问题就是：组件化开发：小程序原生组件出现之前，小程序没有很好的组件化开发模式。比如我自己实现了一套 dialog，别人想使用的时候可能要把我的代码拷贝一份。实现了组件化之后，我只要把这个组件给他就好了。npm 资源：Web 发展至今，npm 库上有非常庞大的资源。但是原生小程序没有使用 npm 资源的能力，WePY 提供了这个功能。前端工程化：前面提及的打包构建部分性能优化友好的开发体验：体验优化跨平台支持：多端这部分总的来说，WePY 解决的问题就是开发中遇到的痛点问题。WePY 的架构上面是我写的两个核心的部分：CLI 以及 Core。Core 通过 CLI 编译，生成小程序端运行的代码。CLI 部分又分为 wepy、wepy-web ，分别负责 wepy 的编译和 wepy-web 的编译。其上又分为编译器和插件两部分，编译器涉及到目前主流的预处理器，类似 Webpack 的 loader 。插件是在编译之后要做的事情，类似于 Webpack 的 plugin。Core 部分分为 wepy 核心库、小程序核心库和 wepy-web 核心库。wepy-web 核心库比小程序多了 wepy components 和 wepy API 。小程序本身的一些内置组件，比如弹窗组件，想要多端运行都需要封装起来放在 wepy components 。小程序原生 API 需要通过 wepy API 封装。web 本身还分很多平台种类，比如 browser、微信 h5、QQ h5，这些都需要分别适配，所以 wepy-web 之上是一个适配层。整个 Core 之上，是用户封装的一些组件，比如上报、异步。还有一些功能组件，比如用户做的弹窗、toast、imageloader 等。纵观整个 WePY，我的代码会通过 CLI 基于 Core 输出小程序端运行的代码。WePY 的编译过程WePY 本身定义了一个文件后缀 .wpy 。编译时将该文件解析并拆分为 Style、Template、Script。拆分时，会解析并记录组件关系，包括事件、引用等。每个节点的信息都会被记录，在注入时生成到 JS 中，在 JS 中就可以知道组件关系并进行调用。生成完之后进入到 plugin，plugin 是用户自定义的，需要进行图片压缩、JS 混淆、wxml 压缩等处理。依次做完这些处理之后才会得到可以在小程序中运行的代码。以上就是 WePY 的整个编译过程。多端的实现在实现多端方面，面临着以下问题：开发模式小程序开发模式自成一派，与现有开发模式都不相同。好在使用 WePY 开发时，WePY 使用的是类 Vue 的开发语法，跟 Vue 开发模式很贴近，所以开发模式问题借助 WePY 非常好解决。标签与样式小程序与 H5 的标签不一样，但是可以直接做一些简单的转换处理。比如 <view> 转换为 <div> 。样式上小程序有一个 rpx 单位，在 750 px 的情况下直接 /2 将 rpx 转为 px。模版语法小程序有自己的模版语法，比如 <wx-if> 等，解析时可以做简单的转换。模块化小程序原生可以使用 require ,但是H5不可以。好在有很多工具值得借鉴，比如 webpack,browserify。内置组件及内置 APIWePY 本身使用的是类 Vue 的语法，要转换为 Vue 运行在 Web 端的话，内置组件直接使用 Vue 的形式编写，使用时直接引入这个 Vue 组件。内置 API 使用 WePY 提供的 JSSDK 去模拟微信端、H5等提供的 API。因此，多端实现完全可行。我们的一些项目完全利用 WePY 实现多端。生态左边是在 Github 上看到的一些 UI 库，大家在使用 WePY 开发的时候可以直接利用这些 UI 库进行二次开发。右边是网上收集到的开发资源，包括开发组件、第三方模块等。Github 上 WePY 关键字搜索结果有900多页。从用户反馈来看，用户选择 WePY 的一个原因也是 WePY 诞生的时间长，生态比较完善。WePY 的规划现有问题WePY 目前存在的核心问题是静态组件编译WePY 项目做的比较仓促，花了大概一个多月就上线了。最开始只是为了解决组件化的问题。因此它采用了静态组件编译这套方案，在编译组件时，直接将我写的组件进行静态替换，将我写的组件注入到页面中，做了一些隔离相关的事情。这导致动态 repeat 时会出现比较严重的 BUG。这是设计上的缺陷，也是急需解决的问题。语法解析xml 的解析用了一个存在问题的库，导致 xml 解析时经常出错。js 的解析设计之初没有考虑用语法树解析，而是使用正则进行解析。因为目前仅涉及解析和语法注入，实现起来都比较简单，所以没有考虑用 AST 语法树进行解析，导致用户没有按照规范写的一些代码在解析时会出现错误。类 Vue 语法从用户的反馈来看，大家更希望用 Vue 的语法而不是类 Vue 语法。这两个之间还是有一些差异的。数据绑定性能优化数据绑定时做了一些优化和处理。但这些优化和处理是通过脏数据进行的，帮助用户减少 setDate 的次数。但是后来再看，这块还是有可以优化的空间。错误处理机制目前 WePY 的错误处理还比较简单，没有一个通用的错误处理机制。用户在使用和编译时的报错很难追溯和定位。后面希望能做到在报错时可以定位到报错的文件和代码。测试用例覆盖度WePY 目前只有核心库被测试用例覆盖。CLI 部分很复杂没有做测试用例覆盖。这导致目前大部分问题都和 CLI 相关。在下一个版本要全部被测试用例覆盖。编译上图是2.0版本编译部分的对比。左边是 1.0 的编译，右边是2.0正在做的事。前面有讲到1.0的编译是把.wpy 文件放到 CLI 中进行编译。CLI 本身涉及编译器和插件。在2.0中，将文件编译修改为了入口编译，从 App 入口，通过 CLI 自动解析依赖，CLI 中也只有插件，所有的核心功能都将通过插件实现。最后生成的除了小程序文件，还有 Vendor 文件（Vendor 文件是指所有的 npm 包都会打包到这个文件内）、资源文件以及自己引用的模块的文件。插件化编译的核心部分是参考 Webpack 做的插件化编译。插件化的概念参考我上面做的图：固定一块板子，板子上有固定数量的挂钩，每个挂钩都可以挂不同的东西。每个挂钩放什么不清楚，但是每个挂钩都可以实现不同的功能。我只需要规定编译的流程，通过在挂钩中写不同的内容实现整个编译流程。所以整个编译过程变为：配置初始化:arrow_right:核心编译:arrow_right:输出文件。插件化可以提供更高的扩展性和可复用性。所有的核心功能都依赖插件进行。用户觉得某个功能不合适的时候，完全可以自己写一个插件替换掉核心功能。用户可以对编译的任何一个环节进行修改。数据绑定v1v1 的数据绑定：在初始化的时候对数据进行深拷贝做数据备份。每个流程都会预置 apply 动作，比如有一个点击事件，点击事件对数据进行修改后进入到 apply 流程，在 apply 流程中进行深比较得到脏数据，脏数据最终进入到 setDate 中。右边是比较简单易懂的图：小明对文件 B 进行修改得到 B+,老师将 B+ 和 B 进行对比，得到修改的数据。这是一个同步流程。当小明叫小红修改 C 文件时，如果老师不再，需要小红主动叫老师对 C 文件进行对比。即手动调用 apply 流程。数据绑定v22.0 使用了 Vue 的数据绑定机制。在初始化时生成 Render Watcher，每个数据初始化时都会添加 observer。修改数据时记录修改的 key-path 并加入队列中，所有的修改动作都会触发 Watcher。在一个 nextTick 时间内会清空队列，并在 Render Watcher 中进行 setDate。setDate 环节根据记录的 key-path 进行 setDate。相比小明和老师的故事：小明在修改文件时会主动记录修改的内容并发起通知，小红的操作方式与小明一致。当老师收到通知时，根据小明、小红的修改记录对修改的内容进行 setDate 的处理。这种优化方式不需要手动调用 apply,也不需要关心异步流程。质量第二个版本会先在内部项目运用，内部实践之后没有问题再开源。另外2.0版本测试用例覆盖度要完全覆盖。开源经验分享规范如何保证开源项目的质量？第一是文档规范。Readme 部分要言简意赅的讲明这个项目能做什么，一个简单的示例说明如何启动项目。Readme 要简洁，大家一眼能看到他想要的东西。第二是 CI。将对应的状态放在 Readme，让开发者可以更安心的使用这个项目。第三是 license。还有 contributer 文档，代码规范、Git 规范等。测试使用了 Mocha 和 Istanbul，集成使用了 TravisCI，部署使用了 npm 和 lerna。推广运营推广运营方面主要靠自己发文章，做外链。另外我在公众号和微信群推了自己的文章。微信群做了一个机器人放入群码。还做了文档监控，官方文档修改之后，我可以第一时间知道官方文档都修改了什么。以及监控报告，每天都会给我的微信推送今天项目有多少 star 、多少 issue 。"}
{"title": "小程序的拖拽、缩放和旋转手势 ", "author": "Rolan", "pub_time": "2018-7-30 14:40", "content": "在开发中，有时会遇到像App中的手势那样的效果，下面就仿照App实现了一下。 wxml部分：<view class=\"touch-container\">  <view class=\"msg\">{{msg}}</view>  <image    class=\"img\"    src=\"{{src}}\"    style=\"width: {{width}}rpx; height: {{height}}rpx; left: {{left}}rpx; top: {{top}}rpx; transform: translate(-50%, -50%) scale({{ scale }}) rotate({{ rotate }}deg);\"    bindload=\"bindload\"    catchtouchstart=\"touchstart\"    catchtouchmove=\"touchmove\"    catchtouchend=\"touchend\"  ></image></view>wxss部分：page {  width: 100%;  height: 100%;  background: #ffffff;}.touch-container {  width: 100%;  height: 100%;  padding-top: 0.1px;}.msg {  width: 100%;  height: 60rpx;  line-height: 60rpx;  text-align: center;  font-size: 30rpx;  color: #666666;}.img {  position: absolute;  width: 690rpx;  height: 300rpx;  transform-origin: center center;}js部分：var canOnePointMove = falsevar onePoint = {  x: 0,  y: 0}var twoPoint = {  x1: 0,  y1: 0,  x2: 0,  y2: 0}Page({  data: {    msg: '',    src: 'http://img01.taopic.com/150508/318763-15050PU9398.jpg',    width: 0,    height: 0,    left: 375,    top: 600,    scale: 1,    rotate: 0  },  // 关闭上拉加载  onReachBottom: function() {    return  },  bindload: function(e) {    var that = this    var width = e.detail.width    var height = e.detail.height    if (width > 750) {      height = 750 * height / width      width = 750    }    if (height > 1200) {      width = 1200 * width / height      height = 1200    }    that.setData({      width: width,      height: height    })  },  touchstart: function(e) {    var that = this    if (e.touches.length < 2) {      canOnePointMove = true      onePoint.x = e.touches[0].pageX * 2      onePoint.y = e.touches[0].pageY * 2    }else {      twoPoint.x1 = e.touches[0].pageX * 2      twoPoint.y1 = e.touches[0].pageY * 2      twoPoint.x2 = e.touches[1].pageX * 2      twoPoint.y2 = e.touches[1].pageY * 2    }  },  touchmove: function(e){    var that = this    if (e.touches.length < 2 && canOnePointMove) {      var onePointDiffX = e.touches[0].pageX * 2 - onePoint.x      var onePointDiffY = e.touches[0].pageY * 2 - onePoint.y      that.setData({        msg: '单点移动',        left: that.data.left + onePointDiffX,        top: that.data.top + onePointDiffY      })      onePoint.x = e.touches[0].pageX * 2      onePoint.y = e.touches[0].pageY * 2    }else if (e.touches.length > 1) {      var preTwoPoint = JSON.parse(JSON.stringify(twoPoint))      twoPoint.x1 = e.touches[0].pageX * 2      twoPoint.y1 = e.touches[0].pageY * 2      twoPoint.x2 = e.touches[1].pageX * 2      twoPoint.y2 = e.touches[1].pageY * 2      // 计算角度，旋转(优先)      var perAngle = Math.atan((preTwoPoint.y1 - preTwoPoint.y2)/(preTwoPoint.x1 - preTwoPoint.x2))*180/Math.PI      var curAngle = Math.atan((twoPoint.y1 - twoPoint.y2)/(twoPoint.x1 - twoPoint.x2))*180/Math.PI      if (Math.abs(perAngle - curAngle) > 1) {        that.setData({          msg: '旋转',          rotate: that.data.rotate + (curAngle - perAngle)        })      }else {        // 计算距离，缩放        var preDistance = Math.sqrt(Math.pow((preTwoPoint.x1 - preTwoPoint.x2), 2) + Math.pow((preTwoPoint.y1 - preTwoPoint.y2), 2))        var curDistance = Math.sqrt(Math.pow((twoPoint.x1 - twoPoint.x2), 2) + Math.pow((twoPoint.y1 - twoPoint.y2), 2))        that.setData({          msg: '缩放',          scale: that.data.scale + (curDistance - preDistance) * 0.005        })      }    }  },  touchend: function(e) {    var that = this    canOnePointMove = false  }})json部分：\"navigationBarTitleText\": \"识别手势\",  \"navigationBarTextStyle\":\"black\",  \"navigationBarBackgroundColor\": \"#FFF\",  \"disableScroll\": true"}
{"title": "小程序官方客服支持手机端登录了？ ", "author": "Rolan", "pub_time": "2019-3-19 00:09", "content": "相信大家用过小程序客服的同学，都有一个希望，希望官方早日支持小程序客服的手机端。之前一直听说此功能在开发阶段，今天在小程序开发群里，有群友分享了一个小程序：客服小助手。然后，我赶紧去体验了一下，写一篇使用心得~一、用户体系(客服小助手)客服小助手，毕竟是微信官方的产品，可以直接用微信体系，授权即可使用。优点：1、用户一旦接收服务通知，就可以无限接收模板消息（下方有配图），能拿服务通知内测资格的小程序也并不多;2、官方后续也许会优化此产品，提供更多实用功能;3、消息是需要手动接收，不是自动分配，这和PC上的玩儿法基本一致。(可以无限接收客服消息)二、在线状态 & 转接 有待优化目前有“在线”和“离线”状态，已经能满足大部分需求，要是能再添加一个“隐身”状态会更好。有时候，你只想看消息，并不想回复，所以，有必要添加一个“隐身”状态，当客服想回复消息时，支持手动接入消息即可。消息一旦接入，没办法“转接”给其他客服同事，也没有找到“结束对话”的功能。（知你客服的截图）三、接收消息在电脑上使用小程序，有一个很痛苦的问题，一个浏览器只能接收一个小程序的客服消息，想接入其他小程序的客服消息，只能换个浏览器，真的很不爽~然而，客服小助手也并没有解决这个问题，一个窗口依然只能接收单个小程序的消息，需要手动切换“服务的小程序”，微信官方真的就不打算改一下这个设计吗？可能我们是极少数做了N多小程序的公司，其他公司都只做一款小程序，我只能这样理解了。四、快捷回复客服小助手中做了快捷回复功能，目前的版本有点儿粗糙，先截图来感受一下。这个快捷回复，有待优化：1、目前只支持10条，感觉太少了，至少我们小程序中不止配置了10条；2、不支持图文并茂形式，或者图片形式的回复；3、没有标题，如果内容过长，不太好区分；(知你客服截图)欢迎留言讨论..."}
{"title": "你的年目标实现了吗，记一次开发微信小程序 ", "author": "Rolan", "pub_time": "2019-1-2 00:12", "content": "前言：这是笔者第一次开发小程序，此前一直有打算自己做一个，并且能够上线使用，但一直找不到灵感，加上还需要服务器端、数据库等技能，所有一直没能实现。后来偶然看到微信小程序云开发(有点惊艳了，确实挺简便)，再加上一点点想法，于是就开始了小程序云开发之旅。第一步，要做什么东西？鉴于自己的技术水平(捂脸)，还有看到年末很多人都在分享年目标，于是便决定好做一个年目标备忘录，简单方便，且有一些意义。第二步，思考小程序的结构实际开发中，往往需要产品相关的思维导图、原型图等来指导开发，即使做一个小项目，我认为也需要一个良好的构思，以下是小程序的思维导图：第三步，开发阶段以下列举主要页面首页首页实现的功能：通过云函数获取当前用户的openid，并查询用户的今年目标；查询链接附带的id，获取其他用户分享后的目标内容；部分代码如下：// 调用云函数\r\n wx.cloud.callFunction({\r\n  name: 'login',\r\n  data: {},\r\n  success: res => {\r\n    console.log('[云函数] [login] user openid: ', res.result.openid)\r\n    app.globalData.openid = res.result.openid;\r\n    if(!id){\r\n      this.getData();\r\n    }\r\n  },\r\n  fail: err => {\r\n    console.error('[云函数] [login] 调用失败', err)\r\n  }\r\n})\r\n //查询数据库\r\n const db = wx.cloud.database();\r\n db.collection(\"targets\").where({\r\n  _openid: app.globalData.openid,\r\n  date: new Date().getFullYear()\r\n}).get({\r\n  success: res => {\r\n    let data = res.data[0] || {};\r\n\r\n    this.setData({\r\n      id: data._id || '',\r\n      title: data.title || '',\r\n      content: data.content || '',\r\n      flag: false\r\n    })\r\n  }, fail: err => {\r\n    console.log(err)\r\n    this.setData({\r\n      flag: false\r\n    })\r\n  }\r\n})\r\n复制代码列表页列表实现的功能：展示所有该用户添加的目标；左滑可删除，并且增加目标详情、编辑、添加入口；部分代码如下：//获取所有目标\r\nconst db = wx.cloud.database();\r\ndb.collection(\"targets\").where({\r\n  _openid: app.globalData.openid\r\n}).get({\r\n  success: res => {\r\n    this.setData({\r\n      flag: true,\r\n      targetList: res.data, height: height\r\n    })\r\n    app.globalData.targetList = res.data;\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      icon: \"none\",\r\n      title: '查询记录失败',\r\n    })\r\n  }\r\n})\r\n//响应删除\r\nlet id = e.currentTarget.id;\r\nconst db = wx.cloud.database();\r\n\r\ndb.collection(\"targets\").doc(id).remove({\r\n  success: res => {\r\n    wx.showToast({\r\n      title: '删除成功',\r\n    })\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      title: '删除失败',\r\n    })\r\n  }\r\n})\r\n复制代码添加目标添加目标实现的功能：通过picker组件让用户选取年份；可添加/编辑年目标标题、内容；部分代码如下：//新增数据\r\ndb.collection(\"targets\").add({\r\n  data: data,\r\n  success: res => {\r\n    wx.showToast({\r\n      title: '新增成功',\r\n    })\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      title: '新增失败',\r\n      icon: 'none'\r\n    })\r\n  }\r\n})\r\n//编辑数据\r\ndb.collection(\"targets\").doc(data.id).update({\r\n  data: data,\r\n  success: res => {\r\n    wx.showToast({\r\n      title: '修改成功',\r\n    })\r\n  }, fail: err => {\r\n    wx.showToast({\r\n      title: '修改失败',\r\n    })\r\n  }\r\n})\r\n复制代码第四步，最终结果小程序从开发到发布成功，只花了一周时间，不得不赞扬云开发给开发者带来的便利，并且还是免费的，为了表达出开发的顺畅，我特意百度了一张图来体现希望没有想歪哈，这是一张纯粹的过山车图(>▽<)因时间、技术或者环境限制，一些还没有解决的问题：分享到朋友圈功能还没有实现，后续将实现保存当前页为图片，让用户手动分享;使用了textarea标签给用户添加数据，有些简陋，希望小程序尽快出富文本编辑器;虽然工作中经常接触设计图，但对ui设计还是有些无感，以后尽量弥补设计上的不足;小程序云开发数据响应有一些缓慢，据称云开发目前只部署在上海，期待后续优化;最后附上小程序码，微信扫码即可体验(或搜索我的年目标)。另外，祝愿大家都能开发出自己的小程序，并且在新的一年实现自己的人生目标^_^该小程序的github地址： 我的年目标参考文档/文章：微信小程序云开发文档微信小程序开发平台新功能「云开发」快速上手体验微信小程序实现左滑删除-一切没有那么简单微信小程序之云开发——模拟后台增删改查"}
{"title": "一诞小程序总结 ", "author": "Rolan", "pub_time": "2019-1-2 14:48", "content": "介绍一诞是一款基于腾讯云的人脸识别、五官定位的圣诞主题小程序。开始做它的初衷是为了简化用户操作，与其他手动添加帽子的小程序形成差别，所见即所得。但是在开发的适合遇到了一些问题，没有完美的方案来根据五官定位API返回的坐标点来准确的给人物戴上帽子。最后无奈之下就加入了圣诞贺卡的功能，弱化了生成头像的功能。小程序全部功能使用云开发，大大减少了一个人的工作量。贺卡功能介绍贺卡是我在初中、小学的时候，圣诞最常送的礼物。小程序的转发恰好是赠送贺卡的最好入口，再加上一些抖音的模式。每个用户转发赠送的贺卡内容都会上传（这里忘记征求用户同意），在主页就可以使用摇一摇的方式来查看下一条贺卡内容，并且可以点赞。五官定位戴帽子五官定位使用的是腾讯云的API，它可以返回五官的坐标，了解更多。这里使用云函数可以快速的拿到返回参数，将坐标点绘制在画布上。安装依赖1npm i --save image-node-sdk云函数调用五官定位API12345678910111213141516171819202122232425// 云函数入口文件const cloud = require('wx-server-sdk')const {ImageClient} = require('image-node-sdk');let AppId = ''; // 腾讯云 AppIdlet SecretId = ''; // 腾讯云 SecretIdlet SecretKey = ''; // 腾讯云 SecretKeyconst imgClient = new ImageClient({  AppId,  SecretId,  SecretKey});cloud.init()// 云函数入口函数exports.main = async(event, context) => {  const url = event.url;  const result = await imgClient.faceShape({    data: {      appid: AppId,      mode: 1,      url,    },  });  return JSON.parse(result.body);}接下来就是根据坐标来准确戴帽子了，但是我能力有限，没有一套比较好的方案，只有在正脸情况下能够准确戴上帽子。帽子也是根据坐标点画出来的，非提前画好的图。如果你有好的想法欢迎联系我（WeChat：tysb7_)总结这款小程序初衷是为了学习使用腾讯云人脸识别API，定位是为了蹭热度。但是时间、推广和能力的原因没能打造成一个爆款。不过在从中收获了许多东西，源码已经上传至GitHub，欢迎大家一起来维护。GitHub: 本文项目仓库WeChat: tysb7_blog: www.tysb7.cnEmail: terry@qiaokr.comSSl: 环洋诚信™"}
{"title": "微信小程序兼容性问题 ", "author": "Rolan", "pub_time": "2018-8-16 00:23", "content": "在微信小程序开发中，经常会遇到一些兼容性的问题，我最近就遇到了一个问题，就是在时间字符串转化为时间戳的方法中，我用的Date.parse(new Date())这个方法，但是在微信开发者工具中这个方法正常实现，但是在一些iphone设备和安卓的部分设备中不会实现相关功能，为了解决这个问题我只能导入了momentjs，不在调用系统方法了。这里我们就来讨论一下一些兼容性问题。运行环境差异微信小程序运行在三端：iOS、Android 和 用于调试的开发者工具。三端的脚本执行环境以及用于渲染非原生组件的环境是各不相同的：在 iOS 上，小程序的 javascript 代码是运行在 JavaScriptCore 中，是由 WKWebView 来渲染的，环境有 iOS8以上 在 Android 上，小程序的 javascript 代码是通过 X5 JSCore来解析，是由 X5 基于 Mobile Chrome 53/57 内核来渲染的 在 开发工具上， 小程序的 javascript 代码是运行在 nwjs 中，是由 Chrome Webview 来渲染的 尽管三端的环境是十分相似的，但是还是有些许区别：ES6 语法支持不一致 语法上开发者可以通过开启 ES6 转 ES5 的功能来规避。wxss 渲染表现不一致 尽管可以通过开启样式补全来规避大部分的问题，还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现。ES6 转 ES5在 0.10.101000 以及之后版本的开发工具中，会默认使用 babel 将开发者 ES6 语法代码转换为三端都能很好支持的 ES5 的代码，帮助开发者解决环境不同所带来的开发问题。 样式补全开启此选项，开发工具会自动检测并补全缺失样式，保证在低版本系统上的正常显示。尽管可以规避大部分的问题 ，还是建议开发者需要在 iOS 和 Android 上分别检查小程序的真实表现。样式补全兼容小程序的功能不断的增加，但是旧版本的微信客户端并不支持新功能，所以在使用这些新能力的时候需要做兼容。文档会在组件，API等页面描述中带上各个功能所支持的版本号。可以通过 wx.getSystemInfo 或者 wx.getSystemInfoSync 获取到小程序的基础库版本号。可以通过 wx.canIUse 来判断是否可以在该基础库版本下直接使用对应的API或者组件获取系统信息同步let res = wx.getSystemInfoSync() console.log(\"同步获取系统信息：\" + res);  console.log(res);异步：wx.getSystemInfo({      success: function(res) {        console.log(\"异步获取系统信息:\");        console.log(res);      },    })版本比较微信客户端和小程序基础库的版本号风格为 Major.Minor.Patch（主版本号.次版本号.修订号）。 开发者可以根据版本号去做兼容function compareVersion(v1, v2) {  v1 = v1.split('.')  v2 = v2.split('.')  var len = Math.max(v1.length, v2.length)  while (v1.length < len) {    v1.push('0')  }  while (v2.length < len) {    v2.push('0')  }  for (var i = 0; i < len; i++) {    var num1 = parseInt(v1[i])    var num2 = parseInt(v2[i])    if (num1 > num2) {      return 1    } else if (num1 < num2) {      return -1    }  }  return 0}compareVersion('1.11.0', '1.9.9')// 1该基础库版本下直接使用对应的API或者组件的APIwx.canIUse(String)判断小程序的API，回调，参数，组件等是否在当前版本可用。此接口从基础库 1.1.1 版本开始支持。String参数说明： 使用{API}.{method}.{param}.{options}或者{component}.{attribute}.{option}方式来调用，例如：{API} 代表 API 名字 {method} 代表调用方式，有效值为return, success, object, callback {param} 代表参数或者返回值 {options} 代表参数的可选值 {component} 代表组件名字 {attribute} 代表组件属性 {option} 代表组件属性的可选值例子：wx.canIUse('openBluetoothAdapter')wx.canIUse('getSystemInfoSync.return.screenWidth')wx.canIUse('getSystemInfo.success.screenWidth')wx.canIUse('showToast.object.image')wx.canIUse('onCompassChange.callback.direction')wx.canIUse('request.object.method.GET')wx.canIUse('live-player')wx.canIUse('text.selectable')wx.canIUse('button.open-type.contact')Javascript 标准库兼容性问题微信小程序的兼容性问题除了微信本身的 Bug 外，大部分是目标平台对 JavaScript 标准库支持程度不同造成的。像我最上面遇到的问题就是Javascript 标准库兼容性问题。对于这类问题我们可以打补丁，从其他地方找到比较完善的js代码，然后我们拷贝到我们的项目中。作者：辉哥de简书 链接：https://www.jianshu.com/p/0eabd560b5a8"}
{"title": "微信小程序语音录制和播放的一些坑，ios 和 android 的 布局兼容问题 ... ", "author": "天下雪", "pub_time": "2017-4-25 00:10", "content": "一：语音录制和播放的一些坑分享者：罗道义，原文地址 年前，公司开发了微信小程序，我负责后端开发，其中遇到一些坑，分享一下 小程序语音录制和播放微信录音不能计时，需要自己计时录音文件是微信独有格式，只能微信本身播放，否则需要工具转换为Mp3等通用格式才可以录音播放不能直接用标签src引入，需要将语音文件下载到本地后才可以正常播放。录音播放没有播放完成的事件，需要自己计时小程序视频录制和播放视频录制很费空间视频需要压缩再上传，否则会很卡，或者上传失败又拍云的视频处理文档是狗屎,直接问客服，否则处理回调不会成功 目前就这些，想到了再写二：ios 和 android 的 布局兼容问题最近在研究小程序，写了一个简单的展示页面。在微信开发者工具上面调试一切正常，在真机上面测试的时候问题就来了。 在iOS 上面 布局出现混乱，查找原因是因为display：flex；标签和属性的部分问题，在Android 真机测试 是没有问题的。原因未果。于是换掉了flex布局 完美兼容。。。"}
{"title": "微信小程序开发之IOS/Android兼容坑 ", "author": "Rolan", "pub_time": "2017-9-20 00:39", "content": "一、时间转换问题：这不只是小程序上面的问题是ios系统 都有这个问题就是new  Date(\"2017-06-16\") 在IOS会出现NAN的情况所以对于时间转换需要另行封装，解决方案如下1.替换”-“为”/“2.删除”.“后面的字符串（带毫秒也会有问题）代码如下： /**\r\n     * 字符串转换为时间\r\n     * @param  {String} src 字符串\r\n     */\r\n    strToDate(dateObj){\r\n      dateObj = dateObj.replace(/T/g, ' ').replace(/\\.[\\d]{3}Z/, '').replace(/(-)/g, '/')\r\n      dateObj = dateObj.slice(0, dateObj.indexOf(\".\"))\r\n     return new Date(dateObj)\r\n    } 二、fixed定位问题整个页面的fixed定位，在ios下下拉会触发下拉事件，但是没有动画效果。Android就能正常运行flex中使用 绝对定位，ios出现严重错位，导致父级元素也会变成绝对定位，Android能达到理想效果总而言之 尽量不用fixed三、absolute定位问题1.使用absolute定位，并且宽带设置了100% 并且设置了padding就会导致屏幕宽度溢出，出现页面左右可以移动的bug，模拟器上是没有问题，但是真机上是有这个问题的。这个问题让我调试并痛苦了许久2.使用absolute并且当前元素是flex容器这种情况在Ios下面布局不会起到左右，会出现所有元素转换成了absloute并且文字错位3.总而言之 尽量不用 absolute四、 word-spacing在button中的问题有时候在使用大按钮的时候两个字中间希望有段间距，但是目前没有找到能使用的占位符，所以使用了的word-spacing加空格 这个方法来设置文字的间距，但是在iPhone6s 上两个字中间一个空格的时候整体会向右偏，必须设置两个空格才正常！"}
{"title": "【微信小程序】编译 .wxss 文件异常解决 ", "author": "Rolan", "pub_time": "2018-6-29 00:21", "content": "遇到问题　　博主最近又重新开始捡起微信小程序，想做点自己的东西。了解到最近小程序工具有做更新，就顺手更新了最新的版本，功能确实比之前强大了不少！　　更新归更新，更新后控制台就一直报下面这个错误：解决方案　1 在控制台输入命令 openVendor()，回车执行　2 在打开的目录当中删除名为 wcsc.exe 的应用程序　3 重启微信小程序，错误已经不存在，程序正常执行"}
{"title": "微信小程序之onLaunch与onload异步问题 ", "author": "Rolan", "pub_time": "2019-3-29 00:19", "content": "目录导航：\r\n\r\n所述问题：\r\n解决方法：\r\n方法实现：\r\n\r\nApp.js方法实现：\r\nindex.js实现：\r\n总结：\r\n \r\n \r\n所述问题：\r\n　　 \r\n前端时间开发了一个微信小程序商城项目，因为这个项目我们的需求是进入小程序就通过wx.login({}) \r\n这个api进行用户登录，获取系统后台的用户基本信息。再此之前，一直以为微信小程序中的App.js 中onLaunch \r\n（小程序初始化完成执行该方法）方法比其他页面的的 onload \r\n方法要先执行。那么问题就来了，我每次进入小程序首页的时候有时候会先执行onlaunch方法，有时又会先执行首页的onload的方法，最后经过确定，在微信小程序中这两个方法并没有执行先后的顺序，因为他们都是异步执行的。当然开发过微信小程序的开发者都知道微信请求数据都是异步执行的，如在同一个onload写两个请求数据的方法，它不一定会按照先后顺序去执行，这就是传说中的异步地狱了。\r\n解决方法：\r\n　　当然，我既然知道这个执行顺序是由于微信小程序的异步执行请求原因导致的。我们可以使用Promise \r\n来解决异步编程问题啦。我的解决方法是，首先我是在app.js \r\n中定义了一个全局方法，用来登录小程序请求用户信息的接口，每次进入首页的时候先判断我是否已有用户信息缓存，假如不存在那么请求app.js中的全局方法进行数据获取。在这里我就不详细介绍Promise \r\n的基本用法了，因为阮一峰已经将的非常详细了，大家可以点击查看【http://es6.ruanyifeng.com/#docs/promise#Promise-all】。\r\n方法实现：\r\nApp.js方法实现：\r\n\r\nApp({\r\nonLaunch: function() {\r\nconsole.log('App Launch')\r\n//不在这里默认请求\r\n},\r\n/**\r\n* 定义全局变量\r\n*/\r\nglobalData: {\r\nopenid: '', //用户openid\r\nuserId: '', //用户编号\r\n},\r\n/**\r\n* 用户登录请求封装(解决onlaunch和onload执行顺序问题)\r\n*/\r\nuserLogin: function() {\r\nvar that = this;\r\n//定义promise方法\r\nreturn new Promise(function(resolve, reject) {\r\n// 调用登录接口\r\nwx.login({\r\nsuccess: function(res) {\r\nif (res.code) {\r\nconsole.log(\"用户登录授权code为：\" + res.code);\r\n//调用wx.request请求传递code凭证换取用户openid，并获取后台用户信息\r\nwx.request({\r\nurl: 'https://www.xxxx.xxx.api', // 后台请求用户信息方法【注意，此处必须为https数字加密证书】\r\ndata: {\r\ncode: res.code //code凭证\r\n},\r\nheader: {\r\n'content-type': 'application/json' // 默认值\r\n},\r\nsuccess(res) {\r\nconsole.log(res.data)\r\nif (res.data.errcode == 0) {\r\n//获取用户信息成功\r\nthat.globalData.openid = res.data.openid;\r\nthat.globalData.userId = res.data.UserId;\r\n//存入session缓存中\r\nwx.setStorageSync(\"userId\", that.globalData.userId)\r\nconsole.log(that.globalData.userId);\r\nconsole.log(that.globalData.openid);\r\n//promise机制放回成功数据\r\nresolve(res.data);\r\n} else {\r\nreject('error');\r\n}\r\n},\r\nfail: function(res) {\r\nreject(res);\r\nwx.showToast({\r\ntitle: '系统错误'\r\n})\r\n },\r\ncomplete: () => {\r\n\r\n} //complete接口执行后的回调函数，无论成功失败都会调用\r\n})\r\n} else {\r\nreject(\"error\");\r\n}\r\n}\r\n})\r\n})\r\n}});\r\n\r\nindex.js实现：\r\n\r\nconst app=getApp();//初始化app.js\r\npage({\r\n\r\nonLoad: function (option) {\r\nvar that = this;\r\nlet UserId = wx.getStorageSync(\"userId\");\r\nconsole.log(\"进入首页的用户编号为：\" + UserId);\r\nif (UserId == '') {\r\napp.userLogin().then(res => {\r\nconsole.log(\"promise回调后的数据：\");\r\nconsole.log(res);\r\nif (res.errcode == 0) {\r\n//把首页需要请求的数据接口都提取到一个自定义方法中\r\nthat.GetData();\r\n}\r\n})\r\n}\r\nelse\r\n{\r\n//用户缓存存在\r\nthat.GetData();\r\n}\r\n\r\n}\r\n,\r\nGetData()\r\n{\r\n//需要用到用户编号换取商品信息的接口\r\n\r\n}\r\n})\r\n\r\n \r\n总结：\r\n　　当然解决异步回调的方法有很多种，不过我在这里只说我认为好用的一种，大家有什么想法也可以一起分享学习。"}
{"title": "谈谈小程序，阿里和腾讯如何做好“新升级” ", "author": "Rolan", "pub_time": "2019-4-8 00:01", "content": "笔者告诉我们：由于开发、运维成本过高，商家纷纷寻找更好的方法代替做APP。小程序开始成为商家做数据化运营的不二选择，笔者以阿里与腾讯为例，聊聊他们是如何做小程序的。一、APP的不足趣头条创始人谭思亮曾经这样谈起他对移动互联网的思考：“从 PC 到移动时代，互联网本质在变化。最核心的原因在于： PC 是一个无限链接的时代，任何东西都可以链接，这才是互联网的本质。但移动时代其实是一个个孤岛，中间没法自由跳转，APP下载加了一道流程，转换效率就差了很多，这导致它就不是自由链接的生态。”从 Web 到APP，技术的演进，反而让服务与服务之间形成了孤岛：从下载、填写账户名、输入验证码、注册、输入密码、绑卡直到实名认证，每一步都是损耗。移动互联网时代的一个特色词汇：转化率，形容的就是这样一个漏斗状过程。APP并不是线下实体商业进行数字化运营的好载体：开发成本之高，时间之长，运维费用之贵，获客之难，业界都深有体会。一位创业者曾经给我算了一笔账：即使找最便宜的外包来开发，产出最粗糙的版本，也需要 1-2 个月，费用大约是 70-90 万。如果算上运营维护和后续迭代，一年下来成本不低于百万。即便对于大品牌，这也是一种不可承受之重。和业内人士交流时我得知：武汉的周黑鸭，光 IT 团队就有数百人之巨，从事门店管理系统、官网的开发。这样的人力配置，一年成本以千万计，代价不菲。但周黑鸭的数字化做得有多好，恐怕还要打上一个问号。跨国公司星巴克有实力开发了自己的APP，同样也面临会员体系难以数字化、服务半径有限和周边衍生品售卖的难题。强令门店搜集顾客身份信息，强行搭售、推销，不仅店员工作压力大，顾客也会反感。星巴克迫切地想通过数字化去了解自己的客户，去触达自己的客户，但不依靠外力来驱动数字化，几乎也无法推进。这是数字时代，小到街边店，中到周黑鸭，大到星巴克所共同面临的新难题。针对线下企业面临的普遍问题，此前互联网公司的各类能力输出，在逻辑上是可以解决线下企业难题的，但在实践上，此前解决得并不好。配送是单独的配送APP，申请备货周转资金是专门的信贷APP，移动支付又是单独的硬件和系统，员工的门店管理又是一套体系。商家越想数字化运营，就越需要购买多个系统进行管理，系统之间数据并不能互通，需要人工进行汇总、对账，运营负担依然很大。这实际上是工具使用门槛过高、工具之间不互通引发的孤岛效应，给商家制造了一种折磨：重复开发，多端不同步。这是值得互联网公司吸取的教训，长期以来，互联网公司不同事业部基于不同的APP为商家服务，KPI 也是基于单一APP的数据表现来评定，而非基于商户真实需求来倒推出业务形态。二、以力出一孔摆脱孤岛效应实际上，商家想要的是调取不同能力，而非开发不同的APP、去不同平台运营。中小商家实力较弱，针对这个群体的数字化，必须是系统工程，包含着进销存、物流、资金、人员等多方面能力加持，而非提供单一工具。越是长尾商家，越需要跨APP的能力摄取。让一个APP里的功能，根据场景需要内嵌在另一个APP里，实现“你中有我，我中有你”效果的最佳载体，就是小程序。还是以星巴克为例：通过小程序，星巴克能实现多端获客、运营，开发人员对中后端的更新迭代，也可以迅速同步到多个前端。实际上大大降低了开发难度，也打通了运营体系。而对用户来说：从支付宝、淘宝等任一前端进入星巴克小程序，同样可以调取多个阿里系 BU 的能力。比如：扫码支付，比如授权支付宝的身份信息作为会员信息，还能获得饿了么配送。不仅如此，用户还可直接在支付宝小程序里点击周边衍生品的链接完成购买，在此过程中能直接使用天猫购物券，而无需跳转至天猫，物流配送也依然能在小程序里无缝完成。我在之前很多稿子里谈过：to B 服务需要的是集团军作战，需要举全公司之力来提供系统性的解决方案。如果一家巨头的不同业务线搞内部竞争、赛马机制，都分头去找政府部门、B 端企业谈合作，各自提供单一场景下的单一工具，只怕客户们会一头雾水：“昨天就来了一拨人谈合作，今天你们公司又来了一拨，我到底该跟谁谈？”春秋时期，管子在《管子 · 国蓄第七十三》中提到：“利出于一孔者，其国无敌；出二孔者，其兵不诎；出三孔者，不可以举兵；出四孔者，其国必亡。”用户和 B 端都需要对抗APP孤岛效应的集成式系统，这意味着互联网公司的所有部门要形成合力，打破部门墙，力出一孔，所谓的“一孔”，在今天，其实就是小程序。基于这样的案例，这也是为什么我认为力出一孔的小程序，是当下 to B 服务尤其是 to 线下服务最好的互联网载体。高调宣布转向产业互联网的腾讯也把小程序视为突破口：今年的微信公开课，过半议题都与小程序有关，张小龙也屡次为小程序站台。据 36 氪统计：2018 年小程序相关融资金额预计超过 70 亿元，这是一个谁也无法忽视的风口。小程序成了 A 和 T 共同为 to B 寻找突破口的新药方。因为，对于 B 端来说，小程序开发成本低；而对于 C 端用户来说无需下载，即走即用，天然适合线下大量的及时性场景需求。这样说来可能有些抽象，不妨举个例子：在城市里停车位紧张，一车挡住另一车是司空见惯的场面。如果 B 有挪车需求，在以往，会拨通 A 留在挡风玻璃处的电话号码，但这容易泄露隐私。今天，挪车码就解决了这一问题：B 打开已有的APP,比如支付宝一扫，就能联系到停车方 A。在扫挪车码过程中，支付宝提供的是基于阿里云虚拟小号的防号码泄露能力。但我没想到的是：这种颗粒度极细的需求也能借助支付宝小程序长成生态。在支付宝上，码上挪车这样一款第三方开发的小程序，一年时间就收获了超 300 万用户，并依靠挪车码的入口衍生出了违章查询、罚单缴费、年检代办、二手车估价等更多车主服务。通过小程序的无缝跳转特点，不断把用车、出行产业链里临时性、低频需求给串了起来，最终汇集成生态。很容易理解的一点是，几乎没有人愿意站在路边用流量专门下载一个挪车APP。但有了小程序之后，这就让颗粒度再细的临时性长尾需求，也不会被下载注册APP的高门槛所挡在互联网世界之外了，这对于 B 端的意义在于：更加容易地构建了一个生态。三、下沉生态开拓者从另一个角度来看，小程序是承接新用户或者说下沉用户的最佳容器。「车来了」是做公交信息查询的一家创业公司，其创始人在一次群访中对周天财经表示：在车来了APP里，男女占比一样，但是到了小程序里面，女性用户占比达到了 7 成。从年龄段看，APP里是 19-35 岁为主流，但在小程序里，最高年龄段触及到了 45 岁。用户画像说明：小程序降低使用门槛，使得原本不亲近互联网的人群，有了获得互联网服务的机会。小程序本质上，是一个做大蛋糕、扩大人群基数的业态。接下来，我们以阿里的小程序体系为样本进行深度研究，具体来看为什么小程序对于拓展线下场景、以及 to B 服务至关重要。支付宝在阿里体系内，此前即便在没有小程序的助攻下，同样也是扮演着开拓线下最为迅猛、充当拉新最前锋的角色。这款国民级移动支付APP，以支付为切入点，深入线下缴费场景，从而完成了对民生服务场景的全覆盖，这也让支付宝天然具备了很强的获客能力。QuestMobile 数据显示：支付宝月活用户在 2018 年 11 月已超 6.5 亿。而一位行业人士透露的数据是：最近，支付宝月活已经超过 7 亿。还有一位内部人士也告诉周天财经：目前支付宝月活已经超过淘宝，二者人群也有巨大的错位，淘宝客群发源于多年前积累的网购群体，而支付宝则吸纳了大量的四五线城市尚未网购的线下用户，小程序天然适配于这个人群的需求。移动支付和小程序的双重助推效应解释了：为什么支付宝小程序是目前阿里体系内跑出来最快的小程序。截至 2019 年 1 月，支付宝小程序的数量已增至 13 万，日活跃用户数突破 2.3 亿，平均 7 日留存率为 43.26%。对于很多远离互联网的边缘地域的原住民来说，他们最开始不一定敢去网上购物，但会先装支付宝在线下进行扫码付款。以我八十多岁的外公外婆为例：二人并不会网购，但都会通过支付宝来缴纳水电煤燃气费。在线下，不仅有数亿 C 端用户，还有大量的小的 B 端商户也在依赖支付宝的收钱码来实现收银，这些码商的另一个名字叫「个体户」，数量达到 1 亿。支付宝给码商的服务不仅仅是收银，还包括保险：大量码商实际上都是异地经营，并不享受医保报销，因此「多收多报」保险产品，就为码商解决了门诊报销问题。除了保险、码商备货，还能对接 1688 的供应链，而备货所需的资金则可以取自网商银行，码商从此有了数字化的货源和经营杠杆。而基于收银需求被吸引使用支付宝的码商，点开 1688 小程序即可在线进货，在进货过程中通过花呗赊账，实际上就是支付宝为阿里生态的其他功能完成了拉新获客的作用。正是支付宝小程序的驱动，阿里生态的用户基数也在 2018 年这一年增大了很多：目前，淘宝超过 70% 新增年度活跃消费者来自低线城市。一位业内人士向周天财经透露：在 2018 年淘宝增加的 1.2 亿用户中，有一半左右是由支付宝完成的拉新，而这其中，应该又有一半是小程序的功劳。可以说，对这 1 亿码商人群而言，支付宝小程序既是码商们生产经营全流程的数字化能力提供者，又是码商们个人生活服务的提供者。这背后，是基于阿里生态内不同能力的跨 BU 打通。以水果店为例：通过支付宝小程序基于不同场景的方案，水果店可实现一次开发、多端透出、多端运营。比如：在办公场景下，老板可以在钉钉群里直接启用支付宝门店小程序，让员工们点自己喜欢的水果，送货上门；再比如：在导航场景，如果目的地定在这家水果店，当导航结束时，门店小程序可在高德中自动唤醒，告诉车主有哪些水果在促销。小程序作为当下线下商业互联网化、数据化最重要的技术载体之一，有望重构线下商业价值，这一部分才是小程序真正的想象空间所在。支付宝本身已经完成了场景化功能的打通，背后是不同部门的高度协调，同气连枝。用户不再需要多方求助，而是在一个App内，通过小程序的跳转即可实现多个需求。可以说，透过支付宝小程序，B 端商户调用的是整个阿里商业操作系统的能力。这也意味着：支付宝小程序的崛起，是对阿里商业操作系统的正式落地。在阿里商业操作系统的构想中，阿里生态将为企业输出一整套的数字化能力，而非提供单一工具。阿里经济体内的品牌、商品、销售、营销、渠道、制造、服务、金融、物流供应链、组织、信息管理系统等企业运营中的 11 大商业要素，都会融合性地助力零售业的数字化转型，改造商业结构、创造出新的需求和市场。而集成这 11 种商业要素的最佳载体，就是小程序。AT 的对决，某种意义上，就是二者在小程序上的对决，这将是 2019 年互联网世界里最有意思的商战。双方在小程序战场的不同进展，直接对应的就是二者改造实体产业的高下之分。四、小程序再升级而在近期，阿里商业操作系统打算加码小程序的底层能力。3 月 21 日，阿里云联合支付宝、淘宝、钉钉、高德，在北京共同了发布了小程序繁星计划。除了为开发者提供 10 亿技术补贴，为商家提供 10 亿运营补贴之外，更重要的是：该一站式小程序云服务最大的亮点还在于可以跨 BU、跨部门，无缝对接阿里集团各开放平台服务市场以及天猫、淘宝、菜鸟、蚂蚁等阿里集团各 BU 业务能力。在现场，阿里云智能产品管理部总经理马劲就演示了如何借助阿里云的基础平台能力快速创建小程序。以一款 VR 看车小程序为例，马劲在可视化界面中，轻点几下，就迅速调取了阿里云的 AI、语音交互、高德地图等能力，并引入了第三方提供的全景看车能力，再通过勾选不同端口，就能实现多端发布。有了更多底层技术的加持，开发门槛在迅速降低，而繁星计划将推动马劲演示的理想状态成为现实。台前一分钟，台后则是这家巨头正在试图打通奇经八脉。可以预见的是：支付宝小程序开发者将成为阿里系融合的最大赢家。因为随着阿里商业操作系统加速融合，淘宝天猫的供应链资源、菜鸟的物流调度资源、蚂蚁金服的金融资源以及各种新零售经验，都会无摩擦无阻碍地注入支付宝小程序。这样一来，支付宝小程序在商业和生活服务领域已初步形成的马太效应，会进一步加强。阿里商业操作系统 to B 的最为重量级的抓手，也就此浮出水面。支付宝小程序总经理管仲在接受周天财经专访时表示：各个 BU 在 To B 这件事上已经达到高度一致，不同 BU 之间在小程序上的“握手”，时机已经成熟。写到这里，已经不难预见，在淘宝天猫开辟的“新零售”战场之外，支付宝“新服务”正呼之欲出。五、催生“新服务”研究微信和支付宝的差异可以发现：用户在微信内的停留常常是漫游式的无目的闲逛，这就决定了微信小程序更多是围绕下沉人群的闲暇时间来挖掘商业潜力；而支付宝本身带有非常强的工具属性和服务心智，用户基本都是带着明确的服务诉求来支付宝，而非为了前来闲逛，这也就决定了支付宝小程序必须主打提升效率的服务类系统。同样的小程序，对微信来说是盘活流量、承接时间的工具；对支付宝来说，就是为 B 端用户加上数字化杠杆的系统本体。这让过去无法在线完成的服务，有了实施的可能。如前面所举的例子，小小的挪车小程序都能在支付宝中构建出一个子生态，还有更多的民生服务，都能基于同样玩法来不断衍生出新物种。随着这一提升效率的“系统”越发强化，在四五线城市，甚至诞生了一门面向下沉人群的生意：协助下载App，下载一个支付宝App，付费五元。可见，不管是小 C 还是小 B，人们获取“新服务”的意愿是如此迫切。当阿里基于天猫淘宝饿了么的新零售体系，已经逐渐变得高度成熟，人货场重构的完成度已经很高了。关于互联网的下一波主题是什么？我大胆猜想：是支付宝小程序对于长尾需求和下沉人群的双重驱动，让供需两端同时借助“系统”实现数字化，从而重构“人与服务”的关系。“新服务”时代的到来，已近在眼前。 作者：周天本文由@周天财经 原创发布于人人都是产品经理，未经允许，禁止转载题图来自Unsplash, 基于CC0协议"}
{"title": "微信小程序-测试游戏生成六边多边形 ", "author": "Rolan", "pub_time": "2018-9-11 00:21", "content": "最新又接到新的活动需求啦，是一个测试类的游戏。 大概的看了整个需求，这个活动的难点在于结果页面的六边形指标怎么实现。效果demo类似分析背景 首先，这是用户对应六个属性值的等边六边形，等边六边形这是一个很关键的点；为什么是等边六边形呢，因为用户留个属性的峰值的一样的，起点也是一致的。中心点 这个六边形的中心就是整个圆心的中心位置六个属性坐标位置 我们需要各自的属性值算出对应的坐标位置绘画等边六边形我们假设要绘画边长为240长度的等边六边形； 我们需要简单的计算下；我们把底部切成三块，一个三角形+矩形+三角形用css方式把它画出来。相信三角形的画法大家应该都很清楚了，这里就不重复讲基础的东西dom<view class=\"six-bg\">\r\n  <view class=\"box1\"></view>\r\n  <view class=\"box2\"></view>\r\n  <view class=\"box3\"></view>\r\n</view>\r\n复制代码css@sixWidthRPX: 208rpx; // 240*cos30°\r\n@sixHeightRPX: 120rpx; // 240*sin30°\r\n@sixWidthBigRPX: 416rpx;\r\n@sixHeightBigRPX: 240rpx;\r\n.six-bg{\r\n    padding: 167rpx;\r\n    .box1{\r\n      width:0;\r\n      border-left: @sixWidthRPX solid transparent;\r\n      border-right: @sixWidthRPX solid transparent;\r\n      border-bottom: @sixHeightRPX solid #6c6;\r\n    }\r\n    .box2{\r\n      width: @sixWidthBigRPX;\r\n      height: @sixHeightBigRPX;\r\n      background-color: #6c6;\r\n    }\r\n    .box3{\r\n      width:0;\r\n      border-top: @sixHeightRPX solid #6c6;\r\n      border-left: @sixWidthRPX solid transparent;\r\n      border-right: @sixWidthRPX solid transparent;\r\n    }\r\n }\r\n复制代码效果图根据属性值画点连线假设我们把那个属性值的峰值都定为10。我们知道等边六边形的6边长度都为240。那我们的每个单位就是24。我们先假设6个属性值都满了，那么data = {\r\n  sixData: {\r\n    one: 10,\r\n    two: 10,\r\n    three: 10,\r\n    four: 10,\r\n    five: 10,\r\n    six: 10\r\n  }\r\n}\r\n复制代码我们找下等边六边形的圆形点。X轴位置 167+208 = 375Y轴位置 167+240 = 4076个坐标位置第一个点的坐标和第四个点的坐标是最容易计算的，我们先把这两个点的坐标算出来；const unit = 24  // 单位\r\nconst centerDotX = 375  // 中心点\r\nconst centerDotY = 407  // 中心点\r\n// 第一个点 位置\r\nlet dotOne = {\r\n    x: centerDotX,\r\n    y: centerDotY - this.sixData.one * unit\r\n}\r\n// 第四个点 位置\r\nlet dotFour = {\r\n    x: centerDotX,\r\n    y: centerDotY + this.sixData.four * unit\r\n}\r\n复制代码第二、三、五、六点的坐标我们就需要用到三角函数了；我们观察下这个图，发现 2、3、5、6点都有30度的夹角；第二点坐标const lineLongTwo = unit * this.sixData.two\r\nx = centerDotX + lineLongTwo*cos30\r\ny = centerDotY - lineLongTwo*sin30\r\n复制代码我们的js代码并没有cos、sin的方法；这时候我们需要补一下Math函数的知识；Math.sin(x) x 的正玄值。返回值在 -1.0 到 1.0 之间；Math.cos(x) x 的余弦值。返回的是 -1.0 到 1.0 之间的数；这两个函数中的X 都是指的“弧度”而非“角度”，弧度的计算公式为：(度数 * Math.PI) / 180；现在我们可以算出6个点的位置了const unit = 24  // 单位\r\nconst centerDotX = 375  // 中心点\r\nconst centerDotY = 407  // 中心点\r\n// 第一个点 位置\r\nlet dotOne = {\r\n    x: centerDotX,\r\n    y: centerDotY - this.sixData.one * unit\r\n}\r\n// 第二个点 位置\r\nconst lineLongTwo = unit * this.sixData.two\r\nlet dotTwo = {\r\n    x: centerDotX + lineLongTwo * Math.cos((30 * Math.PI) / 180),\r\n    y: centerDotY - lineLongTwo * Math.sin((30 * Math.PI) / 180)\r\n}\r\n// 第三个点 位置\r\nconst lineLongThree = unit * this.sixData.three\r\nlet dotThree = {\r\n    x: centerDotX + lineLongThree * Math.cos((30 * Math.PI) / 180),\r\n    y: centerDotY + lineLongThree * Math.sin((30 * Math.PI) / 180)\r\n}\r\n// 第四个点 位置\r\nlet dotFour = {\r\n    x: centerDotX,\r\n    y: centerDotY + this.sixData.four * unit\r\n}\r\n// 第五个点 位置\r\nconst lineLongFive = unit * this.sixData.five\r\nlet dotFive = {\r\n    x: centerDotX - lineLongFive * Math.cos((30 * Math.PI) / 180),\r\n    y: centerDotY + lineLongFive * Math.sin((30 * Math.PI) / 180)\r\n}\r\n// 第六个点 位置\r\nconst lineLongSix = unit * this.sixData.six\r\nlet dotSix = {\r\n    x: centerDotX - lineLongSix * Math.cos((30 * Math.PI) / 180),\r\n    y: centerDotY - lineLongSix * Math.sin((30 * Math.PI) / 180)\r\n}\r\n复制代码现在我们来把点连成；我们可以采用 微信小程序canvas api 来绘制我们的六条线先建立canvas dom<view class=\"canvas-module\">\r\n  <canvas canvas-id=\"myCanvas\" class=\"canvas-class\"/>\r\n</view>\r\n复制代码css布局.canvas-module{\r\n    position: absolute;\r\n    width: 750rpx;\r\n    height: 750rpx;\r\n    z-index: 2;\r\n    top: 0;\r\n    left: 0;\r\n    .canvas-class{\r\n      width: 750rpx;\r\n      height: 750rpx;\r\n    }\r\n}\r\n复制代码canvas api文档 developers.weixin.qq.com/miniprogram…绘制const ctx = wepy.createCanvasContext('myCanvas')\r\nctx.beginPath()\r\nctx.moveTo(dotOne.x / 2, dotOne.y / 2)\r\nctx.lineTo(dotTwo.x / 2, dotTwo.y / 2)\r\nctx.lineTo(dotThree.x / 2, dotThree.y / 2)\r\nctx.lineTo(dotFour.x / 2, dotFour.y / 2)\r\nctx.lineTo(dotFive.x / 2, dotFive.y / 2)\r\nctx.lineTo(dotSix.x / 2, dotSix.y / 2)\r\nctx.lineTo(dotOne.x / 2, dotOne.y / 2)\r\nctx.stroke()\r\nctx.draw()\r\n复制代码位置坐标为什么要除以2呢？因为canvas是以px为单位的效果图我们再给利用canvas属性，给它加上一点补一样的东西我们给线加上颜色和宽度ctx.setStrokeStyle('yellow')  // 线条颜色\r\nctx.setLineWidth(2)  // 线条宽度\r\n复制代码填充渐变颜色const grd = ctx.createLinearGradient(0, 0, 200, 0)\r\ngrd.addColorStop(0, 'red')\r\ngrd.addColorStop(1, 'white')\r\nctx.setFillStyle(grd)\r\nctx.fill()\r\n复制代码加上透明度ctx.setGlobalAlpha(0.7)\r\n复制代码效果图最后我们再加上个动画，修改属性值，完成整个效果；dom<view class=\"canvas-module\" animation=\"{{animationData}}\">\r\n  <canvas canvas-id=\"myCanvas\" class=\"canvas-class\"/>\r\n</view>\r\n<button @tap=\"goStart\">开始canvas</button>\r\n复制代码css.canvas-module{\r\n    position: absolute;\r\n    width: 750rpx;\r\n    height: 750rpx;\r\n    z-index: 2;\r\n    top: 0;\r\n    left: 0;\r\n    transform: scale(0);  //新增样式\r\n    .canvas-class{\r\n      width: 750rpx;\r\n      height: 750rpx;\r\n    }\r\n}\r\n复制代码jsdata = {\r\n  animationData: {},\r\n  sixData: {\r\n    one: 10,\r\n    two: 7,\r\n    three: 1,\r\n    four: 6,\r\n    five: 2,\r\n    six: 8\r\n  }\r\n};\r\n复制代码methods = {\r\n  goStart () {\r\n    var animation = wepy.createAnimation({\r\n      duration: 1000,\r\n      timingFunction: 'ease'\r\n    })\r\n    animation.scale(1, 1).step()\r\n    this.animationData = animation.export()\r\n  }\r\n}\r\n复制代码效果如下这样整个动画就算完成了， demo请前往github github.com/fishmankkk/…其实背景图也是可以用canvas画的，有兴趣的小伙伴可以动手自己画一下"}
{"title": "解决微信小游戏排行榜 Android 模糊问题 ", "author": "Rolan", "pub_time": "2018-7-30 00:08", "content": "最近用 Cocos Creator (cc) 开发微信小游戏。由于 微信小游戏存在 主域和子域的隔离；主域，你的主要游戏场景，和一些交互按钮等内容；子域，主要用于获取用户数据和排行榜的显示；微信这样分开也是为了更好地保护用户数据，防止数据泄露。因此一定要合理的设计自己的主域和子域；凡是设计从微信里获取数据的比如用户头像，游戏成绩等；一定需要在子域的canvas 完成绘制；实际在完成排行榜的功能时候遇到了一点兼容性的问题，Android 的部分机型(自己这边全部复现)和 iOS 设备上存在画布模糊的问题:ios 的截图如下:搜索了一下，发现没有多少人提出这样的问题，但是看别的游戏也存在同样的问题；不过，灵机一动！！！如果前端接触 canvas 的话，才开始都会遇到一个问题，就是再 PC 上看着挺好的，但是在移移动端就模糊了，因为这里存在一个 设备上物理像素和设备独立像素(device-independent pixels (dips))的比例 因此你的 canvas 设置的像素要比实际多出一些比如会有:canvas.width = window.innerWidth * window.devicePixelRatio  \r\n于是照着这个思路，输出了 主域的 canvas 宽度 和 子域的 canvas 宽度，发现 子域的 sharedCanvas 并不是你预期的宽度，因此这个时候你需要手动的将它设置成你在 cocos creator 设置的画布大小比如 750 * 1662 等；if (typeof sharedCanvas !== 'undefined') {  \r\n  sharedCanvas.width = 750\r\n  sharedCanvas.height = 1662\r\n}\r\n大概完成后就不会有模糊的感觉了~"}
{"title": "丛九九微信小程序demo实战教程：Bilibili排行榜 ", "author": "天下雪", "pub_time": "2016-11-1 13:06", "content": "最近微信小程序很火，于是趁机学了一下。然后做了个小的demo，实现了查看B站排行榜的功能。项目地址 https://github.com/congjiujiu/bilibiliRank由于没有appid，所以没法在微信里面预览。可以clone到本地然后在微信web开发工具里面看到项目。git clone https://github.com/congjiujiu/bilibiliRank.git yourappnamecd yourappname在微信web开发工具里面新建项目，地址选到刚clone的地址即可查看了。效果gif可以看 github 的演示！建立项目先创建初始页面，也就是两部分，顶上图片，以及下方列表。用你喜爱的编辑器打开 pages/index/index.js，编辑一下//index.js//获取应用实例var app = getApp()Page({  data: {    bili: {      list: [        {          id: 0,          name: '全区排行榜'        },        {          id: 1,          name: '番剧排行榜'        },         {          id: 2,          name: '原创视频排行榜'        }    ]}  },  onLoad: function () {    console.log('onLoad');  }})表明有三个列表项，然后就可以在index.wxml里面获得数据了<!--index.wxml--><view class=\"container\">\t<view class=\"header\"></view>\t<view class=\"content\">\t\t<view class=\"cmds\">\t\t\t<navigator wx:for=\"{{bili.list}}\" url=\"../ranklist/ranklist?id={{item.id}}\">\t\t\t\t<view class=\"cmd-list\" data-id=\"{{item.id}}\">{{item.name}}</view>\t\t\t</navigator>\t\t</view>\t</view></view>如上，一个header，通过设置background-image来设置头图，下方通过wx:for方法来循环生成一个列表。navigator标签，可以在点击的时候跳转到url指定的组件内。类似于原生的a标签。然后设置一下css，在app.wxss内：/**app.wxss**/.container {\tmargin: 0;\tpadding: 0;\tfont-family: \"Microsoft YaHei\", Monaco;\theight: 100%;} .header {\theight: 140px;\twidth: 100%;\tbackground-image: url(images/logo.jpg);\tbackground-size: 赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              秀杰实战教程系列《十二》：基于LeanCloud实现访问网络与数据存储 ... \n              Belinda的小程序踩坑记《一》 \n            \n             \n            \n                  原作者: 丛九九 \n                  来自: 原文地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小游戏好友排行榜快速开发教程\n                                    \n                  • 解决微信小游戏排行榜 Android 模糊问题\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSEgbX4o', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n给媳妇做一个记录心情的小程序2019-03-22微信小程序开发中的代码片段总结2019-03-22小程序自定义单页面、全局导航栏2019-03-15微信，支付宝小程序实现原理概述2019-03-25Natsuha - 用Taro写个天气微信小程序2019-03-12mpvue开发音频类小程序踩坑和建议2019-03-12微信单页应用的那些事2019-03-13微信小程序框架wepy踩坑记录（与vue对比）2019-03-12如何使用微信小程序云函数发送短信验证码2019-03-13\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n“坦白言”社交类型分享裂变小程序开源2019-04-08AI驾驶行为检测DEMO2019-04-05弹幕微信小程序Demo2019-04-05小程序组件常用组件分享2019-04-02性格测试小程序2019-04-01小程序登录Demo2019-03-26想做一个微信论坛项目2019-03-25新版答题小程序2019-03-21小程序组件常用组件分享2019-03-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880729|21a829fda2197c34653786a20f9aa4d9|2';"}
{"title": "说说微信小程序开发的那些坑--setData ", "author": "Rolan", "pub_time": "2017-12-6 00:21", "content": "this.setData估计是小程序中最经常用到的一个方法，但是要注意其实他是有限制的，忽略这些限制的话，会导致数据无法更新setData的反模式：-- 短时间频繁进行setData操作--页面进入后台后依然进行setData操作-- 使用setData一次性设置太多的数据这里重点说一下第3点，获取更新列表的时候非常容易触犯第三点，举个栗子：假设Page中data有items的数据，装着列表的数据 Page({\r\n  data: {\r\n    items: [],\r\n  }\r\n});一般情况下，更新items的操作可能如下：loadItems() {\r\n    //假设通过API获取到新的列表数据：newItems\r\n    const { items } = this.data;\r\n    this.setData({\r\n    items: items.concat(newItems)\r\n  })\r\n}如果完整items的数据量不大的时候，这样做也是可以的，但是列表的数据比较多的时候，后面loadItems时setData的数据就会变很大，超过一定值（1048576）后就会报以下错误，然后列表无法再加载更多数据传输长度为 xxxxxx 已经超过最大长度 1048576若遇到这样的情况，我的解决方法是loadItems() {\r\n    //依然假设通过API获取到新的列表数据：newItems\r\n    const { items } = this.data;\r\n    const start = items.length;\r\n    const updateItems = newItems.reduce((updateItems, item, index) => {\r\n        const key = `items[${start + index}]`;\r\n        updateItems[key] = item; \r\n        return updateItems;\r\n    }, {})\r\n  //updateItems 示例： { items[0]: 'content', item[1]: 'content', ... }\r\n  this.setData(updateItems)\r\n}以上是我开发时遇到的坑，欢迎大家探讨指导，感谢阅读"}
{"title": "用setData修改对象的属性值/去除button按钮的边框 ", "author": "Rolan", "pub_time": "2017-12-21 00:31", "content": "用setData修改对象的属性值1.\r\nPage({    data: {      items:{ //items为一个对象，is_like和like分别为其两个属性        is_like: 0,        like: 0     } },likes: function () {    var is_like =\"items.is_like\"; //先用一个变量，把items.is_like用字符串拼接起来    var like = \"items.like\";   if (this.data.items.is_like == 0 && this.data.items.like==0){       this.setData({          [is_like]:1, 使用【】将字符串包起来，为其赋值          [like]:1       })   } else if (this.data.items.is_like == 1 && this.data.items.like == 1){      this.setData({         [is_like]: 0,         [like]: 0      })   }},})\r\n2.index.wxml: 使用bindtap绑定事件\r\n <view class=\"centers\" bindtap=\"likes\">     <view wx:if=\"{{items.is_like == 0}}\">       <image class=\"src\" src=\"../../image/like1.png\"></image>     </view>     <view wx:else>       <image class=\"src\" src=\"../../image/like2.png\"></image>    </view>    <view class=\"space\">赞<text class=\"character\">:</text>{{items.like}}</view> </view>\r\n去除button按钮的边框小程序开发中，有时候我们希望button不要有边框，需要使用button::after来实现，具体如下：.operations button::after{border:0 none;}另外button的样式，都是通过button::after伪类来实现的。"}
{"title": "小程序开发技巧总结 ", "author": "Rolan", "pub_time": "2018-7-20 00:25", "content": "最近公司要开发一款电商小程序，匆忙看了一遍文档就开始干活了。整体开发体验个人感觉不太好，特别是如果之前习惯了Vue开发，突然去开发小程序，感觉很鸡肋。以下是我在开发中遇到的一些问题以及解决方法的总结，仅供参考引入iconfont在小程序中引入字体图标要比web麻烦一些，简单说需要三步：下载iconfont，把iconfont.css复制到iconfont.wxss，在app.wxss中引入查看iconfont在unicode模式下的在线链接，替换iconfont.wxss中的链接为远程链接在wxml文件中引入对应的icon class<icon class=\"iconfont icon-pay\"></icon>\r\n复制代码使用lessvscode有一个easy less插件，是我感觉使用less最简单的方式vscode安装easy less插件创建一个less目录，用于存放less文件文件头部添加编译注释 // out: ../pages/index/index.wxss, compress: true, sourceMap: falsectrl + s保存后自动编译编译后的结果按钮重置小程序中的按钮功能强大，很多功能必须要用按钮，比如弹出用户授权，调用客服功能。默认的样式一般无法满足需求，可以把按钮样式统一重置，然后自己写样式button {\r\n  padding: 0;\r\n  background: #fff;\r\n  line-height: 0;\r\n  &::after {\r\n    border-color: transparent;\r\n  }\r\n}\r\n.button-hover {\r\n  background: #fff;\r\n}\r\n复制代码支持async-awaitasync-await是ES7的语法，截止我写这篇文章为止，小程序还是不支持async-await语法的，所以需要使用regenerator这个库下载regenerator，并把regenerator-runtime并放到utils目录下2. 在util.js引入 import regeneratorRuntime from './regenerator-runtime/runtime-module'封装wxRequest，让它支持async-awaitconst wxRequest = async (url, params = {}) => {\r\n  Object.assign(params, {\r\n    token: wx.getStorageSync('token')\r\n  })\r\n  // 所有的请求，header默认携带token\r\n  let header = params.header || {\r\n    'Content-Type': 'application/json',\r\n    'token': params.token || ''\r\n  }\r\n  let data = params.data || {}\r\n  let method = params.method || 'GET'\r\n  // hideLoading可以控制是否显示加载状态\r\n  if (!params.hideLoading) {\r\n   wx.showLoading({\r\n     title: '加载中...',\r\n   })\r\n  }\r\n  let res = await new Promise((resolve, reject) => {\r\n    wx.request({\r\n      url: url,\r\n      method: method,\r\n      data: data,\r\n      header: header,\r\n      success: (res) => {\r\n        if (res && res.statusCode == 200) {\r\n          resolve(res.data)\r\n        } else {\r\n          reject(res)\r\n        }\r\n      },\r\n      fail: (err) => {\r\n        reject(err)\r\n      },\r\n      complete: (e) => {\r\n        wx.hideLoading()\r\n      }\r\n    })\r\n  })\r\n  return res\r\n}\r\n\r\nexport {\r\n  wxRequest\r\n}\r\n复制代码使用方法：import regeneratorRuntime from '../../utils/regenerator-runtime/runtime-module.js'\r\nimport {\r\n  wxRequest\r\n} from '../../utils/util.js'\r\n\r\nPage({\r\n  data: {\r\n   list:[],\r\n   count: 0,\r\n   page: 1,\r\n   limit: 10\r\n  },\r\n  onLoad: function() {\r\n    this.getList()\r\n    // 请求已经结束 做其他事\r\n  },\r\n  getList: async function() {\r\n    await wxRequest(app.globalData.baseUrl + '/test',{\r\n      hideLoading: true,\r\n      data: {\r\n        limit: this.data.limit,\r\n        page: this.data.page\r\n      }\r\n    }).then((ret) => {\r\n      this.setData({\r\n        list: ret.data.data,\r\n        count: ret.data.num\r\n      })\r\n    })\r\n  }\r\n})\r\n复制代码封装之后用起来还是很爽的，扩展起来也方便动态设置data中某个值应用场景：循环出来的列表，需要根据点击项，动态改变列表中对应id的数据// 动态传递id\r\n<block wx:for=\"{{list}}\" wx:key=\"{{index}}\">\r\n  <view catch:tap=\"onChangeName\" data-id=\"{{item.id}}\"></view>\r\n</block>\r\n\r\nPage({\r\n  data: {\r\n    list:[{\r\n      id: 0,\r\n      name: 'wang'\r\n    },{\r\n      id: 1,\r\n      name: 'li'\r\n    }]\r\n  },\r\n  onChangeName: function(event){\r\n    // 拿到id\r\n   let id = event.target.dataset.id\r\n   let key = `list[${id}].name`, val = 'zhang'\r\n   // 设置值\r\n   this.setData({\r\n    [key]: val\r\n   })\r\n  }\r\n})\r\n复制代码flex布局，溢出省略号无效订单列表一般都是左边一个图片，右边是标题或描述。这时候图片宽度是固定的，标题长度自适应.wrap {\r\n  display: flex;\r\n}\r\n.sub {\r\n  flex: 1;\r\n  width: 0; // 宽度设为0\r\n}\r\n.sub text {\r\n  display: block; // 一定要设置成block\r\n}\r\n\r\n<view calss=\"wrap\">\r\n  <image src=\"i.png\"/>\r\n  <view class=\"sub\">\r\n    <text>一段文本一段文本一段文本一段文本一段文本一段文本</text>\r\n    <view>其他</view>\r\n  </view>\r\n</view>\r\n复制代码组件事件传递任务：父组件向子组件传递初始数据，当子组件点击以后可以triggerEvent自定义事件，父组件执行自定义事件，重新请求数据并传给子组件/* 子组件 */\r\n<view>\r\n  <view bind:tap=\"setId\" data-id=\"1\"></view>\r\n</view>\r\n\r\nproperties: {\r\n  list: {\r\n    type: Array,\r\n    default: []\r\n  }\r\n},\r\n\r\nmethods: {\r\n  setId(e) {\r\n    let id = e.currentTarget.dataset.id\r\n    this.triggerEvent('deleteFav', id)\r\n  }\r\n}\r\n\r\n/* 父页面 */\r\n<child bind:customEvent=\"deleteFav\"></child>\r\n\r\ndata: {\r\n  list: []\r\n},\r\ndeleteFav(e) {\r\n  let id = e.detail // 获取传递过来的数据\r\n  // 根据id请求数据，然后重新setData\r\n  let newData = [1,2,3]\r\n  this.setData({\r\n    list: newData\r\n  })\r\n}\r\n复制代码使用wxParse解析HTML下载 wxParse ，放到utils目录下在JS页面引入： import WxParse from '../../utils/wxParse/wxParse'Page({\r\n  data:{\r\n    contentHTML:'' // 解析后的HTML\r\n  },\r\n  onLoad: function() {\r\n    // 请求到的HTML数据\r\n    let content = '<div>我是HTML代码</div>', that = this;\r\n    WxParse.wxParse('contentHTML', 'html', content, that, 0);\r\n  }\r\n})\r\n\r\n复制代码显示解析内容<import src=\"../../utils/wxParse/wxParse.wxml\"/>\r\n<view>\r\n  <!-- 显示内容 -->\r\n  <template is=\"wxParse\" data=\"{{wxParseData:contentHTML.nodes}}\" />\r\n</view>\r\n复制代码图片等比例image标签有个mode属性，可以设置图片如何显示，如果文档看的不仔细还真容易发现<image src=\"test.png\" mode=\"widthFix\"/>\r\n复制代码上拉加载和下拉刷新{\r\n  \"onReachBottomDistance\": 0,\r\n  \"enablePullDownRefresh\": true\r\n}\r\n复制代码data: {\r\n  limit: 30,\r\n  page: 1,\r\n  list:[],\r\n  count:0\r\n},\r\n// 下拉\r\nonPullDownRefresh: function () {\r\n  this.setData({\r\n    page: 1,\r\n    list:[]\r\n  })\r\n  this.getData()\r\n},\r\n// 上拉\r\nonReachBottom: function () {\r\n  if(this.data.list.length >= this.data.count) {\r\n    return false\r\n  }\r\n  this.setData({\r\n    page: this.data.page + 1\r\n  })\r\n  this.getData()\r\n  wx.stopPullDownRefresh()\r\n},\r\ngetData: async function () {\r\n  await wxRequest(app.globalData.baseUrl + '/test', {\r\n    data: {\r\n      page: this.data.page,\r\n      limit: this.data.limit,\r\n    }\r\n  }).then((ret) => {\r\n    let list = this.data.list.concat(ret.data.list)\r\n    this.setData({\r\n      list: list,\r\n      count: ret.data.count\r\n    })\r\n  })\r\n}\r\n复制代码上传图片任务：小程序上传图片到服务器，最多上传三张，前端可以删除图片效果图如下使用到的API有两个：wx.uploadFile wx.chooseImage示例WXML：<view class=\"sale after-pic\">\r\n  <block wx:for=\"{{imgList}}\" wx:key=\"{{index}}\">\r\n    <view class=\"pic\">\r\n      <image src=\"{{item}}\" />\r\n      <icon type=\"clear\" size=\"20\" catchtap=\"clearImg\" data-id=\"{{index}}\"/>\r\n    </view>\r\n  </block>\r\n  <image src=\"../../images/upload.png\" catchtap=\"chooseImage\" />\r\n</view>\r\n<button catchtap=\"onSub\">提交</button>\r\n复制代码imgList是wx.chooseImage成功后返回的图片临时地址示例JSPage({\r\n  data: {\r\n    imgList:[]\r\n  },\r\n  // 使用async await是因为图片上传是异步的\r\n  onSub: async function() {\r\n    // 点击提交后，开始上传图片\r\n     let imgUrls = []\r\n     for (let index = 0; index < this.data.imgList.length; index++) {\r\n       await this.uploadFile(this.data.imgList[index]).then((res) => {\r\n         // 这里要注意把res.data parse一下，默认是字符串\r\n         let parseData = JSON.parse(res.data)\r\n         imgUrls.push(parseData.data) // 图片地址\r\n       })\r\n     }\r\n     console.log(imgUrls) // 3张图片上传成功后，执行其他操作\r\n  },\r\n  // 删除某张图片\r\n  clearImg: function (params) {\r\n    let imgList = this.data.imgList\r\n    let id = params.currentTarget.dataset.id // 图片索引\r\n    imgList.splice(id, 1) // 删除\r\n    this.setData({\r\n      imgList: imgList\r\n    })\r\n  },\r\n  chooseImage: function (params) {\r\n    wx.chooseImage({\r\n      count: 3, // 做多3张\r\n      sizeType: ['original', 'compressed'],\r\n      sourceType: ['album', 'camera'],\r\n      success: (res) => {\r\n        // 存储临时地址\r\n        this.setData({\r\n          imgList: res.tempFilePaths\r\n        })\r\n      }\r\n    })\r\n  },\r\n  uploadFile: function (filePath) {\r\n    // 返回Promise是为了解决图片上传的异步问题\r\n    return new Promise( (resolve, reject) => {\r\n      wx.uploadFile({\r\n        url: app.globalData.baseUrl + '/file/upload', // 上传地址\r\n        filePath: filePath,\r\n        name: 'file', // 这里的具体值，问后端人员\r\n        formData: {},\r\n        header: {\r\n          \"Content-Type\": \"multipart/form-data\"\r\n        },\r\n        success: (res) =>{\r\n          // 图片上传成功后，后端会返回一个地址，可以把它存到imgUrls\r\n          this.imgUrls.push(res.data.data)\r\n        },\r\n        fail:(err) => {\r\n          console.log(err)\r\n        }\r\n      })\r\n    })\r\n  }\r\n})\r\n复制代码动态标题onLoad的时候动态设置标题wx.setNavigationBarTitle({\r\n  title: '新标题'\r\n})\r\n复制代码结语以上是仅为我个人在开发过程中遇到的一些问题，若有错误还请批评指正，感谢阅读."}
{"title": "官方问答精选《十一》后台服务器配置https，获取canvas的尺寸 ", "author": "天下雪", "pub_time": "2017-1-2 00:26", "content": "放假中，被回答的问题也较少，大家凑合着看看吧；官方问答，并非一定是官方人员回答的，所以仅供参考；\r\n问题：如何获取canvas的尺寸（高度和宽度） 我要在canvas上画坐标，但是如何获取canvas的尺寸（高度和宽度）呢？\r\n\r\n答：\r\n\r\ncanvas的尺寸是可以设置的，参见canvas文档。\r\n问题：想问一下navigator的switchTab到底应该怎么样使用？     <navigator url=\"pages/cart/index/index\" open-type=\"switchTab\">switchTab</navigator>    <navigator url=\"cart/index/index\" open-type=\"switchTab\">switchTab</navigator>    <navigator url=\"../../cart/index/index\" open-type=\"switchTab\">switchTab</navigator>    <navigator url=\"../../cart/index/index\">普通</navigator>我测了这几种，除了第四种最普通的，其他都不能用，这个switchTab应该怎么用的？已经按照官网教程写了，我以为是要在app.json里面的tabBar里面给每个tab一个名字取名，结果会报错，有同学知道这个应该怎么做吗？\r\n另外还有一个问题，我用普通的跳转之后下面的navigator没了，有什么办法能让他出现呢?应该不能每个页面的page.json里面都去定义一遍吧？\r\n\r\n\r\n答：\r\nindex是一个关键字,会默认作为首页,也就是说只能有一个index文件,其他文件需要用别的名字,建议目录下所有文件名与目录相同,比如cart目录下cart.js cart.wxml  cart.wxss  cart.json\r\n\r\n\r\n问题：后台服务器配置https疑惑求解！我们的后台希望使用自己的服务器开发，我们有自己的网站域名和服务器。但有两个问题需要确认。1、微信小程序服务器配置，能绑定我们已有的网站域名和服务器吗？包括我们服务器上的mysql数据库？2、微信小程序服务器配置，都要求https协议，我们自己的网站和服务器没有配置，如何才能实现这个配置标准？什么办法，需要付费吗？\r\n\r\n\r\n答：\r\n\r\n可以绑定域名。数据库不需要绑定，通过request请求你自己的服务器API，实现数据库的操作。https协议，需要申请ssl证书，很多网站都有。可以先申请免费的，推荐几个:geotrusrt ,starcom,trustassia都可以申请。\r\n\r\n问题：一直无法通过扫码进入开发者工具 今天打开开发者工具，提示登录态失效，然后我重新扫描二维码，却无法登陆，提示网络错误接着下载了测试版，也不行\r\n\r\n答：系统中是否有不安全的https代理，请关掉代理重试\r\n问题：​有没有计划提供加密相关的API? 有没有计划提供加密的API的，比如request的时候，我希望在header里面加个token, 生成这个token过程是由小程序api调用native来完成。这样可以防止加密代码破解\r\n\r\n答：\r\n自己写就行了,传递的参数+自定义密匙(例如:\"jdufyhfh74884\"),做个md5作为token\r\n问题：scroll-view滑动时textarea没有滑动 scroll-view里面设置了textarea，scroll-view滑动时textarea内容没有跟着滑动，过了一会后跳到停止滑动后textarea相应位置\r\n\r\n答：Bug & Tip\r\nbug: 微信版本 6.3.30，textarea 在列表渲染时，新增加的 textarea 在自动聚焦时的位置计算错误\r\ntip: 请勿在 scroll-view 中使用 textarea 组件\r\ntip: textarea 的 blur 事件会晚于页面上的 tap 事件，如果需要在 button 的点击事件获取 textarea，可以使用 form 的 bindsubmit\r\ntip: 不建议在多行文本上对用户的输入进行修改，所以 textarea 的 bindinput 处理函数并不会将返回值反映到 textarea 上\r\n问题：\r\n小程序，请问有PHP版本的SDK么？ 如题，我是懂php+mysql的服务器开发者。想开发个网页版应用。请问有php版本么？\r\n答：\r\n基于微信开发，php+mysql可以作为后端服务器实现自己的业务逻辑，前端得用小程序这套规范。"}
{"title": "如何在现阶段做增量，做用户增长 ", "author": "Rolan", "pub_time": "2019-3-18 00:01", "content": "有幸旁听了十几位老板探讨会员制模式的案例。分享会员制模式案例的创业者在黑板上写画满满，多可以总结为一个关键：如何在现阶段做增量，做用户增长。对的，今天和您分享的还是用户增长这一话题。小编帮大家汇集了5个案例，分别都是站在用户体验视角，分享者亲自体验产品的玩法，并记录了下来。包括：拼多多「一分钱抽奖」、「小红书社交电商小红店小程序与「每日一淘」进行对比」、「十点读书全民读书激励计划」、「每日拼拼」、「微信读书」。类似笔记见实分享过多次，这里继续欢迎大家投稿。比如这篇：我拆解了几个小程序的玩法，一起看看。也感谢5个案例的分享者，如需要联系作者本人，我们可以帮着介绍。01 拼多多「一分钱抽奖」 小程序拉新裂变可借鉴模块一、用户流程点击进入别人发起的小程序/在拼多多点击进入“一分抽奖”选择相应的商品点击商品列表“一分抢”直接进入商品配置选择和付费界面/点击商品办呢人图进入详情页付费金额0.01付费成功，提醒分享拼单分享拼单成功，等待开奖二、玩法规则及亮点1、参与规则：①百分百中奖：付费0.01元开团，成团即可获得抽奖资格，二等奖全额退款并赠送88元代金券刺激消费，拼单未成功退款；②用户信任：文案提示保险担保，全场包邮。2、亮点（全是细节）1）商品橱窗展示页：点击“一分抽奖”进入商品橱窗展示页面后，点击相应橱窗的“马上抢”直接进入付费页面，点击banner进入详情页文案提示是“0.01一键拼”，直接点击“马上抢”的用户可能付费了之后才知道需要邀请别人来参团；2）用户评价展示提高用户信任：商品橱窗展示页上方banner下面有获奖用户的实时滚动展示，进入一个商品详情页后， 下方有一个“福星晒单”模块，即中奖用户评价，佐证活动的真实性；付费下单后引导分享的设置及文案：1）浮窗提示分享，且浮窗里面有一个实时滚动消息“xx分享x次抽中xx”，刺激用户去完成此动作；2）分享一次后，继续弹出引导分享浮窗，文案“首次分享成功，再分享给不同好友加快成团”；3）继续浮窗引导分享。实时反馈：第一个好友参团后有小程序模板消息提醒拼单成功后页面提醒引导关注公众号，查看抽奖结果，同时浮动文案引导“再次发起拼单，提高中奖率”继续引导分享；无处不在的用户参与滚动消息提醒。分享者：鉴锋团队，已经授权02 小红书社交电商小红店小程序与「每日一淘」进行对比：1、从选品上，看受众人群与产品定位「小红店」为小食类，共1个品类，商品共8款。包含泡面、花蛤酱等，可见针对人群，主要是学生党和白领人群，与一般网络主播淘宝店商品性质类似，单价低，受众人群广。促销形式也仅有优惠券+秒杀价，通过每日更新上下架商品，来保证商城的更新。「每日一淘」于2018年就上线的社交电商，已经有6种类型（不含专题类），商品初步估计也有几百款。这就表示，「一淘」的定位，是走向的社交电商的最终形态，线上分销的百货商城，每个细分产品，也是走的精品SKU路线，买苹果只有一种，买梨子也只有一种，但告诉你，这肯定是最好的。2、从拉新方式上，看裂变利益点「每日一淘」有2种途径拉新：1）第一种是通过邀请码，每个用户有专属邀请码，新人注册时，必须填写邀请码，才能进入注册。所以拉新的场景因此也可以确定，这一定是熟人裂变。（羊毛党除外）2）第二种方式是通过购买专属商品，通过一定的新人折扣优惠，帮助老客拉新，新客下单后，老客得返利，也会获得一定的佣金。社交电商的本质，就是「老带新返佣金」，因为我本人没有拉过朋友注册，这里有一点不太明确的，「每日一淘」上拉来的粉丝，后续购买是否也会给邀请人一定比例佣金。为什么说这个？因为 「小红店」对用户定义就是，你邀请得粉丝，不论什么时候购买了，都会给你一定比例的佣金。相比「每日一淘」，「小红店」的拉新门槛更低，新用户扫码进入小程序，获取了form_id，则成了你的粉丝。所以为什么，「每日一淘」成为会员，要拉10个粉丝，「小红店」却需要50个。3、从会员门槛上，比较获客成本：「小红店」是满50人，获取form_id的授权就算1个粉丝，则1个新用户。按照市场上小程序授权算，应该是2块左右1个授权，一个会员的价值，就是100块钱免费推广费。「每日一淘」只需要10个，但是门槛是注册，比起微信上点一下确定就完成的授权，注册需要填写手机号码，用户转化会低得多，这里算10块一个注册的高价（一般市场价价>10元），10个粉丝成为会员，一个会员的价值，也是100块钱免费推广费。但从后续用户生命周期来看，「小红店」的用户购买的商品种类只有1个，款式8个，也有限，且都是属于网红性质的商品。肯定很多用户都下单数量少，且复购率极低。「小红店」的定位，肯定是以走量为主，毕竟小红书一直都是属于打造爆款商品的社区。「每日一淘」上，应该单个用户创造的GMV会更高，商品种类多，复购概率更高。4、获客方式上，「小红店」的载体是小程序，而「每日一淘」是小程序和App两端，且提佣金只能在App上。总得来说， 「小红店」更像是主播淘宝店的「分销商城」，想要打响「小红店」，需要更多的推广费用和渠道，持续的注入流量，提高转化，是接下来会做的。我们拭目以待吧，说不定，下个版本就跟「每日一淘」一样了呢？分享者：超凶，已经授权03 十点读书全民读书激励计划1、亿现金池——引导APP下载——邀请规则/ 提现规则/ 下载引导2、玩法：包装大金额——66.6元两个阶段，一阶段简单大红包刺激，二阶段大红包，高难度刺激提现24小时限制+实名3、亮点：1.主题包装十点读书-全民读书激励计划-1亿现金池2、标题A/BTest1）助力我！羸奖学金2）我马上要领到66.6元现金啦，你也快来领！4、底部栏，引导下载的样式可参考引导下载APP，或提现操作等，点击欲望比较强，页面多按钮时可考虑底部栏样式5、提现流程（防薅）引导关注公众号——1份奖金既下载APP又引导关注公众号提现需要24小时后+实名认证——防薅羊毛6、规则设置邀请2名奖10元+邀请12名奖励66.6元，后面奖励反而少了，而且2名到12名跨度大，很多人邀请了2个人后，想踮踮脚尖再邀请，估计大部分也只能在6名左右，从而总体下来极大降低获客成本，可能APP获客成本会在2~4元左右，如果羊毛党传播开的话，加24小时挂奖设置，估计还会更低。其它思考：1、分享后可以引导关注公众号查看实时反馈（最后提现也是先引导关注公众号）。2、点击“我也要领”可以直接引导下载APP，同时帮好友助力成功。3、点击助力后，需要下载APP才可以助力，一般不是熟人，强引导帮忙，是不会下载的，可以让新用户帮忙助力也送他一个红包，但需要下载才可以领取，增加助力/下载转化率。4、正常用户拉不动，更多是羊毛党互薅了，拉1个好友可获得3元，新用户体量大，很多人可以做这个任务。所以很大程度还是会被薅，目标用户人群可能还是比较少；不过增加了24小时后提现+实名认证，防薅措施已经很足，1天后记得提现的人少之又少。最后，不过羊毛党影响身边的也是正常用户，其实最后效果很难说，说不定还是不错的，至少是可以大规模传播了，看到服务器都崩了一下下，看后期考验留存了。分享者：鉴锋团队，已经授权04 每日拼拼继每日优鲜之后，每日拼拼横空出世，在社交电商如火如荼之际，倡导一小时可送达+注册就有返利，下单就返7块的每日拼拼究竟如何，我体验了一下：一、流程体验：1）通过朋友圈和社群输入邀请码，下载并注册APP（注意：目前是内测阶段，只能输优惠码进入）2）用微信登录，并且登陆后就把个人信息有所调整。（比如：每日拼拼是每日优鲜旗下，我16年在上海时用过每日优鲜下单，用微信登录后直接定位我曾经在上海的地址）3）正式进入APP，能够明显感受有2个后台，一是用户自己购买，二是用户分销后台针对用户：1、极速达模块，拼团模式，不能加入购物车，直接拼团2、直接搜索，可以加购物车进行购买针对用户分销：1、低价拉粉，高佣专区，必推好货这3个栏目都是为了让用户分销，以低价来打动用户。2、其次，在每个产品，不管是拼团，打折与否，都会在价格后面明确返佣金额，促使用户转化。3、一键发圈，这个要重点说，解决了用户想分销，但苦于文案水平不行的痛点。不仅文案根据种类分了单品和多个，还分了渠道，发給微信好友，微信群，或是朋友圈，文案是直接自动粘贴到剪贴板。4、业绩板块，这个板块很明显是用于客户管理，订单管理，推广数据，可以自定义推广人数，订单量，客单价等，有点坑的是提现还必须绑定身份证，这个一方面是为了认证，另外一方面不知道是不是为了防止薅羊毛。二、激励策略1、邀请新人下单返7元。2、绑定粉丝500人，且订单量达到前50，返现200现金（扶植有流量用户，但个人觉得这个激励是不是有点便宜）。3、新用户开业红包60元（现金券应该是）。三、个人测评优势：1、 背靠每日优鲜资源，有用户大数据2、1小时达，可以触及17个核心城市3、分销的模式特别是文案方面让用户很省心4、补贴的返金目前是比较nice未知：1、是否品质过关，是否可以点评?2、内测的邀请码发了多少，有多少大v参与3、补贴能够维持多久，用户对价格的敏感度有多强?四、可复用：1.内测邀请码2.分销文案自动发圈分享者：漆漆，已经授权05 微信读书 这波助力活动套路十足活动概述：在朋友圈看到有微信读书的元宵助力活动，点击进微信好友的链接，即可增加一次他的抽奖机会，你也会额外获得一次机会。活动流程：1、通过朋友分享进入抽奖页面抽奖2、页面提示抽奖9次即可进入超级福利场赢终身会员3、机会不足分享朋友圈或微信群，再次获得机会4.直到抽奖9次后进入超级福利场（只有一次机会抽终身会员）4、抽不到终身会员又回到第一层的抽奖页面活动可借鉴：1、2层助力2、每一层活动的 分享页面提示不同，并且让用户觉得非常接近无限卡3、活动页面和音效很有魔性4、书籍和赠送的无限卡天数，书币即时到账活动bug：服务器压力过大，一直在不断修复分享者：漆漆，已经授权附：微信读书AARRR增长模型-分享者：鉴锋团队文：见实团队@见实丸(jianshishijie)"}
{"title": "官方问答精选《十五》ios8不支持flex布局，客服接口接收参数 ", "author": "天下雪", "pub_time": "2017-1-7 01:36", "content": "问题：\r\n体验小程序demo样式错乱... \r\n\r\n答：\r\n是这样的,ios8不完全支持flex布局,需要加-webkit参数才能识别,社区一个哥们给的方法是css全部放在wxss里面,就会自动加相关参数\r\n\r\n我的项目按照这个方法,成功解决了ios8下面的布局混乱问题。\r\n\r\n\r\n问题：小程序客服接口接收参数\r\n配置好消息推送后，post接收消息参数时只有三个字段signature    timestamp    nonce，为什么没有消息内容字段呢？文档中写的不清楚，只是给了参数的格式，没有给怎么接收消息\r\n答：\r\n参数不在get  也不在post中  在\r\nHTTP_RAW_POST_DATA\r\n中\r\n\r\n\r\n\r\n\r\n问题：hidden应该怎么使用\r\n在文档中有提到使用hidden来控制影藏和显示相比之下，hidden 就简单的多，组件始终会被渲染，只是简单的控制显示与隐藏。但是我不太清楚hidden是怎么使用的呢\r\n答：\r\n<view hidden=\"true\"/>\r\nor\r\n<view hidden=\"{{isHidden}}\"/>\r\n\r\n\r\n问题：请问小程序名称不能重复是指什么 \r\n\r\n在小程序接入指南上看到这幅图，要求填写的小程序账号名称不能与平台其他账号名称重复是指什么？ 是不能与其他小程序的名称重复还是指不能与我的账户主体下的其他小程序名称重复？如果是与其他小程序名称不能重复的意思是不是指别人已经有了一个小程序名叫“订火车票”，我就不能叫“订火车票”的意思吗？ 还有就是填写的名称什么时候生效的问题， 究竟是保存后生效，还是要等到小程序代码上传完成后才能生效。还有就是小程序的名称和营业执照上的公司名称有没有直接关联，小程序和营业执照上的经营范围有没有直接关联？谢谢大家\r\n答：\r\n不能和其他小程序和其他公众号名称重复,名字在整个微信平台必须唯一,所以抢占名字很重要\r\n\r\n发布前有2次改名机会,发布后就不允许改名了\r\n\r\n\r\n\r\n\r\n问题：小程序线上和开发配置问题 \r\n开发小程序，是否可以控制线上和开发环境比如：开发环境的request地址域名和线上的环境是不一样的开发小程序，request的url是不能带端口的，这个我在开发时应该怎么解决有没有好的办法控制登录拦截，比如需要统一管理登录控制3.1 导航的登录控制3.2 请求的登录控制注：我看小程序API 的导航接口和请求接口都是不能实现拦截的\r\n\r\n答：\r\n1、自己的控制，官方没有支持\r\n2、那就不要带端口，如果服务一定要带端口，就在服务器上用Nginx转发\r\n\r\n\r\n\r\n\r\n问题：\r\ntabBar 不能在子页面使用吗？ \r\n答：\r\n不能\r\n\r\n\r\n\r\n\r\n问题：开发者工具和真机下请求接口返回空，但在浏览器上执行却正常返回 \r\n开发者工具下（版本130400）：response code 200的浏览器下：\r\n答：\r\n比较header\r\n\r\n\r\n\r\n\r\n问题：wx.request返回的json是字符串，怎么破？\r\n为什么有的返回json正常转为对象，但是这个就是不行，怎么办？\r\n\r\n答：\r\n看看请求 的 Response 里返回的数据是不是有小红点？如果有小红点 说明是 返回数据格式有问题。\r\n官方的加密数据解密算法PHP - SDK里的三个文件有带BOM头，要去除\r\n\r\n\r\n\r\n\r\n\r\n\r\n问题：多人开发代码版本同步 \r\n请问如何多人开发，同步代码？\r\n答：\r\n用第三方工具开发，用开发者工具预览，用git同步代码\r\n\r\n\r\n\r\n\r\n问题：小程序不能使用nodejs的模块吗\r\n我想用那个解密的例子。但是提示buffer无法引入。\r\n答：\r\n不能用node_modules方式，您可以把关键文件提取出来放在小程序目录下进行引用\r\n\r\n\r\n\r\n\r\n问题：\r\napp.js 获取登陆session的请求 \r\n微信开发工具可以正常请求  但是真机测试请求好像发不出去 后台没有收到请求  微信调试只显示 request begin 就没了\r\n\r\n答：\r\n有没有用es6的语法？\r\n建议在app.js中添加onError的方法输出错误"}
{"title": "小程序的持续集成方案 ", "author": "Rolan", "pub_time": "2018-8-2 00:08", "content": "半年前，有机会开始接触微信小程序开发。却因为只是接触而并没投入开发小程序的过程中，因此对很多小程序的细节并未有充分的理解，仅仅停留在了解类似的理论层面，比如mpvue修改了 Vue.js 的 runtime 和 compiler 实现了编译及运行在原生小程序能力，比如原生小程序不支持npm包的使用及管理等，当然那时候的技术细节难点都是由非常给力的好同事解决消化了，所以也没多去细究。最近，我开始投入到完成的小程序开发迭代里，却发现一个头痛的问题，如何准确并快速的的把小程序上传去后台，并让测试人员进行测试。问题当遇到多个开发人员并行开发不同功能模块的同一小程序，往往就会遇到测试人员需要进行测试的时候，让开发人员切换至测试分支后，进行构建编译和上传，最终把上传后生产的二维码提供出来进行测试使用。若当前开发人员在认真coding，为某个功能正在奋斗。突然被别人打断并告诉你需要为他提供一个测试环境的二维码….因为为了这个二维码，需要做的事情是：git stashgit checkout branchnpm installnpm run build点击“预览”，生成二维码，或点击上传，更新体验版提供二维码出去后，恢复刚刚的工作状态git checkout branchgit stash popnpm installnpm run dev不断回想刚刚的开发思路理想流程上面所说的，只是一个常见的场景，但是思考一下，这个场景的重复率是否很高，重复这类操作的价值究竟有多少？为了解决不让开发人员为了一个测试环境的二维码而痛苦，我尝试把gitlab ci 和 微信开发者工具的能力进行对接尝试。在理想的流程里，开发人员只需要针对对应的分支进行合并或提交即可，无需关心如何把项目编译及版本分发交付到测试或体验人员手上。接下来，对项目分支的管理不展开过多的说明，只设定develop分支是自动触发小程序持续集成（ 安装依赖、构建、上传至体验版本 ）的目标。微信开发者工具微信开发者工具有提供5个接口能力，并且提供cli 和 http方式调用：命令行启动工具命令行登录命令行提交预览命令行上传代码支持自动化测试由于这次目标只需要把对应develop分支的代码上传微信更新为体验版本，所以微信开发者工具的接口能力最主要的是第4个（命令行上传代码）。如果是功能分支也需要创建预览二维码，可以通过第3个接口能力实现cli和http的调用有什么区别cli方式通过命令行调用安装完成的工具可执行文件，完成登录、预览、上传、自动化测试等操作。调用返回码为 0 时代表正常，为 -1 时错误。 命令行工具所在位置： macOS: <安装路径>/Contents/Resources/app.nw/bin/cli Windows: <安装路径>/cli.bathttp 方式http 服务在工具启动后自动开启，HTTP 服务端口号在用户目录下记录，可通过检查用户目录、检查用户目录下是否有端口文件及尝试连接来判断工具是否安装/启动。 端口号文件位置： macOS : ~/Library/Application Support/微信web开发者工具/Default/.ide Windows : ~/AppData/Local/微信web开发者工具/User Data/Default/.ide说白了，cli可以直接通过调用命令行工具，而http需要先寻找端口再进行接口调用，更适合跨机器调用。 根据我当前情况，选择了cli方式。设置构建机器公司的Mac mini 类似的机器暂时没有资源，不得不回到Windows上进行构建机的设置。但是坑还是挺多，可能一方面也是对windows的不熟悉吧。最后还是选择在Windows上装vmware，在vmware上运行Mac os。在Mac上面，安装微信开发者工具，如何下载安装就没必要多说了。接下来还需要安装gitlab runner，gitlab runner是用来运行你定制的任务（jobs）并把结果返回给 GitLab。 GitLab Runner 配合GitLab CI（GitLab 内置的持续集成服务） 协调完成任务。详情可以查看后面的引用文章。在Mac上安装gitlab runner最简单的是用brew，当然另外下载应用包也是可以的brew install gitlab-runner # 安装gitlab runner\r\nbrew services start gitlab-runner # 开机自动运行\r\ngitlab-runner start # 只需要直接运行（不需要开机自动运行）\r\n复制代码安装完成后，可以进行runner的配置，主要需要提供gitlab url，项目仓库的token，runner tags等，详细信息请参考 Registering Runners | GitLab 中文文档gitlab-runner register \r\n复制代码编写CI文件CI文件编写，最主要是项目根目录上创建一个名为.gitlab-ci.yml，每一行的stages:\r\n  - build # 总体CI的过程，暂时只有一个job：build\r\n\r\nbefore_script:\r\n  - shopt -s expand_aliases # 开启扩展aliases功能 issue https://gitlab.com/gitlab-org/gitlab-runner/issues/1083\r\n  - alias wxcli=\"/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli\" # 指定微信开发者工具cli命名为wxcli\r\n  - type wxcli # 验证wxcli命令是否存在\r\n  - wxcli # 启动微信开发者工具（其实好像有点多余，因为如果当前没启动微信开发者工具，在wxcli -u的时候也会启动）\r\n  - source ~/.bash_aliases # 读取特点的alias，比如配置的nvm，issue https://gitlab.com/gitlab-org/gitlab-runner/issues/1958 \r\n  - npm install # 安装依赖\r\n\r\n# 测试环境\r\ntest-build:\r\n  stage: build # 对应stages上的job名称\r\n  script:\r\n    - npm run build\r\n    - curr_commit_content=`git log -1 --pretty=format:%s` # 获取最近提交的git内容\r\n    - curr_version=`node -p \"require('./package.json').version\"` # 获取package的版本号\r\n    - curr_proj_path=`pwd` # 当前项目路径\r\n    - wxcli -u $curr_version@$curr_proj_path --upload-desc $curr_commit_content # 提交微信开发者\r\n\t  - # 上传成功后，你可以尝试发送一些通知提醒大家可以去打开新版本了，比如钉钉的webhook\r\n  only:\r\n    - develop\r\n  tags:\r\n    - xxx_mp\r\n\r\n复制代码查看构建结果查看构建结果也是很简单，直接在gitlab仓库里的CI/CD —— pipeline 进行查看测试人员和体验人员可以从小程序开发助手上查看最新体验版（记得要在微信小程序后台把该CI用户上传的版本设定成体验版）真的不要再去做重复的工作，太影响心情了。"}
{"title": "微信小程序商品筛选，侧方弹出动画选择页面 ", "author": "Rolan", "pub_time": "2018-12-29 00:32", "content": "微信小程序商品筛选，侧方弹出动画选择页面，在一点点的零碎的时间里面写出来的代码，和前两篇效果结合出来的。点击按钮的同时，要实现这两个功能的叠加。 小程序动画animation向左移动效果：https://www.jianshu.com/p/1cdf36070205 小程序点击按钮出现和隐藏遮罩层：https://www.jianshu.com/p/1193bf63a87d效果是这样的:demo是这样的：wxml<view class=\"\">  <view class=\"animation-button\" bindtap=\"translate\">筛选</view>  <view class=\"float {{isRuleTrue?'isRuleShow':'isRuleHide'}} \">    <view class=\"animation-element\" animation=\"{{animation}}\">      <view class='use'>        <view class='iconuse'>用途</view>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">全部</li>          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">豪华发烧型</li>          <li>疯狂游戏型</li>          <li>商务办公型</li>        </ul>        <ul class=\"useage\">          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>      </view>      <!-- 价格 -->      <view class='use'>        <view class='iconprice'>价格</view>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">全部</li>          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>        <ul class=\"useage\">          <li bindtap=\"tryDriver\" style=\"background:{{background}};\">豪华发烧型</li>          <li>疯狂游戏型</li>          <li>商务办公型</li>        </ul>        <ul class=\"useage\">          <li>经济实惠型</li>          <li>家用学习型</li>        </ul>      </view>      <view class='buttom'>      <view class=\"animation-reset\" >重置</view>      <view class=\"animation-button\" bindtap=\"success\">完成</view>      </view>    </view>  </view></view>wxss.isRuleShow {  display: block;}.isRuleHide {  display: none;}.float {  height: 100%;  width: 100%;  position: fixed;  background-color: rgba(0, 0, 0, 0.5);  z-index: 2;  top: 0;  left: 0;  /* margin-top:80rpx; */}.iconuse {  margin-left: 11rpx;}.iconprice {  margin-left: 11rpx;}.animation-element {  width: 580rpx;  height: 1175rpx;   background-color: #ffffff;   border: 1px solid #f3f0f0;  position: absolute;  right: -572rpx;}.useage {  height: 40rpx;}.useage li {  width: 177rpx;  margin: 12rpx 7rpx;  height: 70rpx;  line-height: 70rpx;  display: inline-block;  text-align: center;  border: 1px solid #f3f0f0;  border-radius: 15rpx;  font-size: 30rpx;}.buttom{  position: fixed;  bottom: 0;}.animation-reset{float: left; line-height: 2;  width: 260rpx;  margin: 15rpx 12rpx;  border: 1px solid #f3f0f0;  text-align: center;}.animation-button{float: left; line-height: 2;  width: 260rpx;  margin: 15rpx 12rpx;  border: 1px solid #f3f0f0;  text-align: center;}jsPage({  onReady: function () {    this.animation = wx.createAnimation()  },  translate: function () {    this.setData({      isRuleTrue: true    })    this.animation.translate(-245, 0).step()    this.setData({ animation: this.animation.export() })  },  success: function () {    this.setData({      isRuleTrue: false    })    this.animation.translate(0, 0).step()    this.setData({ animation: this.animation.export() })  },  tryDriver: function () {    this.setData({      background: \"#89dcf8\"    })  }})ok完成了，今天再说一点，有人问我关于技术博客日更的事情，一来是参加了简书的日更活动，不想断开，二来是一路走来，能看见自己每天学习到的知识点和解决的问题，所以才会感到很充实，不会觉得自己每天在空空度日。如果你也想坚持一件事情，可以私聊我，我们相互监督，互相帮助，让自己变得更好。原文作者：祈澈姑娘 技术博客：https://www.jianshu.com/u/05f416aefbe1 90后前端妹子，爱编程，爱运营，爱折腾。 坚持总结工作中遇到的技术问题，坚持记录工作中所所思所见，对于博客上面有不会的问题，可以加入qq群聊来问我：473819131。"}
{"title": "微信小程序云开发之云函数创建 ", "author": "Rolan", "pub_time": "2019-1-3 00:07", "content": "云函数云函数是一段运行在云端的代码，无需管理服务器，在开发工具内编写、一键上传部署即可运行后端代码。小程序内提供了专门用于云函数调用的 API。开发者可以在云函数内使用 wx-server-sdk 提供的 getWXContext 方法获取到每次调用的上下文（appid、openid 等），无需维护复杂的鉴权机制，即可获取天然可信任的用户登录态（openid）。1. 云函数创建根据官网提示，创建一个云函数，命名为 add， 功能是将 a , b 两数相加，步骤如下：在文件夹 cloudfunctions 目录下创建文件夹 add, 编辑add中的index.js文件：// 云函数入口文件\r\nconst cloud = require('wx-server-sdk') \r\n\r\n// 云函数入口函数\r\nexports.main = async (event, context) => {\r\n  console.log(event)\r\n  console.log(context)\r\n\r\n  const {a, b} = event\r\n  const {OPENID, APPID} = cloud.getWXContext() // 这里获取到的 openId 和 appId 是可信的\r\n  const sum = a + b\r\n\r\n  return {\r\n    OPENID,\r\n    APPID,\r\n    sum\r\n  }\r\n}在小程序中调用这个云函数前，我们还需要先将该云函数部署到云端。在云函数目录上右键，在右键菜单中，我们可以将云函数整体打包上传并部署到线上环境中。2. 云函数调用部署完成后，我们可以在小程序中调用该云函数：//小程序端调用方法\r\nwx.cloud.callFunction({\r\n  // 需要调用的云函数名\r\n  name: 'sum',\r\n  // 传给云函数的参数\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n  success: function(res) {\r\n    console.log(res.result.sum) // 3\r\n  },\r\n  fail: function(err) {\r\n      console.log(err)\r\n  }\r\n})\r\n也可以使用 Promise 调用方式：wx.cloud.callFunction({\r\n  // 云函数名称\r\n  name: 'add',\r\n  // 传给云函数的参数\r\n  data: {\r\n    a: 1,\r\n    b: 2,\r\n  },\r\n}).then(res => {\r\n    console.log(res.result) // 3\r\n  })\r\n  .catch(console.error)"}
{"title": "微信小程序评论/留言功能，附：前端+后端代码+视频讲解！ ", "author": "Rolan", "pub_time": "2018-9-18 00:27", "content": "前端界面：演示：<!-- 表单 -->\r\n<form bindsubmit=\"formSubmit\">\r\n<input type=\"text\" name=\"liuyantext\" placeholder='输入留言内容' class=\"input-style\"/>\r\n<button formType=\"submit\" class=\"btn\" wx:if=\"{{nickName == empty}}\" open-type=\"getUserInfo\" bindgetuserinfo=\"bindGetUserInfo\" bindtap='login'>授权登录</button>\r\n<button formType=\"submit\" class=\"btn\" wx:else>留言</button>\r\n<input type=\"text\" name=\"nickname\" value='{{nickName}}' style=\"display:none;\"/>\r\n<input type=\"text\" name=\"headimg\" value='{{avatarUrl}}' style=\"display:none;\"/>\r\n</form>\r\n\r\n<view wx:for=\"{{re}}\" wx:key=\"re\">\r\n  <view class=\"result\">{{item.result}}</view>\r\n</view>\r\n<view style=\"text-align:center;font-size:14px;color:#ccc;margin-top:20px;\">以下是留言内容</view>\r\n<view wx:for=\"{{liuyanlist}}\" wx:key=\"liuyanlist\" class=\"liuyanview\">\r\n  <view class=\"headimg\"><image src=\"{{item.headimg}}\"></image></view>\r\n  <view class=\"nickname_liuyantext\">\r\n    <view class=\"nickname\">{{item.nickname}} <view class=\"time\">{{item.lytime}}</view></view>\r\n    <view class=\"text\">{{item.liuyantext}}</view>\r\n  </view>\r\n  <!-- 占位符 -->\r\n  <view style=\"width:100%;height:10px;\"></view>\r\n</view>\r\n//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\nPage({\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    \r\n  },\r\n\r\n  //授权登录\r\n  login: function () {\r\n    var that = this;\r\n    // 查看是否授权\r\n    wx.getSetting({\r\n      success(res) {\r\n        if (res.authSetting['scope.userInfo']) {\r\n          // 已经授权，可以直接调用 getUserInfo 获取头像昵称\r\n          wx.getUserInfo({\r\n            success: function (res) {\r\n              console.log(res.userInfo),\r\n                that.setData({\r\n                  nickName: res.userInfo.nickName,\r\n                  avatarUrl: res.userInfo.avatarUrl,\r\n                })\r\n            }\r\n          })\r\n        }\r\n      }\r\n    })\r\n  },\r\n  bindGetUserInfo(e) {\r\n    console.log(e.detail.userInfo)\r\n  },\r\n\r\n\r\n  formSubmit: function (e) {\r\n    wx.showToast({\r\n      title: '已留言',\r\n      icon: 'success'\r\n    })\r\n    var that = this;\r\n    var liuyantext = e.detail.value.liuyantext; //获取表单所有name=liuyantext的值 \r\n    var nickName = e.detail.value.nickname; //获取表单所有name=nickName的值 \r\n    var headimg = e.detail.value.headimg; //获取表单所有name=headimg的值 \r\n    wx.request({\r\n      url: 'http://localhost/liuyanserver/liuyan.php?liuyantext=' + liuyantext + '&nickname=' + nickName + '&headimg=' + headimg,\r\n      data: {\r\n        liuyantext,\r\n        nickName,\r\n        headimg\r\n      },\r\n      header: { 'Content-Type': 'application/json' },\r\n      success: function (res) {\r\n        console.log(res.data)\r\n        that.setData({\r\n          re: res.data,\r\n        })\r\n        wx.hideToast();\r\n      }\r\n    })\r\n  },\r\n\r\n  onPullDownRefresh: function () {\r\n    wx.showNavigationBarLoading();\r\n    var that = this\r\n    wx.request({\r\n      url: 'http://localhost/liuyanserver/loadliuyan.php',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n        //将获取到的json数据，存在名字叫list的这个数组中\r\n        that.setData({\r\n          liuyanlist: res.data,\r\n          //res代表success函数的事件对，data是固定的，liuyanlist是数组\r\n        })\r\n        // 隐藏导航栏加载框\r\n        wx.hideNavigationBarLoading();\r\n        // 停止下拉动作\r\n        wx.stopPullDownRefresh();\r\n      }\r\n    })\r\n  },\r\n\r\n  //加载最新数据\r\n  onLoad: function () {\r\n    var that = this\r\n    wx.request({\r\n      url: 'http://localhost/liuyanserver/loadliuyan.php',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n        //将获取到的json数据，存在名字叫list的这个数组中\r\n        that.setData({\r\n          liuyanlist: res.data,\r\n          //res代表success函数的事件对，data是固定的，liuyanlist是数组\r\n        })\r\n      }\r\n    })\r\n  }\r\n})/**index.wxss**/\r\n.input-style{\r\n  width: 90%;\r\n  height: 50px;\r\n  border:1px solid #ccc;\r\n  margin:10px auto;\r\n}\r\n\r\n.btn{\r\n  width: 88%;\r\n  margin:5px auto;\r\n}\r\n\r\n.liuyanview{\r\n  width: 90%;\r\n  margin: 10px auto;\r\n}\r\n\r\n.result{\r\n  text-align: center;\r\n  font-size: 14px;\r\n  color: #f00;\r\n  margin-top: 20px;\r\n}\r\n\r\n.headimg{\r\n  width: 45px;\r\n  height: 45px;\r\n  border-radius: 100%;\r\n}\r\n\r\n.headimg image{\r\n  width: 45px;\r\n  height: 45px;\r\n  border-radius: 100%;\r\n}\r\n\r\n.nickname_liuyantext{\r\n  width: calc(100% - 55px);\r\n  float: right;\r\n  margin-top:-45px;\r\n}\r\n\r\n.nickname_liuyantext .nickname{\r\n  font-size: 15px;\r\n  color: #999;\r\n}\r\n\r\n.nickname_liuyantext .nickname .time{\r\n  font-size: 11px;\r\n  color: #999;\r\n  float: right;\r\n}\r\n\r\n.nickname_liuyantext .text{\r\n  font-size: 16px;\r\n  color: #666;\r\n}以上是前端部分后端有两个文件。点击下载后端，后端需要修改自己的数据库配置！http://www.youka.la/product/5...数据库格式：视频:https://www.lanzous.com/i1w1deb"}
{"title": "使用Taro框架开发小程序 ", "author": "Rolan", "pub_time": "2018-9-20 00:27", "content": "最近一直在做小程序项目的开发，上手直接就是wepy, 风格跟vue差不多，整体上，还算稳定，开发起来比原生的效率要高一点；很多人也知道，mpvue就是用vue搭建的，但始终觉得，失去了路由的vue，就像失去了灵魂；虽然接下来要给大家安利的框架，也貌似失去了该灵魂- taro框架（ Taro 是一套遵循React 语法规范的 多端开发 解决方案。）taro开发文档： nervjs.github.io/taro/docs/R…有兴趣的可以去看看，在这里我将我初步入坑的学习过程，以及构建了大致矿建与大家分享下：一：安装 Taro 开发工具 @tarojs/clinpm install -g @tarojs/cli\r\n复制代码二：使用命令创建模板项目taro init taro-react-mini-program\r\n复制代码可以根据自己的需要，选择是否使用ts, sass或者less, 接着等安装好依赖，项目就构建完成；三：项目目录结构├── dist                   编译结果目录\r\n├── config                 配置目录\r\n|   ├── dev.js             开发时配置\r\n|   ├── index.js           默认配置\r\n|   └── prod.js            打包时配置\r\n├── src                    源码目录\r\n|   ├── pages              页面文件目录\r\n|   |   ├── index          index页面目录\r\n|   |   |   ├── index.js   index页面逻辑\r\n|   |   |   └── index.css  index页面样式\r\n|   ├── app.css            项目总通用样式\r\n|   └── app.js             项目入口文件\r\n└── package.json\r\n复制代码框架的使用和注意事项，文档中有介绍，我这边主要写一些项目配置和踩过的坑;这里需要先安装一些依赖npm install tslint stylelint tslint-config-prettier -D\r\n复制代码代码规范 .prettierrc{\r\n    \"stylelintIntegration\": true,\r\n    \"tslintIntegration\": true,\r\n    \"tabWidth\": 2,\r\n    \"singleQuote\": true,\r\n    \"semi\": false\r\n}\r\n复制代码.prettierignore/**/libs/**\r\ndist/\r\nlib/\r\n复制代码样式规范： .stylelintrc.jsmodule.exports = {\r\n  ignoreFiles: ['**/*.md', '**/*.ts', '**/*.tsx', '**/*.js']\r\n}\r\n复制代码.stylelintignore**/dist\r\n复制代码tslint.json{\r\n  \"extends\": [\"tslint:recommended\", \"tslint-config-prettier\"],\r\n  \"rules\": {\r\n    \"ordered-imports\": false,\r\n    \"object-literal-sort-keys\": false,\r\n    \"member-access\": false,\r\n    \"member-ordering\": false,\r\n    \"no-empty-interface\": false,\r\n    \"no-console\": [true, \"warning\"],\r\n    \"interface-name\": [true, \"never-prefix\"],\r\n    \"no-empty\": false,\r\n    \"quotemark\": [true, \"single\"]\r\n    // \"semicolon\": [false], // 结尾比较分号\r\n    // \"trailing-comma\": [false], // 结尾必须逗号\r\n    // \"requireForBlockBody\": true,\r\n  }\r\n}\r\n复制代码接着配置git的提交commit提交验证，需要安装对应的依赖包，可以从我的另外一篇文章看：juejin.im/post/5b9867…再加上自己配置一个.gitignore文件，就这样，我们将大致需要的配置文件都配置好了；看看效果：当有不规范的代码提交的时候把所有问题都解决之后提交，当然tslint以及其他的一些配置都是自定义的，可以自己配置。觉得麻烦的可以根据自己的“口味”配置项目然后我们就可以愉快的开发我们的项目，运行npm run dev:weapp,打开我们的小程序很多人反馈用原生的 Taro.request或者用第三方axios等等做异步请求总会有错，我没亲测，但是自己用promise封装了方法, 在根目录src文件夹下创建utils文件夹， 在这里我简单的模拟微信授权登录，以及检测session是否过期，绑定用户的场景写一个大概例子，接口为虚构：├── utils                 \r\n|   ├── api.ts            请求接口设置\r\n|   ├── http.ts           http公共请求文件\r\n|   └── index.ts          \r\n\r\n复制代码http.ts代码如下：import Taro from '@tarojs/taro'\r\nimport md5 from 'blueimp-md5'\r\n\r\ntype HttpMethods = 'GET' | 'POST' | 'PUT' | 'DELETE'\r\n\r\n// 后端是否支持json格式\r\nconst contentType = 'application/x-www-form-urlencoded'\r\n// const contentType = 'application/json'\r\n\r\nexport default class Http {\r\n  noNeedToken = ['mockFakeApi']\r\n\r\n  get(url: string, data: object) {\r\n    return this.commonHttp('GET', url, data)\r\n  }\r\n\r\n  post(url: string, data: object) {\r\n    return this.commonHttp('POST', url, data)\r\n  }\r\n\r\n  async commonHttp(method: HttpMethods, url: string, data: object) {\r\n    return new Promise<any>(async (resolve, reject) => {\r\n      Taro.showNavigationBarLoading()\r\n      try {\r\n        const res = await Taro.request({\r\n          url,\r\n          method,\r\n          data,\r\n          header: {\r\n            'content-type': contentType\r\n          }\r\n        })\r\n        Taro.hideNavigationBarLoading()\r\n        switch (res.statusCode) {\r\n          case 200:\r\n            return resolve(res.data.response)\r\n          default:\r\n            console.log(res.data.message)\r\n            reject(new Error(res.data.msg))\r\n        }\r\n      } catch (error) {\r\n        Taro.hideNavigationBarLoading()\r\n        reject(new Error('网络请求出错'))\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\n复制代码api.tsimport Http from './http'\r\n\r\nconst http = new Http()\r\n\r\n//  自动登录\r\nconst url = 'xxxxx'\r\nexport const login = (data: object) => http.post(url, data)\r\n\r\n复制代码index.ts (自定义公共处理接口文件)import Taro from '@tarojs/taro'\r\nimport { login } from './api'\r\n\r\n// 获取微信登录凭证\r\nexport const wxLogin = async () => {\r\n  try {\r\n    const res = await Taro.login()\r\n    return res.code\r\n  } catch (error) {\r\n    console.log('微信获取临时凭着失败')\r\n  }\r\n}\r\n\r\nexport const userLogin = async () => {\r\n  try {\r\n    await Taro.checkSession()\r\n    if (!Taro.getStorageSync('token')) {\r\n      throw new Error('本地没有缓存token')\r\n    }\r\n  } catch (error) {\r\n    const code = await wxLogin()\r\n    const loginRes: any = await login({\r\n      code\r\n      // ...(其他参数)\r\n    })\r\n    console.log('用户数据', loginRes)\r\n  }\r\n}\r\n\r\n复制代码最后在pages/index/index.tsx中引用就好了import { userLogin } from '../../utils/index'\r\n\r\n....\r\n\r\nasync componentDidMount() {\r\n    await userLogin()\r\n  }\r\n复制代码整个框架的使用大致就是这样了，react的书法风格还是挺舒服的，如果习惯了vue的写法可能刚开始会不习惯，有兴趣的可以尝试尝试，下面再简单的把一些小技巧给补上：一：图片以模块的方式的引入使用ts搭建的项目，引入静态资源，比如图片，会提示找不到模块，这时候就必须将图片声明为一个模块：在types目录的global.d.ts文件下:declare module ‘*.png’ {​ const img: any​ export default img}二：动态添加style<View style={{backgroundImage: `url(${bgImg})`}}></View>\r\n复制代码三：动态添加class1.<View className={data.length>0?’class-yes’: ’class-no'}></View>\r\n\r\n2.<View className={`common ${data.length>0?’class-yes’: ’class-no}`}></View>\r\n复制代码四：this的指向问题1）在 Taro 的页面和组件类中， this 指向的是 Taro 页面或组件的实例,如果我们要引用原生组件，需要使用到this的时候，如果如下引用：Taro.createCanvasContext(canvasId, this.$scope)\r\nwx.createLivePlayerContext(liveId, this.$scope)\r\n错误：wx.createLivePlayerContext(liveId, this)这样引入是没有效果的，this并不是指向 wx.createLivePlayerContext.(当前版本没有liveplayer的回调方法，所以直接用原生wx)"}
{"title": "微信小程序开发手记《六》：API ", "author": "天下雪", "pub_time": "2017-4-25 00:12", "content": "作者：王梵，来自授权地址准备工作API中有关于网络的接口，需要配置合法域名，如果不想配置，可以直接在开发工具中设置，如下图 如果没有在开发工具中设置，也没有设置合法域名，运行时爆出如下错误 wx.request该API既支持http请求，也支持https请求。对于网络请求，小程序大大减轻了我们的工作量，不需要再次解析json，只需要将data的结构设置的与返回的json即可。Page({\r\n\r\n    onLoad:function(e){\r\n\r\n      var that = this\r\n\r\n      wx.request({\r\n        url: 'http://web.juhe.cn:8080/environment/air/cityair?city=beijing&key=.....自己的key....',\r\n        data: {},\r\n        method: 'GET', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT\r\n        // header: {}, // 设置请求的 header\r\n        success: function(res){\r\n          // success\r\n          console.log(\"statusCode:\"+res.statusCode);\r\n\r\n          var dataBean = res.data\r\n          console.log(\"success\",dataBean.resultcode)\r\n          console.log(\"success\",dataBean.reason)\r\n          that.setData({\r\n             \"resultcode\":dataBean.resultcode,\r\n               \"reason\":dataBean.reason,\r\n               \"error_code\":dataBean.error_code,\r\n             \"result\":dataBean.result\r\n          })\r\n        },\r\n        fail: function(res) {\r\n          // fail\r\n          console.log(\"faile\")\r\n        },\r\n        complete: function(res) {\r\n          // complete\r\n          console.log(\"complete\")\r\n        }\r\n      })\r\n    },\r\n    data:{\r\n      \"resultcode\":\"\",\r\n        \"reason\":\"\",\r\n        \"error_code\":0,\r\n        \"result\":[\r\n            {\r\n                \"citynow\":{\r\n                    \"city\":\"\",\r\n                    \"AQI\":\"\",\r\n                    \"quality\":\"\",\r\n                    \"date\":\"\"\r\n              },\r\n                \"lastTwoWeeks\":{\r\n                    \"1\":{\r\n                        \"city\":\"\",\r\n                        \"AQI\":\"\",\r\n                        \"quality\":\"\",\r\n                        \"date\":\"\"\r\n                  }\r\n\r\n                }\r\n            }\r\n        ]\r\n    }\r\n\r\n})1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\n洪锦中\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序开发手记《五》：组件 \n              微信小程序语音录制和播放的一些坑，ios 和 android 的 布局兼容问题 ... \n            \n             \n            \n                  原作者: 王梵 \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序开发手记《一》：项目的代码结构\n                                    \n                  • 微信小程序开发手记《二》：属性display\n                                    \n                  • 微信小程序开发手记《三》：backgroud和border属性\n                                    \n                  • 微信小程序开发手记《四》：视图容器\n                                    \n                  • 微信小程序开发手记《五》：组件\n                                    \n                  • 微信小程序开发手记《七》：上线后的总结（上）\n                                    \n                  • 微信小程序开发手记《八》：上线后的总结（下）\n                                    \n                  • 微信小程序--数据缓存API整理\n                                    \n                  • 微信小程序--外部API调用方法遇到的一个小问题\n                                    \n                  • 以微信小程序为例学习网站开发平台API调用\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSpqcH4h', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n微信小程序开发早知道2019-04-04\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880729|21a829fda2197c34653786a20f9aa4d9|2';"}
{"title": "微信小程序~云开发的实现的一个社区 Demo ", "author": "Rolan", "pub_time": "2019-3-28 00:48", "content": "官方介绍文档开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发为开发者提供完整的云端支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。目前提供三大基础能力支持：云函数：在云端运行的代码，微信私有协议天然鉴权，开发者只需编写自身业务逻辑代码数据库：一个既可在小程序前端操作，也能在云函数中读写的 JSON 数据库存储：在小程序前端直接上传/下载云端文件，在云开发控制台可视化管理实现的功能由于是 Demo 所以有些功能没实现完整，后续时间充足会补充完整。用户登录后将用户信息保存在云数据库，方便下次读取发布话题成功后将数据保存在云数据库，在首页列表页面可读取展示获取云数据库列表展示本地图片获取和预览等广场显示用户发布的内容管理员发布的一些教程（这块想通过banner 来展示，在后续版本会添加，目前就先这样了…）实现分析可点击下边的博文链接：微信小程序~云开发Demo 实现数据的添加、查询和分页实现发布发布图文水平图片的滑动显示（效果不是很好，有时间会改为九宫格实现）发布页面效果如下：实现分析可点击下边的博文链接：微信小程序~云开发 Demo 实现发表页面我的1、显示用户的登录信息主要就是调用小程序接口，获取用户的微信公开信息进行展示2、用户的收藏列表获取数据库中的收藏列表进行展示3、发布历史在发布页面，当发布成功将数据存到发布历史表中，需要的时候获取该表的数据进行展示4、邀请好友调用小程序的分享接口，直接分享给微信群，或者个人5、产品意见一个类似于发布页的页面，实现思路和发布页实现是一样的。实现的效果实现分析可点击下边的博文链接：微信小程序~新版授权用户登录例子可能存在的一些问题1、其他用户发布的内容，有时候显示不出来？将数据库的权限设置为全部人可见2、发布内容之后返回首页没有自动刷新？在广场首页 onShow 的时候获取数据库的数据进行展示3、clone 源码后运行不起来？需要在自己的云数据库中创建对应的表源码地址：方便的话点个 Star，多谢~https://github.com/dongxi346/doughnut---------------------"}
{"title": "微信小程序开发问答《七十四》Math.js如何引入 &  表单无法提交 ... ", "author": "Rolan", "pub_time": "2017-9-19 07:59", "content": "1、微信小程序编辑器bug：wx.showToast下image无法识别同名图片文件的更改示例：  wx.showToast({\r\n          title: 'xxx',\r\n          image: '../images/fail.svg',\r\n          duration: 'xxx'\r\n        })12345发现如下问题：当引用fail.svg时，不论手动修改fail.svg文件；还是直接更换另一个图片文件，仍将其命名为fail.svg，编辑器都无法识别文件的更改。即，无论如何更改，显示的图片都相同，是第一个fail.svg文件。当更换文件名字，如改为fail.png时，更改后，编辑器才会显示出更换后的图片。再对名为fail.png的文件进行更改，则情况同上一条。应对措施当对图片文件更改后（不改文件名），只有重启编辑器，才能正确显示一次。2、调用模板时，模板中的表单无法提交情况是这样的，我做了一个简单的表单模板<template name='form1'>\r\n  <form bindsubmit='formsubmit'>\r\n    <input name='name'></input>\r\n    <button form-type='submit'>提交</button>\r\n  </form>\r\n</template>然后在调用这个模板时发现“提交”按钮无效。不太理解的是，我在页面中如果不采用调用temlate的方式，提交按钮就正常。请教了答：原因找到了，是因为我在css中多了一个view图层，影响了button的点击。3、Math.js如何引入到微信小程序?微信小程序里面想引用Mathjs 做数学运算，发现小程序没有window对象，没法外链形式引入，于是将Math.js下载下来，放进utils文件夹里面引到其他js报错 这是 mathjs 可以npm node形式使用 按理来说可以 在小程序里面用得 但是报错了 求解答：1.路劲对不对2.有没有小程序的export3.原本的deinfe等判断方法全都去掉4、微信小程序中canvas的滚动问题但是滚动画布不动这种情况现在能解决么答：1.这个插件支不支持滚动2.如果支持，是不是事件没有触发3.是不是浏览器的默认行为阻止了4.如果不支持，判断滑动，重新渲染数据试试5.换一个插件"}
{"title": "微信小程序框架wxss--电话列表展示demo ", "author": "Rolan", "pub_time": "2017-12-27 00:29", "content": "今天好冷，躲在客厅瑟瑟发抖的学习小程序。先看一下效果图↓\r\n准备工作：在pages目录下新建一个wxss2文件夹，并在app.json中进行注册，会自动生成wxss.js等四个文件。1.我们先看看wxml样式的编写\r\n<view class=\"container list-container\">   <view class=\"list-item\">     <image class=\"left\" src=\"../../resources/headImg.jpg\"></image>     <view class=\"right\">       <view class=\"title\">         <view class=\"name\">name</view>         <view class=\"phone\">phone</view>       </view>       <view class=\"time\">time</view>     </view>   </view>  lt;/view>   \r\n（1）container & list-container①container在app.wxss中进行定义，作用于全局\r\n.container {    height: 100%;    display: flex;    flex-direction: column;    align-items: center;    justify-content: space-between;    padding: 200rpx 0;    box-sizing: border-box;  }  \r\n②list-container在wxss2.wxss中，主要目的是重新padding，覆盖container中的参数\r\n.list-container{    padding: 0  }  \r\n（3）最外层view的效果图\r\n2.一个item的编写\r\n可以结合两张图片，理解view对应的部分，在这里不一一说明，贴上wxss的代码↓\r\n.list-container{    padding: 0  }  .list-item{    height: 100rpx;    display: flex;    flex-direction: row;    padding:20rpx;  }  .left{    width: 100rpx;    height:100rpx;  }  .right{    width: 590rpx;    height: 100rpx;    margin-left: 20rpx;    display: flex;    flex-direction: row;  }  .title{    flex: 1;    display: flex;    flex-direction: column;    width: 310rpx;  }  .name{    font-size: 50rpx;    color: #000;  }  .phone{    font-size: 35rpx;    color:darkgrey;  }  .time{    width: 200rpx;    color: #aaa;    font-size: 30rpx;  }  \r\n①list-item和right样式中，决定其包裹的内容水平分布\r\ndisplay: flex;  flex-direction: row;  \r\n②title样式中，决定其包裹的内容竖直分布↓\r\ndisplay: flex;  flex-direction: column;  \r\n此外，flex：1表示按照分布方式剩余的空间都分配给title。如该例中，right宽度为590rpx，time的宽度为200rpx，因此title的宽度为590-200=390rpx；\r\n3.多个item项的编写，我们需要在js文件中定义一个数组contactList↓\r\nPage({    data: {      contactList:[{        \"name\":\"Crab\",        \"phone\":\"15566667777\",        \"time\":\"2017-10-14\"      },{          \"name\": \"Emily\",          \"phone\": \"15566668888\",          \"time\": \"2017-10-13\"      },{          \"name\": \"Rachel\",          \"phone\": \"15566669999\",          \"time\": \"2017-10-10\"      },{        \"name\": \"Crab2\",        \"phone\": \"15566667777\",        \"time\": \"2017-10-14\"      }, {        \"name\": \"Emily2\",        \"phone\": \"15566668888\",        \"time\": \"2017-10-13\"      }, {        \"name\": \"Rachel2\",        \"phone\": \"15566669999\",        \"time\": \"2017-10-10\"      }, {        \"name\": \"Crab3\",        \"phone\": \"15566667777\",        \"time\": \"2017-10-14\"      }, {        \"name\": \"Emily3\",        \"phone\": \"15566668888\",        \"time\": \"2017-10-13\"      }, {        \"name\": \"Rachel3\",        \"phone\": \"15566669999\",        \"time\": \"2017-10-10\"      }]    }  })  \r\n修改wxml中部分代码， 循环访问数组↓，可以得到最开始的效果图。\r\n就记录到这里啦~ 晚安。"}
{"title": null, "author": null, "pub_time": null, "content": ""}
{"title": "golang+json-iterator（微信小程序推送通知实例） ", "author": "Rolan", "pub_time": "2018-9-11 00:12", "content": "结构体如下：type WxPushContent struct {\r\n    Push_record_id   int    `json:\"push_record_id\"`\r\n    Template_id      string `json:\"template_id\"`\r\n    Page             string `json:\"page\"`\r\n    Data             Data   `json:\"data\"`\r\n    Emphasis_keyword string `json:\"emphasis_keyword\"`\r\n}\r\n\r\ntype Data struct {\r\n    Keyword1 WxKeyword `json:\"keyword1\"`\r\n    Keyword2 WxKeyword `json:\"keyword2\"`\r\n    Keyword3 WxKeyword `json:\"keyword3\"`\r\n}\r\n\r\ntype WxKeyword struct {\r\n    Value string `json:\"value\"`\r\n}实际代码如下：func ExecutePush_WX(ctx *gin.Context) {\r\n  var json_iterator = jsoniter.ConfigCompatibleWithStandardLibrary\r\n\r\n  jsonWxPushContent, _ := json_iterator.Marshal(models.WxPushContent{\r\n    Push_record_id:   note.Id,\r\n    Template_id:      setting.MINITemplateId,\r\n    Page:             \"/pages/detail?isShare=true&isFromPush=\" + strconv.Itoa(note.Id) + \"&id=\" + strconv.FormatInt(note.NewsId, 10),\r\n    Data:             models.Data{\r\n      Keyword1:models.WxKeyword{Value: \"热点新闻\"},\r\n      Keyword2:models.WxKeyword{Value: news.Title},\r\n      Keyword3:models.WxKeyword{Value: tt[0].Summary},\r\n    },\r\n    Emphasis_keyword: \"keyword1.DATA\"})\r\n  }\r\n\r\n  log.Println(\"小程序-加密前的参数: \", string(jsonWxPushContent))返回结果：{\r\n    \"push_record_id\":33,\r\n    \"template_id\":\"3OviTbpRI-7t8GJxlaoKtyQM6SuOXnROVk-jwj-T-GI\",\r\n    \"page\":\"/pages/detail?isShare=true&isFromPush=33&id=63688\",\r\n    \"data\":{\r\n        \"keyword1\":{\r\n            \"value\":\"热点新闻\"\r\n        },\r\n        \"keyword2\":{\r\n            \"value\":\"人工智能是否会颠覆传统电视行业？\"\r\n        },\r\n        \"keyword3\":{\r\n            \"value\":\"据了解，近日长虹再次与人工智能领先企业达观数据达成合作，将电视内容的个性化推荐引入智能电视，为用户更好的打造智慧家庭体系\"\r\n        }\r\n    }\r\n    \"emphasis_keyword\":\"keyword1.DATA\"\r\n}之后就是请求微信小程序api地址拉！"}
{"title": "微信小程序开发问答《七十六》canvas绘制图片模糊 & Math.js如何引入 ... ", "author": "Rolan", "pub_time": "2017-10-11 00:42", "content": "1、微信小程序中的canvas绘制图片截图，拿到的图片会模糊？需求是我在微信小程序中使用canvas把图片绘制到图中黑框区域，然后进行编辑操作最后拿到编辑后的图片，图片肯定不能小因为是要打印到衣服上的，但是用手机中黑框截图出来的图片肯定是有限的大小，当我要截图时，我发现使用wx.canvasToTempFilePath()这个api截图出来的图设置指定长宽就会糊掉，我在想一开始绘制的时候就已经把图片已经压缩，再放大肯定会糊的，该怎么解决这个问题？答：你的图片实际大小是大于canvas的大小的。比如你的图片是1200*800， 而你的canvas大小只有600*400。当你使用ctx.drawImage(src, 0, 0, 600, 400)后，你的图片就被压缩到了canvas的大小，就会造成截出来图片适量下降。方案1准备两个canvas，一个绘制压缩图(600400)，一个绘制原图大小(1200800)，截图的时候从原图canvas截取。方案2将canvas大小设为(1200*800)，使用css将canvas缩放到适应屏幕大小。2、微信小程序邀请好友给奖励，怎么去写这个能记录是谁通过点击转发的链接进入到小程序的参数码？答：1、生成的分享链接，带上一级用户的ID或者用户名作为参数。2、二级用户点击之后，将一级用户ID参数种在COOKIE或者session里面，同时保存一条点击记录进入数据库。3、后续二级用户的下单，注册，等等操作，都从COOKIE判断是否存在对应一级ID，并进行对应的奖励操作。3、小程序中为何无法获取setData中的值secondMenuAjax:function(){\r\n    var  _this=this\r\n    wx.request({\r\n        url: 'xxxx', //仅为示例，并非真实的接口地址\r\n      header: {\r\n        'content-type': 'application/json' // 默认值\r\n      },\r\n      success: function (res) {\r\n        // console.log(res.data)\r\n        // this.secondMenuData=res.data.data\r\n        _this.setData({\r\n          secondMenuData:res.data.data,\r\n          nowMenuData:res.data.data[0]\r\n        })\r\n        console.log(_this.secondMenuData)//undefined\r\n        \r\n      }\r\n    })我ajax请求中获得了数据然后setData数据，但是我再去console.log为什么是undefined。答：console.log(_this.secondMenuData)改为 console.log(_this.data.secondMenuData)4、Math.js如何引入到微信小程序?微信小程序里面想引用Mathjs 做数学运算，发现小程序没有window对象，没法外链形式引入，于是将Math.js下载下来，放进utils文件夹里面引到其他js报错 这是 mathjs 可以npm node形式使用 按理来说可以 在小程序里面用得 但是报错了 求解答：1.路劲对不对2.有没有小程序的export3.原本的deinfe等判断方法全都去掉函数需要导出才能用：/utils/test.jsfunction func() {\r\n    return 123\r\n}\r\n\r\nmodule.exports = {\r\n  func: func\r\n}引用：/pages/index/index.jsvar util = require(\"../../utils/test.js\") //相对路径"}
{"title": "微信小程序：拼图游戏 ", "author": "Rolan", "pub_time": "2018-8-23 00:42", "content": "微信小程序：拼图游戏源代码：https://github.com/lcp1551/lcpISfat游戏界面初始化游戏：游戏成功：思路&功能：1.初始化，将数字1~8存放在数组中，随机打乱后拼接一个9(空白格),修改空白格的样式2.点击数字，判断空白格对于其所在位置的方向，进行相应的上下左右移动3.上下左右移动，及把移动的两个数字互换在数组中的位置4.判断数组中元素是否是[1,2,3,4,5,6,7,8,9]，是则游戏成功，5.计时，利用定时器，结束，清除定时器代码：项目中所用到的数据：data: {        num: ['★', '★', '★', '★', '★', '★', '★', '★', '★'],   //初始化前        hidden: true,   //隐藏空白格中的数字        time:0,           //秒数        t:''                  //定时器  },复制代码构建页面：index.wxml<view class=\"container\">  <view class=\"row\" wx:for=\"{{num}}\" wx:for-item=\"item\" wx:for-index=\"index\">    <button class=\"btn {{item == 9?'active':''}}\" catchtap='onMoveTap'  data-item=\"{{item}}\" data-index=\"{{index}}\">{{item}}</button>  </view></view>复制代码需要传两个数据过去，一个是被点击块的下标index和块中的数字item动态为空白格[9]添加样式active{{item == 9?'active':''}}复制代码游戏初始化：init:function(){    this.setData({      num:this.sortArr([1,2,3,4,5,6,7,8]).concat([9])    })  },复制代码初始化的时候，这里用了sortArr(arr)打乱数组，并拼接个空白格[9]，这样让空白格初始化的时候永远处于最后一位。随机打乱数组:sortArr: function (arr) {    return arr.sort(function () {      return Math.random() - 0.5    })  }复制代码这里用了最简单的打乱方法，缺点就是打乱不完全给每个块添加点击事件onMoveTap:onMoveTap: function (e) {    var index = e.currentTarget.dataset.index;    var item = e.currentTarget.dataset.item;    if (this.data.num[index + 3] == 9) {      this.down(e);    }        if (this.data.num[index - 3] == 9) {      this.up(e);        }        if (this.data.num[index + 1] == 9 && index != 2 && index != 5) {            this.right(e);     }    if (this.data.num[index - 1] == 9 && index != 3 & index != 6) {       this.left(e);    }  }复制代码如果空白格的下标比所点击的块的下表大3，则表示空白格在所点击块的下方，那么点击后向下移动；如果空白格的下标比所点击的块的下表小3，则表示空白格在所点击块的上方，那么点击后向上移动；如果空白格的下标比所点击的块的下表大1，则表示空白格在所点击块的右方，那么点击后向右移动，需考虑点击快是否在容器右边缘；如果空白格的下标比所点击的块的下表小1，则表示空白格在所点击块的左方，那么点击后向左移动，需考虑点击快是否在容器左边缘；移动：以向上移动举例 up: function (e) {    var index = e.currentTarget.dataset.index; //当前数字下标    var temp = this.data.num[index];    this.data.num[index] = this.data.num[index - 3]    this.data.num[index - 3] = temp;    this.setData({      num: this.data.num    })        if (this.data.num.toString() == [1, 2, 3, 4, 5, 6, 7, 8, 9].toString()) {      this.success();    }  }复制代码移动后，将所点击块与空白格互换在数组中的位置，并判断目前的数组是否满足游戏成功的条件，判断数组相等，我这里把数组转化成字符串做的比较游戏成功：success: function () {    var that = this;    wx.showToast({      title: '闯关成功',      icon: 'success',      success: function () {        that.init();      }    })  }复制代码游戏成功，弹出交互反馈窗口，并初始化重新打乱数组定时器： timeCount:function(){    var that = this;    var timer = that.data.time;    that.setData({      t:setInterval(function(){        timer++;        that.setData({          time:timer       })      },1000)    })  }复制代码开始结束游戏： timeBegin:function(){    clearInterval(this.data.t);    this.setData({      time:0    })    this.timeCount();    this.init();  },  timeStop:function(){    clearInterval(this.data.t);    if (this.data.num.toString() != [1, 2, 3, 4, 5, 6, 7, 8, 9].toString()) {      this.fail();    }  }复制代码给开始按钮绑定timeBegin事件，初始化游戏给结束按钮绑定timeStop事件，判断是否游戏成功试玩:源代码：github.com/lcp1551/lcp…待开发：选择难度自传图片"}
{"title": "微信小程序专题之setData ", "author": "Rolan", "pub_time": "2018-6-29 00:26", "content": "Page.prototype.setDatasetData 函数用于将数据从逻辑层发送到视图层（异步），同时改变对应的 this.data 的值（同步）。setData() 参数格式setData(data, callback); // data需为可 JSON 化的数据，callback在 setData 对界面渲染完毕后调用setData() 非常灵活setData() 的第一个参数 data 是 Object 类型的数据，其中 key 可以非常灵活，可以以数据路径的形式给出，如 array[2].message，a.b.c.d，并且不需要在 this.data 中预先定义。下面举个例子来说明：index.jsPage({\r\n    data: {\r\n        userInfo: {\r\n            avatar: 'https://images.example.com/default_avatar.png'\r\n        },\r\n        articleList: [{title: 'init title'}]\r\n    },\r\n    onLoad: function () {\r\n        let avatar = 'https://images.example.com/avatar.png';\r\n        let newTitle = 'This is a new title';\r\n        \r\n        this.setData({\r\n            'userInfo.avatar': avatar,\r\n            'articleList[0].title': new Title\r\n        })\r\n    }\r\n})微信小程序这种给 setData 赋值的方式在原生 JavaScript 中显然是不行的，比如：let obj = {};\r\nobj['person.gender'] = 'male'; // {'person.gender': 'male'}从 obj 的结果我们可以看到两种赋值的差异。this.setData() 失效？在某些情况的回调里面，直接使用 this.setData 会得到错误的结果，这个其实不是 setData 的问题，而是 this 指向的问题，这时候只需要提前把 this 赋值给另外一个变量，比如 that，然后使用 that.setData 就可以了，或者使用 ES6 的箭头函数。代码\r\nPage({\r\n    data: {\r\n        starCount: 0\r\n    },\r\n    onLoad: function () {\r\n       // 错误的写法\r\n       wx.request({\r\n           url: '/api/getStarCount',\r\n           success: function (res) {\r\n               this.setData({\r\n                   starCount: res.starCount\r\n               });\r\n           }\r\n       });\r\n       \r\n       // 正确的写法1\r\n       let that = this;\r\n       wx.request({\r\n           url: '/api/getStarCount',\r\n           success: function (res) {\r\n               that.setData({\r\n                   starCount: res.starCount\r\n               });\r\n           }\r\n       });\r\n       \r\n       // 正确的写法2\r\n       wx.request({\r\n           url: '/api/getStarCount',\r\n           success: res => {\r\n               this.setData({\r\n                   starCount: res.starCount\r\n               });\r\n           }\r\n       });\r\n    }\r\n})从代码中可以看到，第二种写法更加的简洁，这也是 ES6 带来的最大便利了，提高开发效率、减少代码量。实际开发中使用第一种和第二种都可以，取决于团队的开发规范和个人喜好。不过在微信小程序中，更推荐第二种写法，代码更少更简洁，也没有兼容问题，何乐而不为呢？"}
{"title": "微信小程序 View：flex 布局 ", "author": "天下雪", "pub_time": "2017-2-16 00:03", "content": "微信小程序 View 支持两种布局方式：Block 和 Flex所有 View 默认都是 block要使用 flex 布局的话需要显式的声明：display:flex; 下面就来介绍下微信小程序的 Flex 布局先做一个简单的 demo  <view class=\"main\">\r\n    <view class=\"item item1\">1</view>\r\n    <view class=\"item item2\">2</view>\r\n    <view class=\"item item3\">3</view>\r\n  </view>加上背景色能看的更清楚些.main {\r\n  width: 100%;\r\n  background-color: antiquewhite;\r\n}\r\n\r\n.item {\r\n  height: 100rpx;\r\n  width: 100rpx;\r\n}\r\n\r\n.item1 {\r\n  background-color: red;\r\n}\r\n\r\n.item2 {\r\n  background-color: dodgerblue;\r\n}\r\n\r\n.item3 {\r\n  background-color: greenyellow;\r\n}然后大概是这个样子的： 然后我们先都加上  display: flex好使用 flex 布局，主意，貌似 view 不会自动继承，需要在每个想使用的 view 里都加上。 首先是横向布局和竖向布局，要设置属性 flex-direction ,它有4个可选值：row：从左到右的水平方向为主轴row-reverse：从右到左的水平方向为主轴column：从上到下的垂直方向为主轴column-reverse：从下到上的垂直方向为主轴我们来看下设置 row 和 row-reverse 的区别：row： row-reverse：  然后我们要设置元素在横向上的布局方向，需要设置 justify-content 属性，它有5个值可选：flex-start：主轴起点对齐(默认值)flex-end：主轴结束点对齐center：在主轴中居中对齐space-between：两端对齐，除了两端的子元素分别靠向两端的容器之外，其他子元素之间的间隔都相等space-around：每个子元素之间的距离相等，两端的子元素距离容器的距离也和其它子元素之间的距离相同  然后我们要设置元素在纵向上的布局方向，需要设置 align-items 属性，它有5个值可选：stretch 填充整个容器(默认值)flex-start 侧轴的起点对齐 （这里我们手动设置下子 view 的高度，来看的明显一些）flex-end 侧轴的终点对齐center 在侧轴中居中对齐baseline 以子元素的第一行文字对齐  子 View 还有个属性 align-self，可以覆盖父元素的 align-items 属性，它有6个值可选：auto | flex-start | flex-end | center | baseline | stretch （auto 为继承父元素 align-items 属性，其他和 align-items 一致）比如上面最后一个 baseline 的例子，我们把 item3 设置 align-self:flex-end;就成了这个样子：  此外还有 flex-wrap 属性，用于控制子 View 是否换行，有3个值可选：nowrap：不换行（默认）wrap：换行wrap-reverse：换行，第一行在最下面 还有子 View 有个 order 属性，可以控制子元素的排列顺序，默认为0。比如还是上面那个例子，我们把 item3 设置 order:-1; 可以把 item3 排在前面 flex 常用布局就这些写微信小程序的可以试试 最后，要是啥时候小程序能直接支持 bootstrap 就更好了…"}
{"title": "官方问答精选《十六》wx.uploadFile的formData传输汉字,invalid url ", "author": "天下雪", "pub_time": "2017-1-8 14:52", "content": "问题：如果页面个数多于五个，要怎么处理\r\nwx.navigateTo(OBJECT)最多只可以打开五个页面，如果页面多于五个，还想要返回，应该怎么处理呢\r\n答：\r\nwx.redirectTo()\r\n问题：获取不到unionId 我的小程序让用户登录后，用户信息解密出来的json结构没有unionId，可能是什么原因？是我小程序的后台配置有问题吗？\r\n答：需要到开发者平台绑定\r\n\r\n\r\n问题：在真机上对textarea进行编辑，会出现几行文字缩成一行的问题 \r\n答：\r\n已知问题，下个版本修复。\r\n问题：微信小程序，如何调试？ 什么方法，用alert吗？\r\n答：\r\nconsole.log\r\n\r\n\r\n问题：\r\n小程序如何编译 这个启动界面怎么填？是什么格式的，找了很多都没有相映的例子。以及，自定义参数又是负责什么的？\r\n答：\r\n填:\r\n/index/index\r\n\r\ncity=广州\r\n\r\n\r\n\r\n\r\n然后：\r\n\r\n  onLoad: function (options) {\r\n\r\n    console.log('onLoad参数：', options)\r\n\r\n你就知道了。\r\n\r\n\r\n问题：\r\n关于微信background-image在真机展示不出来的解决方案 假设文件目录结构为如下形式，我们需要在index这个page中引用main_bg.png这个文件\r\n\r\n平时我们的做法都是在wxss中或者元素的style中指定background-image: url(\"/images/main_bg.png\")。但是这种做法在开发工具上可以展示，在真机上却展示不出来，这个应该是个bug。\r\n解决方案如下：只能在wxml中的style中指定background-image，并且url中最前面的/需要去掉。（在wxss中指定无效，加上'/'也会无效）\r\n但是这个方案在开发工具中无法正常预览，所以大家可以先通过在wxml中指定background-image: url('/images/main_bg.png')，待开发完成要在真机预览时，再把最前面的'/'去掉即可\r\n当然最好是希望微信团队能够早点解决这个小bug\r\n\r\n问题：onLoad: function (options) 没有参数介绍啊？onLoad: function (options) {    var that = this    this.title = options.title    wx.request({      url: '' + options.id,      headers: {        'Content-Type': 'application/json'      },      success: function (res) {         that.setData({           list: res.data.stories         })         console.log(res.data)      }    })  }option的介绍呢？另外，我服务器没有配置，如何模拟数据返回？我先在客户端模拟服务器数据返回，如何做？答：\r\n由其它页面传入，如：\r\n    wx.navigateTo({\r\n      url: 'pages/selectCity?city=广州\r\n      success: function (res) {\r\n        // success\r\n      },\r\n      fail: function () {\r\n        // fail\r\n      },\r\n      complete: function () {\r\n        // complete\r\n      }\r\n    })\r\n\r\n然后在selectCity页面的onLoad就可以\r\n  onLoad: function (options) {\r\n\r\n    console.log('onLoad参数：', options)生命周期函数\r\nonLoad: 页面加载\r\n\r\n一个页面只会调用一次。\r\n接收页面参数可以获取wx.navigateTo和wx.redirectTo及<navigator/>中的 query。\r\n\r\n\r\nhttps://mp.weixin.qq.com/debug/w ... /page.html?t=201715\r\n\r\n\r\n问题：\r\n安卓上wx.uploadFile的formData传输汉字出现问题答：\r\n在小程序端把汉字编码，在后端对应解码就可以问题：\r\n小程序已经绑定到了开放平台，但依然拿不到 unionid 这里已经绑定了小程序\r\n但通过下面接口去换取时，依然没有 unionidhttps://api.weixin.qq.com/sns/jscode2session?appid=APPID&secret=SECRET&js_code=JSCODE&grant_type=authorization_code\r\n答：\r\nunionid是要解密的\r\n\r\n\r\n问题：提交次数频繁什么鬼？ \r\n答：短时间连续30次会被封24小时\r\n问题：video 能默认全屏播放吗？ video 有全屏播放的方法吗？\r\nwxss 目前是不是还不支持 transform: rotate(90deg); ？在开发环境是可以，真机上就不行，微信版本6.5.3答：wxml:\r\n<video src=\"{{src}}\" style=\"top:{{top}}px;left:{{left}}px;width:{{height}}px;height:{{width}}px;\"  autoplay=\"true\" \r\ncontrols=\"{{false}}\" objectFit=\"cover\"></video>\r\n\r\nwxss:\r\nvideo {\r\n  position: absolute;\r\n  top: 0;\r\n  left: 0;\r\n  width: 100%;\r\n  height: 100%;\r\n  transform: rotate(90deg);\r\n}\r\n\r\n思路是把视频的宽设置成屏幕的高，高设置成屏幕的宽，然后旋转90度，变成横屏显示这样\r\n\r\n\r\n\r\n\r\n问题：Object.assign() Android真机环境不支持这个API \r\n答：\r\nObject.assign 是 ES6 API，安卓目前不支持\r\n\r\n\r\n问题：开发者帐号，wx.request异常 \r\n答：登录身份不会影响接口调用，麻烦排查下其他原因。看看 request 是否有 fail 回调。\r\n问题：wx.request 错误提示 request:fail invalid url 我已经配置好了 https ，浏览器中可以正常访问在小程序后台也设置好了服务器域名但在小程序代码中使用 wx.request 请求 url 时显示错误信息： request:fail invalid url请问大家有遇到过这个问题的吗？答：传入的 URL 不合法最后发现，我的这个问题不是因为后台配置，也不是SSL证书的问题，是调用url时的引号写法问题\r\n\r\n之前的写法：\r\n\r\nwx.request({\r\n      url: 'https://www.xxx.com/test.php', \r\n      ...\r\n    })\r\n\r\n这样就报错：invalid url\r\n\r\n后来改成：\r\n\r\n...\r\nurl: `https://www.xxx.com/test.php`,\r\n...\r\n\r\n不使用单引号，改为了 ` （与 ~ 同键）, 这样就好了\r\n\r\nurl 字符串中并没有使用变量，不明白为什么单引号不行，而需要使用 `\r\n\r\n\r\n\r\n\r\n问题：微信小程序怎么控制WXSS样式 我想添加或删除某个元素、或某个元素的CSS样式，该怎么处理？\r\n答：我用的办法是在wxss定义两个样式,wxml条件渲染选择其中一个\r\n问题：小程序二维码可以在朋友圈识别访问吗？ \r\n答：\r\n不可以，只能通过扫一扫识别"}
{"title": "微信小程序集成环信SDK ", "author": "天下雪", "pub_time": "2017-2-10 00:10", "content": "分享者：mirrorZyb，来自原文地址本文以一个小例子简单的演示在微信小程序中使用环信SDK收发消息。官网demo 下载后把整个utils目录下的文件复制到咱自己工程的目录下。在WebIMConfig.js中将AppKey替换成自己应用的key界面简单的用一个输入框和一个按钮组成，点击按钮发送消息。导入WebIM.jsvar WebIM = require('../../utils/WebIM.js')\r\nvar WebIM = WebIM.default登陆hxloign: function () {\r\n        var options = {\r\n            apiUrl: WebIM.config.apiURL,\r\n            user: 'u1',\r\n            pwd: 'p1',\r\n            grant_type: 'password',\r\n            appKey: WebIM.config.appkey //应用key\r\n        }\r\n        WebIM.conn.open(options)\r\n    },发送文本消息 sendMessage: function () {\r\n\r\n        var that = this\r\n        var id = WebIM.conn.getUniqueId();\r\n        var msg = new WebIM.message('txt', id);\r\n        msg.set({\r\n            msg: this.data.inputValue,//输入框的文本\r\n            to: 'u0',\r\n            roomType: false,\r\n            success: function (id, serverMsgId) {\r\n            }\r\n        });\r\n        msg.body.chatType = 'singleChat';\r\n        WebIM.conn.send(msg.body);\r\n    },接收消息接收消息要先在app.js中添加回调函数app.js获取聊天界面  getRoomPage: function () {\r\n        return this.getPage(\"pages/index/index\")//聊天界面\r\n    },\r\n   getPage: function (pageName) {\r\n        var pages = getCurrentPages()\r\n        return pages.find(function (page) {\r\n            return page.__route__ == pageName\r\n    })在app.jsonlanuch方法中进行声明   var that = this;\r\n        WebIM.conn.listen({\r\n            onTextMessage: function (message) {\r\n                var page = that.getRoomPage()\r\n                if (message) {\r\n                    if (page) {\r\n                        page.receiveMsg(message, 'txt')//receiveMsg方法就是咱在自己界面定义的方法\r\n                     }else{\r\n                        //界面不存在\r\n                      }\r\n                }\r\n            }\r\n        })index.js中定义的接收消息的方法receiveMsg: function (msg, type) {\r\n        console.log(msg);\r\n    },到此简单的收发消息功能就算实现了，发送语音图片规则都差不多，只不过参数不一样，可以参考消息 环信开发文档"}
{"title": "微信小程序-setData()方法 ", "author": "Rolan", "pub_time": "2018-2-27 00:37", "content": "一般setData方法多用于点击后改变页面信息或者刷新后与后台交互获取最新的信息注意：直接修改 this.data 而不调用 this.setData 是无法改变页面的状态的，还会造成数据不一致单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。方法如下：js:Page({\r\n  data: {\r\n    text: 'init data',\r\n    num: 0,\r\n    array: [{text: 'init data'}],\r\n    object: {\r\n      text: 'init data'\r\n    }\r\n  },\r\n  changeText: function() {\r\n    // this.data.text = 'changed data'  // bad, it can not work\r\n    this.setData({\r\n      text: 'changed data'\r\n    })\r\n  },\r\n  changeNum: function() {\r\n    this.data.num = 1\r\n    this.setData({\r\n      num: this.data.num\r\n    })\r\n  },\r\n  changeItemInArray: function() {\r\n    // you can use this way to modify a danamic data path\r\n    this.setData({\r\n      'array[0].text':'changed data'\r\n    })\r\n  },\r\n  changeItemInObject: function(){\r\n    this.setData({\r\n      'object.text': 'changed data'\r\n    });\r\n  },\r\n  addNewField: function() {\r\n    this.setData({\r\n      'newField.text': 'new data'\r\n    })\r\n  }\r\n})wxml:<view>{{text}}</view>\r\n<button bindtap=\"changeText\"> Change normal data </button>\r\n<view>{{num}}</view>\r\n<button bindtap=\"changeNum\"> Change normal num </button>\r\n<view>{{array[0].text}}</view>\r\n<button bindtap=\"changeItemInArray\"> Change Array data </button>\r\n<view>{{object.text}}</view>\r\n<button bindtap=\"changeItemInObject\"> Change Object data </button>\r\n<view>{{newField.text}}</view>\r\n<button bindtap=\"addNewField\"> Add new data </button>"}
{"title": "微信小程序与内嵌网页交互实现支付功能 ", "author": "Rolan", "pub_time": "2017-12-21 00:27", "content": "上个月，小程序开放了新功能，支持内嵌网页，所以我就开始了小程序内嵌网页之路，之前我只是个小安卓。 \r\n内嵌网页中可使用JSSDK 1.3.0提供的接口，可坑就来了，居然不支持支付接口的调用，经过一番研究，总算打通了两边的交互\r\n大概流程\r\n1、先说明涉及到的文件，下面会用到\r\n1.1 app.js:小程序的app.js文件,在globalData里定义一个全局变量paySuccessUrl: '',用来保存支付成功跳转url1.2 wxminiwebview.js:小程序中放web-view的界面\r\n1.3 wxminipay.js:小程序原生支付界面1.4 web_pay.vue:内嵌网页会调起支付的路由组件界面，由于我是用vue+vue-router写的，所以你最好了解下vue和vue-router，记得引入微信jssdk1.3.0,最新版本才包含小程序相对应方法。很遗憾，微信并没提供npm包，github有人提供的commonjs引入方式的微信jssdk版本也只有1.2.0,所以就只能这样引入了\r\n<script src=\"./static/jweixin-1.3.0.js\">script>\r\n2、首先我们像官网那样正常嵌入一个内嵌网页,url是wxmini_webview.js中data中定义的变量，webview加载的就是网页就是这个url\r\n<web-view src=\"{{url}}\">web-view>\r\n3、在内嵌网页web_pay.vue里判断当前是否是微信环境\r\nwindow.wx.ready(function () {    isWxMini = window.__wxjs_environment === 'miniprogram'})\r\n4、在内嵌网页web_pay.vue调用支付时把支付金额，支付说明，支付成功跳转url...(任何你想要的参数，记得encodeURIComponent)，传给小程序原生页面\r\nif (isWxMini) {    let jumpUrl = encodeURIComponent(window.location)    let path = `/page/pay/pay?amount=${amount}&title=${desc}&jumpUrl=${jumpUrl}`    window.wx.miniProgram.navigateTo({        url: path    }) }\r\n5、在小程序支付界面wxmini_pay.js里获取到内嵌网页传过来的值,这里演示方便,实际上是在page的data里存储这些会显示在界面的值好些\r\nonLoad: function (options) {    console.log(options)    // 获取网页传过来的值    // TODO 用es6解构来获取值TODO    jumpUrl = options.jumpUrl    amount = options.amount    title = options.title    ...  },\r\n6、支付成功后,把跳转url附带支付结果及当前时间保存到全局变量\r\npaySuccess () {    let currentTime = new Date().getTime()    //这是为了防止wxmini_webview.js文件里调用setData由于前后两个url一致导致路由不触发刷新的bug    jumpUrl = options.jumpUrl+encodeURIComponent(`?payResult=1&time=${currentTime}`)     //payResult=1表示支付成功，这里我偷懒了直接在url后面补?,实际情况比较复杂    //为了实现支付成功返回后的无刷新加载,这里的参数应该是属于路由web_pay.vue的,而不是属于window.location.search的    //所以要判断路由锚点#的位置和是否已经有路由参数（如果是vue-router的history模式我没用过,应该和window.location一样吧）    getApp().globalData.paySuccessUrl=jumpUrl //保存跳转url到小程序全局变量里    wx.navigateBack() //返回会上个页面，也就是承载网页的容器页面wxmini_pay.js}\r\n7、回到小程序wxmini_webview.js,会触发onshow,在里面进行界面无刷新加载\r\nonShow: function () {    console.log('on show')    let paySuccessUrl = getApp().globalData.paySuccessUrl    getApp().globalData.paySuccessUrl=\"\" //清空支付成功url，防止一些操作触发onShow事件    if (paySuccessUrl) {      let url = decodeURIComponent(paySuccessUrl)      this.setData({      //这里在次说明下步骤6中的&time=${currentTime},就是因为不加这个当你第一次支付成功回来这里      //这个url跟你第二次支付成功回来这里是一样的，会导致第二次支付开始，这里的setData方法失效        url       })    }  },\r\n8、步骤7中的setData会触发webview中的网页加载，由于我采用的是vue-router,而且前后两个url只有路由的参数query不一样，所以并不会触发界面刷新，也不会触发路由的重新加载，而是只会触发beforeRouteUpdate 这个方法，举个例子，现在支付前界面是https://host/#/pay,然后支付成功后跳转https://host/?payResult=1&time=123456#/pay,此时界面不会刷新，pay路由也不会重新加载，而是触发beforeRouteUpdate (to, from, next),你要做的只是在这里界面解析to.query里的数据，然后该干嘛干嘛\r\nbeforeRouteUpdate (to, from, next) {      console.log('路由发生改变，很有可能是小程序的支付成功回调')      let payResult = to.query.payResult      if (payResult) { // 小程序支付成功        if (payResult === '1') {          console.log('支付成功,下班打卡走人')        }      }      next()    },\r\n这么晚了，先睡了，如果有空我再整理个demo，如果文章对你有帮助麻烦点个赞"}
{"title": "微信小程序集成 Jenkins ", "author": "Rolan", "pub_time": "2018-9-4 00:18", "content": "微信小程序的测试发布在没有 CI/CD 等相关工具的情况下，存在着如下的问题：小程序开发助手中，同一个开发者只能显示一个开发版本测试同事找开发要二维码，效率较低本地生成的二维码会出现携带本地代码、未及时拉取分支其他改动等问题为了避免如上问题的发生，采用 微信小程序集成 Jenkins 的方案。基础在介绍实现方案之前，先来回顾一下常规的微信小程序发布流程。从上面的流程图可以看出，微信小程序预览、上传都是需要在微信开发者工具中进行的，接下来了解一下微信开发者工具提供的上传方式。微信开发者工具除了图形化界面，微信开发者工具还提供了命令行与 HTTP 服务两种接口供外部调用，来进行登录、预览、上传等操作。命令行调用命令行工具所在位置：macOS: <安装路径>/Contents/Resources/app.nw/bin/cliWindows: <安装路径>/cli.bat以 macOS 操作系统示例：1、打开开发者工具：/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\n复制代码其中， /Applications/wechatwebdevtools.app/ 为安装路径。2、登录：/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -l\r\n复制代码输入上面的命令行后，终端中打印出登录二维码，使用微信扫码登录。在微信端完成操作之后，会输出 login success ，如下图所示：如果想得到 base64 形式的二维码，可以使用下面的命令：# 登录，在终端中打印登录 base64 形式的二维码\r\ncli -l --login-qr-output base64\r\n\r\n# 登录，二维码转成 base64 并存到文件 /Users/username/code.txt \r\ncli -l --login-qr-output base64@/Users/username/code.txt\r\n复制代码更多 API 可以参考命令行调用 。HTTP 服务HTTP 服务在 工具启动后自动开启 ，每次开启 host 固定为 127.0.0.1，端口号并不固定。端口号在 用户目录 下记录，位置如下：macOS : ~/Library/Application Support/微信web开发者工具/Default/.ideWindows : ~/AppData/Local/微信web开发者工具/User Data/Default/.ide以 macOS 操作系统示例：首先需要 运行开发者工具 ，可以利用上面介绍的命令行方法打开微信开发者工具。/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\nport=$(cat \"/Users/zyy/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\n复制代码这样就可以拿到微信开发者工具运行的端口号了，其中， /Users/zyy/ 为用户目录。1、打开开发者工具：# 打开工具\r\nhttp://127.0.0.1:端口号/open\r\n# 打开/刷新项目\r\nhttp://127.0.0.1:端口号/open?projectpath=项目全路径\r\n复制代码2、登录：# 登录，返回图片格式的二维码\r\nhttp://127.0.0.1:端口号/login\r\n# 登录，取 base64 格式二维码\r\nhttp://127.0.0.1:端口号/login?format=base64\r\n# 登录，取 base64 格式二维码，并写入 /Users/username/logincode.txt\r\nhttp://127.0.0.1:端口号/login?format=base64&qroutput=%2FUsers%2Fusername%2Flogincode.txt\r\n复制代码3、预览：# 预览路径为 /Users/username/demo 的项目，返回图片格式的二维码\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo\r\n\r\n# 预览路径为 /Users/username/demo 的项目，返回 base64 格式的二维码\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&format=base64\r\n\r\n# 预览路径为 /Users/username/demo 的项目，返回 base64 格式的二维码，并写入 /Users/username/logincode.txt\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&format=base64&qroutput=%2FUsers%2Fusername%2Flogincode.txt\r\n\r\n# 预览路径为 /Users/username/demo 的项目，返回图片格式的二维码，并将预览信息输出至 /Users/username/info.json\r\nhttp://127.0.0.1:端口号/preview?projectpath=%2FUsers%2Fusername%2Fdemo&infooutput=%2Users%2username%2info.json\r\n复制代码更多 API 可以参考HTTP 调用 。方案微信开发者工具目前只有 macOS 和 Windows 两种版本，这限制了服务器的系统。下面以 macOS 为例， 来介绍具体的实现过程：安装 JenkinsThe leading open source automation server, Jenkins provides hundreds of plugins to support building, deploying and automating any project.作为领先的开源自动化服务器，Jenkins提供数百个插件来支持构建，部署和自动化任何项目。Jenkins 依赖于 Java 运行环境，所以需要在机器上安装 Java。安装 Jenkins 方式很多，可以在官网直接下载最新的软件包，然后执行下面的命令启动 Jenkins 。java -jar jenkins.war --httpPort=8888\r\n复制代码其中， --httpPort=8888 为设置服务端口号，默认端口号为 8080 。新建任务选择 “ 构建一个自由风格的软件项目 ” ，在输入任务名称之后，点击确定按钮，进入到任务配置页面。任务配置在介绍任务配置之前，先来看一下最终要实现的功能。主要的功能点如下：使用 git 来管理代码，可以选择分支打包版本（开发版／体验版）可以选择（注意：这里的「开发版」对应「预览」，体验版对应「上传」）1、源码管理在任务配置页面的第二项 “源码管理” 中，选择 git 方式管理代码。填入 git 仓库地址及访问的账户，上图中的 $branch 是自定义的构建参数，下面来看一下构建参数的定义。2、构建参数在任务配置页面的第二项 “General” 中，选择 “参数化构建过程”，进入构建参数配置页面。参数有上述的几种类型供选择，可以参考下图进行配置，这里不再赘述。需要注意的是，这里的 name 可以通过 branch 。构建在任务配置页面的 “构建” 中，选择 “执行 shell” 方式来进行构建。Tips：这里的 shell 脚本是微信小程序集成 Jenkins 最核心的内容。回顾一下，本文最开始提到的微信小程序发布流程图：这一系列的操作使用 shell 脚本来完成，如何实现呢？登录微信开发者工具的登录需要在微信端扫码确认，这一步微信并没有提供账号密码的登录方式。不过，微信开发者工具是可以保持登录态的。由于微信限制，一个开发者身份只能在一个终端登录，所以我们申请了一个新的微信账号「前端小姐姐」用于在 Jenkins 机器上登录。项目基础设置在图形化界面中，上传代码时，会在开发者工具中填入 AppID 、项目路径等信息，也会在「详情」中选择项目的基本设置，比如「ES6 转 ES5」。微信还提供了一种配置方法，在项目根目录使用 project.config.json 文件。这里通过一段 node 脚本，生成 project.config.json 文件。const fs = require('fs')\r\n\r\nconst content = '{\"description\":\"项目配置文件。\",\"setting\":{\"urlCheck\":false,\"es6\":true,\"postcss\":true,\"minified\":true,\"newFeature\":true},\"miniprogramRoot\":\"./\",\"compileType\":\"miniprogram\",\"appid\":\"***\",\"projectname\":\"wechat-app\",\"condition\":{\"search\":{\"current\":-1,\"list\":[]},\"conversation\":{\"current\":-1,\"list\":[]},\"plugin\":{\"current\":-1,\"list\":[]},\"game\":{\"currentL\":-1,\"list\":[]},\"miniprogram\":{\"current\":-1,\"list\":[]}}}'\r\n\r\nfs.writeFileSync('./dist/project.config.json', content, 'utf-8')\r\n复制代码这样就完成了项目的基础设置，接下来将介绍如何通过 shell 脚本完成上传。shell 脚本echo -------------------------------------------------------\r\necho GIT_BRANCH: ${GIT_BRANCH}\r\necho -------------------------------------------------------\r\n# 执行项目构建\r\nnpm i --registry=http://registry.npm.taobao.org\r\nnpm run build\r\n# 打开微信开发者工具\r\n/Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -o\r\nport=$(cat \"/Users/devops/Library/Application Support/微信web开发者工具/Default/.ide\")\r\necho \"微信开发者工具运行在${port}端口\"\r\nreturn_code=$(curl -sL -w %{http_code} http://127.0.0.1:${port}/open)\r\nif [ $return_code == 200 ]\r\n  then\r\n  echo \"返回状态码200，devtool启动成功！\"\r\nelse\r\n  echo \"返回状态码${return_code}，devtool启动失败\"\r\n  exit 1\r\nfi\r\nif [ \"$build_type\" == \"dev\" ]\r\n  then\r\n  echo \"发布开发版！\"\r\n  wget -O $BUILD_ID.png http://127.0.0.1:${port}/preview?projectpath=/Users/Shared/Jenkins/Home/workspace/fe-wechat-app/dist\r\n  echo \"预览成功！请扫描二维码进入开发版！\"\r\nelif [ \"$build_type\" == 'prod' ]\r\n  then\r\n  echo \"准备上传！\"\r\n  /Applications/wechatwebdevtools.app/Contents/Resources/app.nw/bin/cli -u 1.0.0@/Users/Shared/Jenkins/Home/workspace/fe-wechat-app/dist --upload-desc 'initial release'\r\n  echo \"上传成功！请到微信小程序后台设置体验版并提交审核！\"\r\nfi\r\n复制代码因为本项目需要编译代码，所以服务器上需要安装 node 和 npm。 npm run build 命令不光在编译代码，而且还执行了前面介绍的生成 project.config.json 的 node 脚本。开发版上传成功后，将二维码图片保存下来，用于构建后显示二维码和发送邮件。这里结合 命令行调用 和 HTTP 调用 两种方式来完成上传，主要出于以下原因：HTTP 调用 可以很方便的下载生成的二维码图片HTTP 服务 只有在微信开发者工具启动之后，才会启动，所以需要通过 命令行调用 方式，来启动微信开发者工具构建后使用 description setter plugin 插件来实现，构建完成后显示二维码图片。安装插件回到 Jenkins 主页，在「系统管理」中，进入到「插件管理」页面，搜索 description setter plugin 并安装。安装好插件后，返回任务配置页面。在「构建后操作」中，增加「Set build description」步骤，如下图：这里采用 HTML <img> 标签形式，展示二维码信息，如下：<img src=\"http://机器ip:端口/job/项目名称/ws/${BUILD_ID}.png\" alt=\"二维码${BUILD_ID}\" width=\"200\" height=\"200\" /> <a href=\"http://机器ip:端口/job/项目名称/ws/${BUILD_ID}.png\">二维码${BUILD_ID}</a>\r\n复制代码按照上面的方式配置后，发现图片并没有显示出来，而是显示了文本信息。这是由于 Jenkins 出于安全的限制，所有描述信息的 Markup Formatter 默认都采用 Plain text 的模式。在「系统管理」-> 「全局安全配置」中，将 Markup Formatter 由 Plain text (纯文本) 更改为 Safe HTML 即可。按照上面的步骤操作后，就可以显示出开发版二维码。因为 Jenkins 构建时，均使用「前端小姐姐」微信账号，所以小程序开发助手上「前端小姐姐」发布的开发版不确定是哪位同学构建的，故需要使用 Jenkins 平台生成的二维码，并注意二维码有效期（有效期25分钟）。总结本文以微信小程序常规的发布流程为切入点，循序渐进地介绍了如何集成 Jenkins 实现微信小程序预览、上传功能。后台、测试同事可以在该平台上选择分支获取开发版用于联调、测试，解决了本文开篇提及的问题。由于本文篇幅有限，只是介绍了该平台的一些基本功能，如果有其他的需求，可以参考文末的拓展链接解决。此外，文中若有任何表述不清或不当的地方，欢迎大家批评指正～本文首发于 github.com/yingye/Blog… ，欢迎各位关注我的Blog，正文以issue形式呈现，喜欢请点star，订阅请点watch～"}
{"title": "AppAdhoc微信小程序 SDK 集成文档 ", "author": "天下雪", "pub_time": "2017-1-22 00:06", "content": "下载SDKAppAdhoc 微信 SDK引入SDK在您工程的app.js中，引入sdk：……\r\nvar adhoc = require('./ab.wx');\r\n……\r\n其中“app_key” 是在登录 AppAdhoc 后台创建“应用”之后获得的该“应用”的授权标识。可在AppAdhoc控制台应用列表找到，如下图红线部分：其中”client_id” 是一个唯一的 ID，用来代表一个独立访客，建议使用微信的openid如果没有指定 client_id，SDK 将自动生成一个随机的 client_id，并使用微信的storage进行持久化。编程模式：根据“试验变量”展示相应内容在编程模式中“试验变量”的值决定了展示的内容或程序的逻辑。注意：试验变量值应由PM或相关A/B Testing需求制定人员在后台提前录入完毕，如下图“版本管理”红线部分：展示相应内容需要两步：1.获取AppAdoc 后台试验变量通过在您的小程序中调用 adhoc.getExperimentFlags(callback) 来完成的：adhoc.getExperimentFlags(function(flagObj){\r\n    if (flags.get('isNewHomePage') === true)\r\n      var text = \" Hey，我是试验版 :) \";\r\n    } else {\r\n      var text = \" Hey, 我是原始版本！\";\r\n    }\r\n    that.setData({\r\n        text: text\r\n    })\r\n})\r\n其中，'isNewHomePage' 即是“试验变量“，应与上图中红线标识保持一致，上面的示例代码在获取是否是新的首页后，修改了数据。请注意在用户访问到试验页面时，需要触发试验内包含的所有变量才算作进入试验，否则将不会上报试验数据。在此示例中，“flags.get('isNewHomePage')”算作触发变量“isNewHomePage”。请勿在非试验页面或者公用文件中调用。上报指标指标用于量化试验结果的好坏，AppAdhoc 后台中的试验图表根据此数据生成。注意：指标值应由PM或相关AB Test需求制定人员在后台提前录入完毕，如下图“优化指标”红线部分：比如在进入某一逻辑分支后，可以统计点击次数。将上图中的指标“clickTimes”传入函数increment实现上报指标, 每次累加1：Page({\r\n    bindViewTap: function(){\r\n        adhoc.increment('clickTimes', 1);\r\n    }\r\n})\r\n如果需要同时上传多个指标，可以使用以下方法（多个指标将统一上传成功或失败）：Page({\r\n    bindViewTap: function(){\r\n        adhoc.increment(['stat1', 'stat2', {key: 'stat3', val: 10}], function(error){\r\n            if(error){\r\n                //error handler\r\n            }else{\r\n                //success handler\r\n            }\r\n        });\r\n    }\r\n})\r\n开始试验恭喜，您完成了AppAdhoc AB Testing wx SDK的埋点集成工作，请通知PM或相关AB Test需求制定人员，点下开始试验按钮吧！注意：确保app_key, 试验变量字符串，指标字符串与后台截图处一一对应，否则可能出现异常或无试验数据情况。高级功能 自定义受众定向（需要联系管理员开启）注意：自定义受众定向条件应由PM或相关AB Test需求制定人员在后台提前录入完毕。在运行控制/右侧定向试验：选择分组，点击编辑用户群：即得到受众条件的key，在下图例子中，“sex”是key：自定义受众定向有三种情况：普通自定义：adhoc.setCustomTags({sex: 'male', age: '20'})"}
{"title": "PHP：微信小程序服务端集成微信支付 ", "author": "天下雪", "pub_time": "2017-1-4 14:12", "content": "作者：秀杰，来自授权地址该demo源码已托管到码云：http://git.oschina.net/dotton/lendoo-wx，欢迎下载。理论上集成微信支付的全部工作可以在小程序端完成，因为小程序js有访问网络的能力，但是为了安全，不暴露敏感key，而且可以使用官方提供的现成php demo更省力，于是在服务端完成签名与发起请求，小程序端只做一个wx.requestPayment(OBJECT)接口的对接。整体集成过程与JSAPI、APP类似，先统一下单，然后拿返回的结果来请求支付。一共三步：1.小程序端通过wx.login的返回的code换取openid 2.服务端向微信统一下单 3.小程序端发起支付事先准备好这几样东西：APPID = 'wx426b3015555a46be';MCHID = '1900009851';KEY = '8934e7d15453e97507ef794cf7b0519d';APPSECRET = '7813490da6f1265e4901ffb80afaa36f';PHP SDK，下载链接见文尾第1、4样是申请小程序时获得的，第2、3样是申请开通微信支付时获得的，注意第3、4样长得比较像，其实是2个东西，两者混淆将导致签名通不过。向微信端下单，得到prepay_id1. 创建一个Controller，引并WxPay.Api.php类<?phprequire_once __DIR__ . '/BaseController.php';require_once __DIR__ . '/../third_party/wxpay/WxPay.Api.php';class WXPay extends BaseController {    function index() {    }}之后可以通过index.php/wxpay来作访问请求2. 修改配置文件WxPay.Config.php改成自己申请得到相应key3. 实现index方法function index() {    //初始化值对象    $input = new WxPayUnifiedOrder();    //文档提及的参数规范：商家名称-销售商品类目    $input->SetBody(\"灵动商城-手机\");    //订单号应该是由小程序端传给服务端的，在用户下单时即生成，demo中取值是一个生成的时间戳    $input->SetOut_trade_no('123123123');    //费用应该是由小程序端传给服务端的，在用户下单时告知服务端应付金额，demo中取值是1，即1分钱    $input->SetTotal_fee(\"1\");    $input->SetNotify_url(\"http://paysdk.weixin.qq.com/example/notify.php\");    input->SetTrade_type(\"JSAPI\");    //由小程序端传给服务端    $input->SetOpenid($this->input->post('openId'));    //向微信统一下单，并返回order，它是一个array数组    $order = WxPayApi::unifiedOrder($input);    //json化返回给小程序端    eader(\"Content-Type: application/json\");    echo json_encode($order);}说明1：文档上提到的nonce_str不是没提交，而是sdk帮我们填上的出处在WxPay.Api.php第55行$inputObj->SetNonce_str(self::getNonceStr());//随机字符串"}
{"title": "小程序Checkbox全选 ", "author": "Rolan", "pub_time": "2019-3-28 00:32", "content": "这是我写的第一篇文章，若有不对，请大家指正，多谢！这篇文章主要讲小程序的全选。接触小程序没有太久，我想每实现一个功能就在这里记录一次，以此巩固。其实实现很简单，在每个选择集合中加入一个isCheck字段，默认是false（未选中），然后wxml页面中循环list时，给checkbox加一个属性：checked='{{item.isCheck}}'；接下来是js，在全选按钮上绑定事件：checkAll。js中首选要得到所有的list（var list = that.data.Data）;然后for循环list，在循环中让每一个isCheck取反；之后，在循环外setData我们上文声明的list：that.setData({Data:list}),意思就是把我们操作过的list重新赋给Data，页面会重新渲染；废话不多说，以下是代码：  wxml:\r\n    <view class='atte-title'>\r\n      <view class='odb-title-left'>选择参会人</view>\r\n      <checkbox value='全选' bindtap='checkAll'></checkbox>\r\n    </view>\r\n    <checkbox-group bindchange='change'>\r\n      <block wx:for='{{Data}}' wx:key>\r\n        <checkbox value='{{item.name}}' checked='{{item.isCheck}}' class='check-item' style='background:#fff;'>\r\n          <view class='check-box'>\r\n            <view class='atte-ava'>\r\n              <image src='{{item.Image}}'></image>\r\n            </view>\r\n            <view class='atte-name'>{{item.name}}</view>\r\n            <view class='atte-point'>\r\n              <image src='/images/Articles/point.png'></image>\r\n            </view>\r\n            <view class='atte-pro'>{{item.partyBranchJobTypeName}}</view>\r\n          </view>\r\n        </checkbox>\r\n      </block>\r\n    </checkbox-group>  // 全选\r\n  checkAll: function (e) {\r\n    var that = this\r\n    console.log(that.data.Data)\r\n    var list = that.data.Data  \r\n    for (var i = 0; i < list.length;++i){\r\n      list[i].isCheck = !list[i].isCheck || false;  //list[i].isCheck默認是false,这里是取反\r\n    }\r\n    that.setData({\r\n      Data:list,         //将取反后的集合setData到我们的Data\r\n    })\r\n  },小白一枚，水平很差，请多指教；"}
{"title": "小程序构建骨架屏的探索 ", "author": "Rolan", "pub_time": "2018-9-18 00:12", "content": "首屏一般情况下，在首屏数据未拿到之前，为了提升用户的体验，会在页面上展示一个loading的图层，类似下面这个其中除了菊花图以外网上还流传这各种各样的loading动画，在PC端上几乎要统一江湖了，不过最近在移动端上面看到不同于菊花图的加载方式，就是这篇文章需要分享的Skeleton Screen，中文称之为\"骨架屏\"概念A skeleton screen is essentially a blank version of a page into which information is gradually loaded.在H5中，骨架屏其实已经不是什么新奇的概念了，网上也有各种方案生成对应的骨架屏，包括我们经常使用的知乎、饿了么、美团等APP都有应用骨架屏这个概念图片来源网络，侵删方案先从H5生成骨架屏方案开始说起，总的来说H5生成骨架屏的方案有2种完全靠手写HTML和CSS方式给每个页面定制一套骨架屏利用预渲染的方式生成静态骨架屏第一套方案，毫无疑问是最简单最直白的方式，缺点也很明显，假如页面布局有修改的话，那么除了修改业务代码之外还需要额外修改骨架屏，增加了维护的成本。第二套方案，一定程度上改善了第一套方案带来的维护成本增加的缺点，主要还是使用工具预渲染页面，获取到DOM节点和样式，保留页面结构，覆盖样式，生成灰色块盖在原有文本、图片或者是canvas等节点上面，最后将生成的HTML和CSS打包出来，就是一个带有骨架屏的页面。最后再利用webpack工具将生成的骨架屏插入到HTML里面，详细的话可以看看饿了么的分享，这里就不多描述了。调研了下H5生成骨架屏的方案，对于小程序生成骨架屏的方案也有了一个大致的想法，主要有2个难点需要实现预渲染获取节点预渲染再说回饿了么提供的骨架屏的方案，使用 puppeteer 渲染页面（或者使用服务端渲染，vue或者react都有提供相应的方案），拿到DOM节点和样式，这里有一点需要注意的是，页面的渲染是需要初始化的数据，数据的来源可以是初始化的data（vue）或者mock数据，当然小程序是无法直接使用 puppeteer 来做预渲染（有另外的方案可以实现），需要利用小程序初始化的 data + template 渲染之后得到一个初始化结构作为骨架屏的结构//index.js\r\nPage({\r\n    data: {\r\n        motto: 'Hello World',\r\n        userInfo: {\r\n            avatarUrl: 'https://wx.qlogo.cn/mmopen/vi_32/SYiaiba5faeraYBoQCWdsBX4hSjFKiawzhIpnXjejDtjmiaFqMqhIlRBqR7IVdbKE51npeF6X1cXxtDQD2bzehgqMA/132',\r\n            nickName: 'jay'\r\n        },\r\n        lists: [\r\n            'aslkdnoakjbsnfkajbfk',\r\n            'qwrwfhbfdvndgndghndeghsdfh',\r\n            'qweqwtefhfhgmjfgjdfghaefdhsdfgdfh',\r\n        ],\r\n        showSkeleton: true\r\n    },\r\n    onLoad: function () {\r\n        const that = this;\r\n        setTimeout(() => {\r\n            that.setData({\r\n                showSkeleton: false\r\n            })\r\n        }, 3000)\r\n    }\r\n})\r\n\r\n//index.wxml\r\n<view class=\"container\">\r\n    <view class=\"userinfo\">\r\n        <block>\r\n            <image class=\"userinfo-avatar skeleton-radius\" src=\"{{userInfo.avatarUrl}}\"\r\n                   mode=\"cover\"></image>\r\n            <text class=\"userinfo-nickname skeleton-rect\">{{userInfo.nickName}}</text>\r\n        </block>\r\n    </view>\r\n    <view style=\"margin: 20px 0\">\r\n        <view wx:for=\"{{lists}}\" class=\"lists\">\r\n            <icon type=\"success\" size=\"20\" class=\"list skeleton-radius\"/>\r\n            <text class=\"skeleton-rect\">{{item}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class=\"usermotto\">\r\n        <text class=\"user-motto skeleton-rect\">{{motto}}</text>\r\n    </view>\r\n\r\n    <view style=\"margin-top: 200px;\">\r\n        aaaaaaaaaaa\r\n    </view>\r\n</view>有了上面的 data + template 之后，就有了一个初始化的页面结构，接下来就需要拿到节点信息节点小程序基础库1.4.0之后小程序基础库提供了一组新的API，可用于获取节点信息，具体API戳这里。跟H5方式一样，根据class或者id获取节点信息，不同的是只能获取到当前的节点信息，无法获取到其父或者子节点信息，所以只能手动给需要渲染骨架屏的节点添加相应的class或者id<view class=\"container\">\r\n    <view class=\"userinfo\">\r\n        <block>\r\n            <image class=\"userinfo-avatar skeleton-radius\" src=\"{{userInfo.avatarUrl}}\"\r\n                   mode=\"cover\"></image>\r\n            <text class=\"userinfo-nickname skeleton-rect\">{{userInfo.nickName}}</text>\r\n        </block>\r\n    </view>\r\n    <view style=\"margin: 20px 0\">\r\n        <view wx:for=\"{{lists}}\" class=\"lists\">\r\n            <icon type=\"success\" size=\"20\" class=\"list skeleton-radius\"/>\r\n            <text class=\"skeleton-rect\">{{item}}</text>\r\n        </view>\r\n    </view>\r\n\r\n    <view class=\"usermotto\">\r\n        <text class=\"user-motto skeleton-rect\">{{motto}}</text>\r\n    </view>\r\n\r\n    <view style=\"margin-top: 200px;\">\r\n        aaaaaaaaaaa\r\n    </view>\r\n</view>约定2个特殊的class作为获取节点信息的标记skeleton-rect和skeleton-radius，在页面中获取相应的top、left、width、height进行骨架屏的绘制结果具体的调用方式和源码，请看 github ，最后求start总结上文有说到小程序也可以使用 page-skeleton-webpack-plugin 方式一样生成骨架屏，最重要的一点就是需要将小程序跑在chrome上面，后面的流程就一样了，至于怎么将小程序跑在chrome上面呢？可以利用 wept ，缺点就是目前作者已经停止维护这个工具了，不支持新版小程序的API。说回来我这个生成骨架屏的方案，其实跟 page-skeleton-webpack-plugin 有点相似，不同的是，page-skeleton-webpack-plugin 采用离线渲染的方式生成静态骨架屏插入路由中，而我采用运行时先渲染页面默认结构，然后根据默认结构再绘制骨架屏。从性能角度出发确实不如 page-skeleton-webpack-plugin，但是也差不了多少了，主要还是小程序并没有提供类似服务端渲染的方案。目前从使用上来讲，还是有点小麻烦，需要默认数据撑开页面结构，需要给相应的节点添加class，后面有时间再研究下有没有更好的方案吧~~~"}
{"title": "以微信小程序为例学习网站开发平台API调用 ", "author": "Rolan", "pub_time": "2017-10-10 00:29", "content": "一、引言    相信各位码农们都有过要调用各大资源网站提供的API的经历，但是在接入的时候出现许多这样那样的问题，最近在做一个业界备受关注的微信小程序项目，使用了多个网站的API接入，接下来我就以“豆瓣电影”小程序的demo与大家分享下我在学习网站API使用的一些心得体会，本文为个人观点，如有不当之处，恳请批评指正。\r\n二、.开发工具与资源平台    1. [微信web开发者工具]：主要用于敲网页代码，但是最主要用来进行网页效果预览。我这里用的是微信web开发者工具0.19.191900，现在最新版本是0.20.191900版本，功能基本一样，没什么大变化，不过建议使用最新版本，功能功能更强大，操作更方便。\r\n    2. [Atom编辑器]：主要用于布局排版，也是敲代码的主战场，真心觉得这个编辑器不错，快捷输入和排版，大大提高了开发效率，使用简单，一学就会。\r\n    3. [微信小程序开发者文档]：微信小程序开发的文档，资源库，以及API规范\r\n    4. [Iconfont-阿里巴巴矢量图标库]：提供项目中的所有图标，资源丰富。\r\n    5. [野狗实时通信云wilddog]：提供项目中数据的存储以及通信功能，实现微信登录。\r\n    6. [豆瓣开发者平台]：豆瓣电影的应用接口和开发规范说明文档\r\n三、.目录结构展示├── app.js\r\n├── app.json\r\n├── app.wxss\r\n├── pages\r\n│   ├── welcome\r\n│   ├── mine\r\n│   ├── comingSoon\r\n│   └── top250\r\n│   ├── detail\r\n│   ├── search\r\n│   ├── video\r\n│   └── index\r\n│   └── log\r\n├── wilddog-weapp.js\r\n├── images\r\n└── utils\r\n  └── util.js\"pages\":[\r\n\"pages/welcome/welcome\",            //电影首页\r\n\"pages/mine/mine\",                  //我的信息页\r\n\"pages/comingSoon/comingSoon\",    //近期上映列表页\r\n\"pages/inTheaters/inTheaters\",     //热门电影列表页\r\n\"pages/top250/top250\",         //top250电影列表页\r\n\"pages/detail/detail\",           //电影详情页\r\n\"pages/search/list\",            //电影搜索页\r\n\"pages/video/video\"          //电影播放页\r\n]四、效果预览项目github地址：https://github.com/webstormsh...说明：由于项目中所有电影数据是通过请求豆瓣官方提供API远程获取，微信授权登录是通过第三方野狗平台实现，所以加载速度可能稍微有点慢，视频播放功能由于不能获得电影视频资源地址，所以电影播放页面使用了一个固定的视频资源地址访问。五、项目实现功能列表  电影首页查看\r\n  栏目列表查看\r\n  电影详情查看\r\n  电影搜索查看\r\n  电影播放暂停弹幕\r\n  登录退出\r\n六、项目难点解析1.野狗平台API实现微信登录配置野狗官方API文档引用：\r\n\r\nwilddog.App 对象是野狗 Web SDK 的核心，它维护着应用的全局上下文数据，不同模块之间需要通过它来\r\n进行交互。同时 App 实例也是我们访问野狗各个功能模块的入口，所以初始化 App 实例是我们使用其他任\r\n何 API 接口的前提。要使用野狗的身份认证功能，你的初始化参数中必须包含 authDomain， 代码如下：\r\n\r\nvar config = {\r\n  authDomain: \"<appId>.wilddog.com\"\r\n};\r\nwilddog.initializeApp(config);\r\n初始化多个 App 实例\r\n//上面的代码相当于如下初始化动作\r\nvar wilddog = wilddog.initializeApp(config);\r\n//我们还可以使用不同配置声明多个不同的 App 实例\r\nvar configA = {\r\n  authDomain: \"<appId-a>.wilddog.com\"\r\n};\r\nvar a = wilddog.initializeApp(configA, \"APP_A\");\r\n//通过 a 来访问 auth\r\n//a.auth().signInXxx().then(...)\r\n\r\n**定义**  auth()\r\n**说明**获取 wilddog.Auth 实例，wilddog.Auth 实例只能通过此方法获取。\r\n**返回值**[wilddog.Auth](https://docs.wilddog.com/auth/Web/api/Auth.html)\r\n\r\n**定义**     sync()\r\n**说明**   获取 wilddog.Sync 实例，wilddog.Sync 实例只能通过此方法获取。\r\n**返回值**   [wilddog.Sync](https://docs.wilddog.com/sync/Web/api/App.html)新手由于对微信小程序的的目录结构以及微信提供的API不熟悉，可能不知道怎样实现微信授权登录，在这里为了操作简便，本人使用了wilddog提供的接口，让第三方代理实现微信登录(操作详情见开发文档)，而在项目中只需进行如下操作：将wilddog-weapp-all.js拷贝到根目录下，并在js中进行如下配置：App({\r\nonLaunch: function () {\r\nvar config = {\r\nsyncURL : \"https://sywx.wilddogio.com\",      //这里写wilddog中新建的项目域名\r\nauthDomain:'sywx.wilddog.com'                  \r\n}\r\nwilddog.initializeApp(config)\r\nthis.ref = wilddog.sync().ref('todo')\r\n},\r\nlogin:function(callback){\r\nconsole.log(callback);\r\nwilddog.auth().signInWeapp().then(function(user){\r\ncallback(user);\r\nwx.showToast({\r\ntitle: '登录成功',\r\n})\r\n}).catch(function(err){\r\nwx.showToast({\r\ntitle: '登录失败',\r\n})\r\n})\r\n},2.豆瓣电影API获取电影信息首先，应该要仔细阅读下豆瓣开发者平台的API文档，因为各个网站的提供的接口规范各不相同，所以需要搞明白他们使用的套路，我脑子不太好使，文档看了整整一天才搞明白；然后，在获取API链接的时候，应该注意不是所有的接口都全部开放的，有的数据无法获取，我试了好几个才找到能用的，所以在选择之前，应该提前测试以下是否可用，一般文档下面都会一个提供一个测试示例，最后在微信小程序中调用API的步骤可以参看下面项目中的代码：//全局变量数据配置 \r\nglobalData:{\r\n    userInfo:null,\r\n    doubanBase:\"https://api.douban.com\",       //豆瓣电影api域名\r\n    inTheaters:\"/v2/movie/in_theaters\",        //热门电影URI\r\n    comingSoon:\"/v2/movie/coming_soon\",       //最近上映URI\r\n    top250:\"/v2/movie/top250\",                //top250电影URI\r\n    detail:\"/v2/movie/subject/\",              //电影详情URI\r\n    search:\"/v2/movie/search\"                 //电影搜索URI\r\n  }//拼接请求电影列表的URL并调用获取方法\r\n  onLoad:function(options){\r\n     var comingSoonURL = app.globalData.doubanBase + app.globalData.comingSoon+ \"?start=0&count=10\";\r\n    //  console.log(comingSoonURL);\r\n    // 页面初始化 options为页面跳转所带来的参数\r\n    this.getComingSoonListData(comingSoonURL,'comingSoon','近期上映');\r\n  }//获取近期上映电影列表并存放到data中\r\n  getComingSoonListData:function(url,settedKey,categoryTitle){\r\n      wx.showToast({\r\n        title:\"加载中\",\r\n        icon:'loading',\r\n        duration:10000\r\n      });\r\n      var that = this;\r\n      wx.request({\r\n        url:url,\r\n        method:'GET',\r\n        header:{\r\n          \"Content-Type\":\"json\",\r\n        },\r\n           success:function(res){\r\n              that.setData({\r\n                comingSoon:res.data.subjects,\r\n            })\r\n          }\r\n      });\r\n  }3.微信小程序API实现视频播放微信小程序自带媒体组件 video（视频）可以对视频媒体信息进行加载，播放等操作，并且可以对video组件的一些相关属性进行自定义，以下展示部分video组件的相关属性：                              video组件属性部分列表\r\n\r\n属性名            类型             默认值          说明                                   \r\nsrc              String                      要播放视频的资源地址\r\nduration         Number                      指定视频时长                       \r\ncontrols         Boolean           true      是否显示默认播放控件（播放/暂停按钮、播放进度、时间）\r\ndanmu-list       Object Array                弹幕列表\r\ndanmu-btn        Boolean          false      是否显示弹幕按钮，只在初始化时有效，不能动态变更\r\nautoplay         Boolean          false      是否自动播放\r\nloop             Boolean          false      是否循环播放\r\nmuted            Boolean          false      是否静音播放 //电影播放页面的wxml文件\r\n<!--pages/video/video.wxml-->\r\n<view class=\"section tc\">\r\n  <video id=\"myVideo\" src=\"http://wxsnsdy.tc.qq.com/105/20210/snsdyvideodownload?filekey=30280201010421301f0201690402534804102ca905ce620b1241b726bc41dcff44e00204012882540400&bizid=1023&hy=SH&fileparam=302c020101042530230204136ffd93020457e3c4ff02024ef202031e8d7f02030f42400204045a320a0201000400\"   enable-danmu danmu-btn controls></video>\r\n  <view class=\"btn-area\">\r\n    <input bindblur=\"bindInputBlur\" />\r\n    <button bindtap=\"bindSendDanmu\" type=\"primary\">发送弹幕</button>\r\n     <button"}
{"title": "实现一个扫描商品条码进行评价或留言的小程序（附源码） ", "author": "Rolan", "pub_time": "2018-9-5 00:08", "content": "对准上面的小程序码，扫一下，‘嘀’~地一声，扫码成功，打开小程序，进入小程序首页。因为手头上没有可乐，所以我找来了一只非常专业的猫，扮演一瓶330ml的可口可乐演示给大家看。摁住它，对准它的条码，扫一下，‘喵’~地一声，说明猫跑掉了，扫码失败了，去追如果‘嘀’~地一声，说明扫码成功了，这时页面就自动跳到商品详情页。然后你就可以看得到别人在可口可乐下写的留言，当然你也可以点击右下角的蓝色按钮就发表你的留言了；原理：因为一个商品对应唯一一个条码，所以扫描同一个商品条码就可以进入唯一一个留言列表；全国各地的可口可乐330ml的条形码都是一样的，扫码后都会进入同一个页面条形码就像一个暗号，一句口令，一个邮差.. 当然，不只是条形码，二维码也可以留言，比如说别人的微信二维码一般是长时间不会变的，你可以码上说别人坏话。接下来详细介绍一下每个页面的功能2.首页首页有三个部分：1.用户的信息：头像和昵称；2.轮播图-可以放一些平时要展示的图片；3.扫码按钮-点击即可打开扫描条码；当用户点击扫码按钮时，我们就调用小程序的扫码接口去扫描商品条码，当用户扫描好条码后，我们就得到了商品条码（barcode）；这时，我们就可以跳转到商品详情页面了，顺便把条码传过去，这样商品详情页才能知道用户扫的是什么商品：wx.navigateTo({\r\n          url: \"/page/component/proDtl/proDtl?barcode=\" + barcode,  //把商品条码传给商品详情页\r\n    })\r\n复制代码3.商品详情页进入详情页后，我们的第一件事情：在生命周期onLoad中获取首页传过来商品条码，然后根据条码请求当前商品的留言列表，如果这个商品还没有人扫过的话，就可能没有留言，那我们只要显示“暂无留言”即可onLoad(options){\r\n       var barcode = options.barcode ? options.barcode:'';\r\n       this.getProductInfo(barcode)  //根据条码请求当前商品的留言列表\r\n  },\r\n复制代码在getProductInfo（）方法中，我们会向后台请求商品留言列表； 接着我们就把请求到的商品留言列表渲染到页面上:如果用户觉得请求到的商品名称是不对的，还可以点击名称进行编辑：最后，页面底部还有一个提交留言的小按钮：如果你要发表留言，你可以用你的食指点击它：点击按钮后，小程序就会跳到添加留言页面，顺便把商品条码信息传过去：turnToSubmit(){\r\n    wx.navigateTo({\r\n      url: \"/page/component/addNode/addNode?barcode=\" + this.data.barcode,\r\n    })\r\n  },\r\n复制代码4.添加留言页面如图，这时候我们就可以开始写我们的留言了。写完留言之后，你可以标注一下你的留言类型：如果你觉得你写的是一首诗，你可以选择类型为‘诗一首’；如果你觉得你写的是一封信，等待别人扫码阅读，你可以选择类型为‘鱼书’；如果你扫描的是一本书的条码，你可以选择类型为‘书摘’；类型的右边就是是上传图片功能，首先，我们点击'添加图片'小图标，这时就会使用小程序选择图片的接口打开相册或者直接拍照，得到图片之后，因为现在的手机图片拍照像素都比较高，导致图片比较大，上传会很慢，占服务器空间，请求也会很慢...所以为了优化用户体验，我们需要压缩一下图片然后再上传。wx.chooseImage({\r\n      count: 1, // 默认9  \r\n      sizeType: ['original'], // 可以指定是原图还是压缩图，默认二者都有\r\n      sourceType: ['album', 'camera'], // 可以指定来源是相册还是相机，默认二者都有\r\n      success: function (res) {  //图片选择成功之后\r\n        \r\n               var tempFilePaths = res.tempFilePaths;\r\n               self.compressedImg(res)  //调用compressedImg方法，先把图片压缩一下\r\n\r\n        }\r\n  })\r\n复制代码虽然小程序的选择图片接口可以设置默认压缩，但好像没什么用，还是需要找其他的方法压缩一下， 网上最普遍的图片压缩是使用了小程序提供的canvas画布，把用户上传的图片搞到画布上（....），然后根据画布上的图片高和宽判断图片是否过大，如果过大，就直接把画布按比例缩小：while (canvasWidth > 220 || canvasHeight > 220) {  //如果宽度或者高度大于220，我就认为图片要进一步压缩，你可以根据需求改成其他的数字\r\n          //比例取整\r\n      canvasWidth = Math.trunc(res.width / ratio)\r\n      canvasHeight = Math.trunc(res.height / ratio)\r\n      ratio++;\r\n   }\r\n复制代码图片的压缩参考自：[微信小程序：利用canvas缩小图片][ blog.csdn.net/akony/artic… ]然后把canvas上这张压缩了的图片上传到后台服务器：......\r\n   wx.uploadFile({  //上传图片\r\n          url: 'https://mp.orancat.com/proImgUpload',\r\n          filePath: photo.tempFilePath,  //压缩后的图片\r\n          name: 'file',\r\n          header: {\r\n            'content-type': 'multipart/form-data'\r\n          },\r\n          success: function (res) {\r\n    .......          \r\n\r\n复制代码图片上传成功之后，后台会返回上传图片的地址给我们，我们把图片渲染到页面上，用户就会知道图片上传成功了；最后点击'提交'按钮，就会把以下内容发送给后台，后台就会自动将留言保存到数据库；var data={\r\n      authorName: userName, //用户昵称\r\n      token: userId,  //用户ID\r\n      content: this.data.textContent, //留言文本内容\r\n      imgUrl: userImg,  //用户的头像\r\n      code: this.data.barcode,  //商品的条码\r\n      typeIndex: this.data.typeIndex, //留言的类型\r\n      nodeImgUrl: this.data.nodeImgUrl //用户上传的图片的地址\r\n    }\r\n复制代码留言提交成功之后，页面会自动切回商品详情页面，这时，你就可以看到自己刚刚的留言了；5.排行榜页面有过留言的商品都会出现在排行榜页面，并且按照留言的数量多少进行排列，点击单个商品就查看该商品下的留言；6.其他实现的功能1.分页在商品详情页，有可能出现这种情况，比如说假设A商品有120条留言，如果一进A商品详情页就要加载120条留言的话，可能页面加载半天都没有出来；这样的话用户体验就会非常不好。所以相对理想的方式应该是，假设12条留言为一页，那么A商品的留言总共有10页，当我们进入A商品的详情页面时，先加载第一页（前12条留言），当我们往上滑动页面到底部时就自动加载下一页的内容，一页一页按需加载；我们使用小程序提供的OnReachBottom触底事件实现分页加载，当用户滑动留言列表到底部时触发加载下一页：onReachBottom: function () { //滑动到底部时触发\r\n       this.setData({\r\n           bottomLoading: true  // 显示loading提示\r\n       })\r\n       this.getRankList()  //请求下一页数据\r\n  }\r\n复制代码同理，排行榜页面也使用了分页加载；2.通过wx.login获取用户唯一凭证openId由于用户的昵称，头像什么的都可能随时会改变，当openID不会变，所以使用openId作为用户唯一凭证；虽然我获取了用户的Id，但暂时还没有使用到；如果以后要弄个用户个人主页或者留言回复等等可能就要用到openId；3.gif图片上传如上所述，在图片上传前，我们把图片压缩了一下 如果图片是jpeg，png时没问题的 但如果图片时gif动图的话，那可能会导致动图不会动了（可能直接变成jpeg图片？） 所以我另外加了一个判断：如果图片时gif格式的话，就不压缩图片,直接上传：if(res.type=='gif'){\r\n       if(res.width>666||res.height>666){ //如果图片太大了，拒绝上传\r\n         wx.hideLoading()\r\n         wx.showModal({\r\n           title: '提示',\r\n           content: '动图太大了，请上传小一点的',\r\n           showCancel: false\r\n         })\r\n         return false;\r\n       }\r\n       res.tempFilePath=res.path;\r\n       _this.uploadImg(res)  //上传图片\r\n       return false;\r\n    }\r\n复制代码这样在window和安卓下就可以上传gif图片了。苹果手机呢？？咳咳..苹果手机一打开相册选动图，动图就自动变成了jpeg的不动图...所以苹果手机暂时上传不了动图，似乎没有解决办法。。7.下载与本地电脑运行在本文底部的github地址下载源码，用微信开发者工具，填上你的小程序appId，打开项目即可；记得在开发者工具点击‘’详情‘’设置不校验域名：如果你要提交审核并分布小程序的话，你需要在公众号平台上的\"设置>开发设置\"页面上设置小程序的服务器域名如下：然后，由于一般电脑没有摄像头不能扫码，所以当你需要扫码时，你可以把下面这张条码图片保存在本地电脑上，点击扫码按钮时打开这张图片即可：当然，你也可以自己找其他的条码；另外，需要注意的是，当你在本地电脑调试时，由于我们都是使用同一个后台接口，所以你发的留言都会同步到我的小程序上，所以尽量不要发送太明显的测试留言，例如：可以发一些强颜欢笑，积极向上，人畜无害的留言，例如："}
{"title": "微信小程序开发问答《七十九》不能使用session如何解决 & 小程序处理JS很慢 ... ", "author": "Rolan", "pub_time": "2017-11-22 00:31", "content": "1、微信小程序请求不能使用session如何解决？A：本人在前面的微信小程序开发《二》中提到要想在服务端保持状态需要在客户端第一次请求服务器的时候给客户端返回一个sessionid，由客户端在本地保存，下次请求的时候在header里面带上这个sessionid，写到cookie字段里。但是最近发现请求时哪怕每次在header里带上sessionid还是不能拿到同一个session，百度后终于发现坑了（也不知道微信为啥要这么做），原来微信对wx.request这个API做了修改，小程序发起的请求并不是直接请求我们的后台服务器，而是先通过微信的服务器再发送到我们的后台服务器，既然请求都是要通过微信的服务器发送到我们的服务器，那么我们的服务器也就无从识别请求的发起者了。因此，session在微信小程序的后台开发中是无法使用的。 既然session无法使用，对于本人这种web的后端程序猿该如何是好，只能用别的方式来代替了哦。我用了redis来代替session的功能，当客户端发送请求到后台服务器时，生成一个随机字符串作为key，原本要放入session的内容，一般是用户信息作为value存入redis中，然后将key返回给客户端，客户端将key存在本地的storage，在下次请求的时候以参数据形式将key带上，这样当后端服务器接收到key时便可以从redis中查找该key对应的value，从而实现了替代session的效果，redis还可以设置key失效的时间。2、微信小程序报错: Cannot read property '0' of undefinedA:今天遇到了一个bug：VM4735:2 Uncaught TypeError: Cannot read property '0' of undefined查了很久发现是三目运算写错了，这种低级错误容易犯，而且又很难发现。最后是一段一段注释掉，用排除法来缩小范围来找到的。直接看代码很难发现。<view>{{param:1:2}}</view>to<view>{{param?1:2}}</view>3、小程序里面不支持document或window语法,那请问这里要用什么方式来代替? A:由于框架并非运行在浏览器中，所以 JavaScript 在 web 中一些能力都无法使用，如 document，window 等。 https://mp.weixin.qq.com/debug/wxadoc/dev/api/api-react.htmlhttps://mp.weixin.qq.com/debug/wxadoc/dev/framework/view/wxml/data.html4、为啥小程序处理JS很慢很慢 ？我在网页上跑 这一段代码一两秒就可以了，在小程序上跑了10秒左右，这段代码有130行左右，一直循环匹配，太耗性能了吧，在网页上还好。小程序里太慢了！A：看样子应该是你数据量太大了，调用setData之后觉得卡顿，建议不要用setData传输太大的数据（可以分块传输） https://mp.weixin.qq.com/debug/wxadoc/dev/framework/performance/tips.html"}
{"title": "微信小程序开发手记《五》：组件 ", "author": "天下雪", "pub_time": "2017-4-25 00:05", "content": "作者：王梵，来自授权地址iconicon组件有3个属性，如下：type，可选值：success, success_no_circle, info, info_circle，warn, waiting, cancel, download, search, clearcolor，如#C9C9C9。size，默认为23px。先看一张效果图： 再看具体的wxml和wxss。<view class=\"demo-view-4\">\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"circle\" />\r\n        <view class=\"margin\">circle：多选未选中</view>\r\n    </view>\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"success\" />\r\n        <view class=\"margin\">success：成功或已选中</view>\r\n    </view>\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"success_no_circle\" />\r\n        <view class=\"margin\">success_no_circle：单选已选中</view>\r\n    </view>\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"info\" />\r\n        <view class=\"margin\">info：信息提示</view>\r\n    </view>\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"warn\" color=\"#C9C9C9\" />\r\n        <view class=\"margin\">warn-#C9C9C9：普通警告</view>\r\n    </view>\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"warn\" />\r\n        <view class=\"margin\">warn：强烈警告</view>\r\n    </view>\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"waiting\" />\r\n        <view class=\"margin\">waiting：等待</view>\r\n    </view>\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"download\" />\r\n        <view class=\"margin\">download：可下载</view>\r\n    </view>\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"info_circle\" />\r\n        <view class=\"margin\">info_circle：有信息提示</view>\r\n    </view>\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"cancel\" />\r\n        <view class=\"margin\">cancel：停止或关闭</view>\r\n    </view>\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"search\" />\r\n        <view class=\"margin\">search：搜索</view>\r\n    </view>\r\n\r\n    <view class=\"view-1\">\r\n        <icon class = \"margin\" type=\"clear\" />\r\n        <view class=\"margin\">clear：删除</view>\r\n    </view>\r\n\r\n    <view class=\"view-1\">\r\n        <view class=\"margin\">PS:每个type都可以设置颜色(color),大小(size)</view>\r\n\r\n    </view>\r\n\r\n\r\n</view>1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575812345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758.demo-view-4{\r\n    display:flex;\r\n    height: 100%;\r\n    flex-direction: column;\r\n}\r\n\r\n.view-1{\r\n    display:flex;\r\n    height: 100%;\r\n    flex-direction: row;\r\n}\r\n\r\n.margin{\r\n    margin: 20rpx;\r\n}123456789101112131415123456789101112131415text效果图如下： wxml如下：<text>My name is wisely。\\n I am a Androider！</text>11progressprogress组件的属性如下：属性名类型默认值说明percentFloat无百分比0~100show-infoBooleanfalse在进度条右侧显示百分比stroke-widthNumber6进度条线的宽度，单位pxcolorColor#09BB07进度条颜色 （请使用 activeColor）activeColorColor已选择的进度条的颜色backgroundColorColor未选择的进度条的颜色activeBooleanfalse进度条从左往右的动画效果图如下： <view class=\"demo-view-4\">\r\n\r\n    <progress class = \"margin\" percent=\"60\" show-info/>\r\n\r\n    <progress class = \"margin\" percent = \"80\" active activeColor = \""}
{"title": "微信小程序---绘制指令 ", "author": "Rolan", "pub_time": "2018-3-30 00:08", "content": "小程序文档：https://developers.weixin.qq.com/miniprogram/dev/创建小程序很简单，按文档走几步就行；生成的工程目录如下：其中app.json和project.config.json是配置文件。app.json{  \"pages\":[    \"pages/index/index\"  ],  \"window\":{    \"backgroundTextStyle\":\"light\",    \"navigationBarBackgroundColor\": \"#fff\",    \"navigationBarTitleText\": \"\",    \"navigationBarTextStyle\":\"black\"  }}pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。window字段 —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。 看下本例子中的主页面: (page/index)这是经典的 HTML + CSS + JS 样式，wxss相当于css样式，wxml相当于html，js就是js样式，json用于描述数据。在wxml中定义一个Canvas组件:<canvas canvas-id=\"myCanvas\"></canvas>在index.js中进行绘制：Page({  data: {    winNum: 0  },  //生命周期，刚进来  onLoad: function () {  },  canvasIdErrorCallback: function (e) {    console.error(e.detail.errMsg)  },  onReady: function (e) {    // 使用 wx.createContext 获取绘图上下文 context    var ctx = wx.createCanvasContext('myCanvas')    ctx.strokeRect(10, 10, 25, 15)    ctx.setLineWidth(1)    ctx.scale(2, 2)    ctx.strokeRect(10, 10, 25, 15)    ctx.scale(2, 2)    ctx.strokeRect(10, 10, 25, 15)    ctx.draw()  }})绘制的方式如上，先从组件创建一个上下文，接着调用上下文的绘制api，最后draw出来。看下绘制效果：这段绘制程序，就是用不同比例进行矩形绘制，而且这个scale是可以叠加的。更多绘制api的说明文档如下：https://developers.weixin.qq.com/miniprogram/dev/api/canvas/reference.html问题是，这里的js绘制指令，在android客户端上是怎么执行的？先讲下过程：前端的调用绘制指令的js代码，其实是在一个js的对象上操作的，这些绘制指令会将信息汇聚到这个对象中。前端和客户端的交互，是通过webview的js bridge来进行的，客户端注册webview的js监听（addJavascriptInterface），收到相关数据（定义好的数据协议），然后再还原成像绘制指令一样的列表，再进行端上绘制。补充：其中的数据格式，也是一个绘制列表，比如每个绘制指令是一个action结构的话，那么就是一个action列表的结构。 具体一点：前端写了js代码：    ctx.strokeRect(10, 10, 25, 15)    ctx.scale(2, 2)    ctx.strokeRect(10, 10, 25, 15)    ctx.draw()那么汇聚得到的传输数据大概是这样：\"canvasId\":\"myCanvas\",\"actions\":\"[{\\\"method\\\":\\\"strokeRect\\\",\\\"data\\\":[10,10,25,15]},{\\\"method\\\":\\\"setLineWidth\\\",\\\"data\\\":[1]},{\\\"method\\\":\\\"scale\\\",\\\"data\\\":[2,2]},{\\\"method\\\":\\\"strokeRect\\\",\\\"data\\\":[10,10,25,15]},{\\\"method\\\":\\\"scale\\\",\\\"data\\\":[2,2]},{\\\"method\\\":\\\"strokeRect\\\",\\\"data\\\":[10,10,25,15]}]\"在客户端上先解析这些数据，形成类似的Action列表数据，然后在View的onDraw中把这些指令绘制出来。过程大体如此，那么绘制指令其实可以分为几批次，比如上下文相关的，形变类的，普通绘制（比如矩形，文本等）；在客户端的实现中，一定要注意执行的顺序（包括设定上下文的），不能在解析数据的时候就立即执行上下文设定否则会错乱。另外微信绘制api基本是和android对齐的，因为大部分都有相同的绘制名称和参数对应上；ios的话就可能有点儿麻烦了。。。先到这里。"}
{"title": "微信小程序开发问答《八十一》修改循环item中的属性值 & 如何清除图片缓存？ ... ", "author": "Rolan", "pub_time": "2017-12-25 00:42", "content": "1、小程序可以修改循环出来的item中的属性值么？修改后并在页面上修改<view class=\"index-list-item\" wx:for=\"{{listData}}\" data-id=\"{{item.id}}\" data-qr=\"{{item.qr_url}}\" data-view=\"{{item.view_int}}\" catchtap=\"OpenDialog(item)\">\r\n  <image src=\"{{item.thumb_url}}\"></image>\r\n  <text class=\"list-item-name\">{{item.wx_name}}</text>\r\n  <text class=\"list-item-view\">浏览量:{{item.view_int}}</text>\r\n  <view class=\"list-item-redicon\" wx:if=\"{{item.is_fensibao}}\"></view>\r\n  </view>就像上面的点击事件，我的浏览量是可以在我点击后随着我修改item的值而修改，我在vue中是直接把item这个对象传到事件中直接操作，但是小程序中话好像不能直接传过去，请问该怎么做呢？求教答：小程序修改值需要调用 this.setState({value: newvalue})，而且你想改变item的值，正确的方式是更新 listData 。先绑定；data-item=\"{{item}}\"在事件处理函数里用event.currentTarget.dataset.item拿到当前item。2、两个省市区地址库，该如何转换？如果有做过微信小程序的都知道，微信小程序的地址有一键添加的功能，就是把用户在微信上的地址拿过来存到自己的系统上。那么，问题来了，我们系统上得省市区是用早期的淘宝省市区库，而微信的地址是用国家2013年的省市区库。例子1：系统： 北京 北京市 朝阳区微信： 北京市 北京市 朝阳区例子2：系统：湖北省 仙桃市 xx区 微信： 湖北省 省直辖县级行政区划 仙桃市例子一很好理解，就是同一个地方，但两个库的名称有点不一样例子二就麻烦了，一个地方，在系统上是属于市级单位，在微信上是属于区单位，这就尴尬了有什么好的方法，可以将微信一键导入的地址完美匹配上系统的地址。答：没有简单的办法。不过使用模式识别的一些算法，单纯提出省，市，区信息，再最优匹配当前信息，然后给个结果，应该不难。3、微信小程序支付，服务端一直没有收到回调微信小程序支付成功后，服务器一直没有收到支付回调请求统一下单时地址已经传入了并且域名在小程序后台也是request合法域名回调地址外网访问也没问题：https://sharelover.cnxz999.co...答：这你得排查一下，是你回调的地址没有正确接收并处理回调信息让你以为没有回调，还是确实是微信那边就没有回调，如果是微信那边就没有任何请求过来，那就得看下你下单时候的回调地址设置了，或者你没把这个回调地址加到回调通知白名单？换成http就可以了，具体原因不明。4、微信小程序如何清除图片缓存？无论我删除小程序还是清除微信设置里通用里的缓存，都没用。服务器的图片确实已更新了。删除服务器图片依然能显示出来。答：如果是iphone、直接把微信删了、与微信相关的数据都没了、给图片重新命名试试、给图片后缀加个时间戳。"}
{"title": "小程序-记牌器 ", "author": "Rolan", "pub_time": "2018-9-7 00:06", "content": "这个想法来自看直播时看主播斗地主时经常由于没有记牌器，判断失误导致输豆，所以做了这个记牌器。估计不会有人用 :laughing:，就当作练手，熟悉小程序的整个开发流程哈哈。 没想到提交第二天就审核通过了截图思路比较简单只有一个页面1.可选一副牌或两副牌2.点击相应牌减少对应牌的数量, 数量为0时该图标变灰3.可撤销，撤销操作仅保留最近100个点击操作4.重置操作会清空所有操作记录开发上选择的是 mpvuempvue.com/然后直接使用grid布局对卡牌进行排列<div class=\"gird-container\">\r\n  <div class=\"gird-item\" v-for=\"(poker, index) in pokers\" :key=\"index\">\r\n    <card :poker=\"poker\" :index=\"index\" @handleHuase=\"handleHuase\" @handleWang=\"handleWang\">\r\n    </card>\r\n  </div>\r\n</div>\r\n复制代码操作方法// 点击操作\r\nhandleHuase (obj) {\r\n// 这里用来记录操作历史\r\nthis.updateHistory.push(JSON.parse(JSON.stringify(this.pokers)))\r\n  if (this.pokers[obj.index][obj.huase] > 0) {\r\n    this.pokers[obj.index][obj.huase] -= 1\r\n    this.pokers[obj.index].count -= 1\r\n  } else {\r\n    this.pokers[obj.index][obj.huase] = this.defaultCount\r\n    this.pokers[obj.index].count += 1\r\n  }\r\n}\r\n复制代码// 撤销操作\r\nrollback () {\r\n  let pokers = this.updateHistory[this.updateHistory.length - 1]\r\n  this.pokers = pokers\r\n  this.updateHistory.pop(this.updateHistory.length - 1)\r\n}\r\n复制代码git地址github.com/jinggoing/m…"}
{"title": "小程序上传一张或多张图片到阿里云OSS ", "author": "Rolan", "pub_time": "2018-6-29 00:32", "content": "效果图：效果图 一.准备工作1.登录阿里云服务器配置需要的参数AccessKeySecret和OSSAccessKeyId。2.Base64,hmac,sha1,crypto相关算法签名算法去下载3.WeUI组件上传图片（使用方法请参考https://www.jianshu.com/p/010cea4202b8）4.上传图片主要的代码为： uploadAliyun.js注意：在小程序的配置位置如图：项目中js的位置 5.选图片的方法：点击确定上传到的代码（多张图片）：uploadImg.wxss代码：@import \"../../weui.wxss\"; 6.上传成功后的结果如图：结果 其中images/http://tmp/wx1b4e5e756cd48af1.o6zAJsws4grEQvYrWTjBigy-6QaU.0llhudiKSF2V955a1c48350d9328ef064b4d36d12746.jpg 就是在阿里云服务器的图片名称，拼接上\"http://yijiao.oss-cn-qingdao.aliyuncs.com/images/http://tmp/wx1b4e5e756cd48af1.o6zAJsws4grEQvYrWTjBigy-6QaU.0llhudiKSF2V955a1c48350d9328ef064b4d36d12746.jpg\"才是完整图片。该demo gitHub的下载地址：https://github.com/dt8888/uploadImage，如有疑问请发简信给我，定会回复。"}
{"title": "小程序如何更换主体以及修改管理员权限？ ", "author": "Rolan", "pub_time": "2017-10-14 00:34", "content": "小程序可以更换主体吗？目前还不可以。我们知道，微信公众号可以更新注册主体及主体类型，但如果你在公众平台查看小程序的主体类型，微信会提示主体类型和名称不可修改。也就是说，目前小程序还不能更改注册主体，也就意味着不能迁移给其他主体。橙子君用个人主体的小程序做了一次测试，想通过更换小程序管理员，进而更改注册主体信息。但在我们操作的时候发现，微信要求新管理员微信号必须绑定相同主体的实名信息才能更换，也就是说，两个微信号必须绑定同一个名字的银行卡才行。所以，个人主体的小程序暂时不能向企业迁移。同理，组织类型的小程序也不能迁移给其他企业。小程序如何更换管理员权限？1.登录微信公众平台（mp.weixin.qq.com）。2. 在左侧菜单栏，点击「用户管理」，然后在「管理员」项中，就可以看到现有的管理员微信号，点击该微信号右上角的「修改」。3.点击「修改」后，需要现有管理员的微信进行扫码验证，请提前准备好。4. 通过验证后，按照页面提示，填写新管理员的信息，按要求用新管理员微信进行扫码验证，注意，整个过程不要超过5分钟。当然，并不是所有的小程序都可以更换管理员，个人主体的小程序只能更换给相同主体的管理员，即绑定了同一主体实名信息的微信。除此之外，所有组织类型的小程序，都可以更换小程序管理员权限。搜索复制"}
{"title": "制作todo list微信小程序 ", "author": "Rolan", "pub_time": "2018-8-27 00:16", "content": "今天给大家分享如何制作todo list微信小程序。资源视频 - BiliBili，制作ToDo List微信小程序http://v.youku.com/v_show/id_XMzc5NjgwMDM5Ng==.html， YouTube源码地址 - https://github.com/JKooll/sha...工具微信开发者工具 v1.02微信小程序框架文档weui for 小程序 基础样式库过程打开微信开发工具，创建新项目导入weui for 小程序 基础样式库下载weui for 小程序源码在项目中创建目录src/wxss/复制dist/style/weui.wxss文件到项目src/wxss/目录下在全局引入weui基础样式库打开app.wxss文件添加代码到开头@import './src/wxss/weui.wxss';创建todo页面打开app.json在pages数组第一行中添加pages/todo/todo,保存文件添加tasks数据打开pages/todo/todo.js在data对象中添加tasks数据tasks每个元素包含三个字段：content: 内容key: 键status: true - 完成状态， false - 未完成状态渲染tasks列表打开pages/todo/todo.wxml清空文件添加如下代码到文件， 保存文件<view class=\"page\">\r\n\r\n  <view class=\"page__bd\">\r\n\r\n    <view class=\"weui-cell\">\r\n      <view class=\"weui-cell__bd\">\r\n        <input class=\"weui-input\" placeholder=\"添加新任务\"/>\r\n      </view>\r\n\r\n      <view class=\"weui-cell__ft\">\r\n        <button class=\"weui-btn\" type=\"primary\">添加</button>\r\n      </view>\r\n    </view>\r\n\r\n    <view class=\"weui-cells__title\">待办事项</view>\r\n    <view class=\"weui-cells weui-cells__after-title\">\r\n      <radio-group>\r\n\r\n        <block wx:for=\"{{tasks}}\" wx:key=\"value\" wx:if=\"{{!item.status}}\">\r\n          <label class=\"weui-cell weui-check__label\">\r\n            <radio class=\"weui-check\" value=\"{{item.value}}\"></radio>\r\n\r\n            <view class=\"weui-cell__hd weui-check__hd_in-checkbox\">\r\n              <icon class=\"weui-icon-checkbox_circle\" type=\"circle\" size=\"23\" wx:if=\"{{!item.checked}}\"></icon>\r\n            </view>\r\n            <view class=\"weui-cell__bd\">{{item.content}}</view>\r\n\r\n            <view class=\"weui-cell__ft\"><button class=\"weui-btn\" type=\"warn\">删除</button></view>\r\n          </label>\r\n        </block>\r\n        \r\n      </radio-group>\r\n    </view>\r\n\r\n    <view class=\"weui-cells__title\">完成事项</view>\r\n    <view class=\"weui-cells weui-cells__after-title\">\r\n      <radio-group>\r\n\r\n        <block wx:for=\"{{tasks}}\" wx:key=\"value\" wx:if=\"{{item.status}}\">\r\n          <label class=\"weui-cell weui-check__label\">\r\n            <radio class=\"weui-check\" value=\"{{item.value}}\"></radio>\r\n\r\n            <view class=\"weui-cell__hd weui-check__hd_in-checkbox\">\r\n              <icon class=\"weui-icon-checkbox_success\" type=\"success\" size=\"23\"></icon>\r\n            </view>\r\n\r\n            <view class=\"weui-cell__bd\">{{item.content}}</view>\r\n\r\n            <view class=\"weui-cell__ft\"><button class=\"weui-btn\" type=\"warn\">删除</button></view>\r\n          </label>\r\n        </block>\r\n        \r\n      </radio-group>\r\n    </view>\r\n    \r\n  </view>\r\n\r\n</view>改变task状态打开pages/todo/todo.wxml待办事项和完成事项下的label更改为<label class=\"weui-cell weui-check__label\" data-value=\"{{item.value}}\" bindtap=\"changeTaskStatus\">bindtap=\"changeTaskStatus\" 绑定点击事件data-value=\"{{item.value}}\" 将task的value值传递给changeTaskStatus函数打开pages/todo/todo.js, 添加changeTaskStatus, 保存文件查看效果changeTaskStatus: function (e) {\r\n    let value = e.currentTarget.dataset.value;\r\n\r\n    let tasks = this.data.tasks;\r\n\r\n    let index = tasks.findIndex(task => task.value == value);\r\n\r\n    if (index < 0) {\r\n      return;\r\n    }\r\n\r\n    tasks[index].status = !tasks[index].status;\r\n\r\n    this.setData({\r\n      tasks: tasks\r\n    });\r\n  }删除task打开pages/todo/todo.wxml待办事项和完成事项下的button更改为button class=\"weui-btn\" type=\"warn\" data-value=\"{{item.value}}\" catchtap=\"removeTask\">删除</button>catchtap=\"removeTask\" 绑定点击事件，和bindtap区别在于它阻止事件冒泡 【更多】data-value=\"{{item.value}}\" 将task的value值传递给removeTask函数打开pages/todo/todo.js, 添加removeTask函数, 保存文件查看效果添加task创建task打开pages/todo/todo.wxml将添加新任务下的input更改为<input class=\"weui-input\" placeholder=\"添加新任务\" bindinput=\"typeNewTask\" value=\"{{newTask}}\"/>bindinput=\"typeNewTask\" 绑定input事件value=\"{{newTask}}\" 绑定newTask到input valu，可以用来初始化input中的内容打开pages/todo/todo.js在data对象中添加两个新的变量, newTask: '', key: ''newTask 保存新的task的内容key 保存下一个task value值添加typeNewTask，更新newTask变量的值typeNewTask: function(e) {\r\n    this.setData({\r\n      newTask: e.detail.value.trim()\r\n    });\r\n  },保存task打开pages/todo/todo.wxml将添加新任务下的button更改为<button class=\"weui-btn\" type=\"primary\" bindtap=\"addTask\" disabled=\"{{newTask == ''}}\">添加</button>bindtap=\"addTask\" 绑定点击事件disabled=\"{{newTask == ''}}\" 当newTask为空时，禁用button打开pages/todo/todo.js清空data中tasks变量的内容， tasks: []添加addTask函数，保存文件查看效果addTask: function () {\r\n    let tasks = this.data.tasks;\r\n    let key = this.data.key;\r\n\r\n    let newTaskObj = { content: this.data.newTask, value: key++, status: false };\r\n    tasks.push(newTaskObj);\r\n\r\n    this.setData({\r\n      tasks: tasks,\r\n      key: key,\r\n      newTask: ''\r\n    });\r\n  },完成作者：jkol原文：https://segmentfault.com/a/1190000016151643"}
{"title": "微信小程序开发问答《八十》实现 sticky header 效果 & input标签中文字被遮盖 ... ", "author": "Rolan", "pub_time": "2017-11-27 00:34", "content": "1、微信小程序列表能否实现 sticky header 效果？就像 iOS 的列表一样，上滑的时候每个 section 的 header 固定，直到滚动到下一个 section 的时候下一个 header 把上一个 header「顶走」。类似 https://codepen.io/chrissp26/...点击预览鉴于小程序没有 DOM 相关 API，不知道如何实现这种效果。Update: 我看到京东小程序的首页有类似效果，所以理论上是可以做到的？另，非回答类的回复请直接在问题下评论，不要开回答。A：1.4.0 小程序开始有 WXML节点信息的API可以通过这个来进行操作。里面有一个boundingClientRect 不正是可以利用的API？https://mp.weixin.qq.com/debu...css3新增的一个position属性可以直接实现sticky的效果在你的header中加上{\r\n  position: sticky;\r\n  top: 0;\r\n}就可以了2、微信小程序中的在退出后再进入时，canvas中的定时动画效果异常我在入口页做了一个圆从里向外扩大循环往复的canvas动画效果，在开发工具测试是没有问题的，然后在真机测试时发现第一次进入也是没有问题的，但是若是在使用中退出小程序再进入就会出现动画的效果变得非常的快，下面是简单的代码（需要图片资源的部分可以注释掉），可以在真机测试下<view class=\"home\">\r\n  <view class='home-header clearfix'>\r\n    <view class='home-person' bindtap=\"ToUserCenter\">\r\n      <view class='home-personwrap'>\r\n        <image src='../../static/person.png'></image>      \r\n      </view>\r\n    </view>\r\n  </view>\r\n    <canvas canvas-id='button' id='button' bindtap='ToIndex'>\r\n    </canvas> \r\n</view>\r\nPage({\r\n\r\n  /**\r\n   * 页面的初始数据\r\n   */\r\n  data: {\r\n    range:40,\r\n    PictempFilePath:'',\r\n  },\r\n  StartLogin(){\r\n    qcloud.login({\r\n      success(result) {\r\n        console.log('登录成功', result);\r\n      },\r\n\r\n      fail(error) {\r\n        console.log('登录失败', error);\r\n      }\r\n    });\r\n  },\r\n  ToUserCenter(){\r\n    wx.navigateTo({\r\n      url: '../usercenter/usercenter',\r\n    })\r\n  },\r\n  ToIndex(){\r\n    wx.navigateTo({\r\n      url: '../index/index',\r\n    })\r\n  },\r\n  \r\n  drawImage(){\r\n    let ctx = wx.createCanvasContext('button')\r\n    ctx.translate(75,75)\r\n    \r\n    ctx.arc(0, 0, this.data.range, 0, 2 * Math.PI)\r\n    ctx.drawImage('../../static/btn.png', -60, -60, 120, 120)\r\n    ctx.setLineWidth(5)\r\n    ctx.setStrokeStyle('#ff7058')\r\n    ctx.setGlobalAlpha(0.8)\r\n    ctx.stroke()\r\n    ctx.draw()\r\n  },\r\n  RepetDraw(){\r\n    clearInterval(t)\r\n    var t = setInterval(() => {\r\n      if (this.data.range < 65) {\r\n        var range = this.data.range + 1\r\n        this.setData({\r\n          range: range\r\n        })\r\n      } else {\r\n        this.setData({\r\n          range: 50\r\n        })\r\n      }\r\n\r\n      this.drawImage()\r\n    }, 130)\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  onLoad: function (options) {\r\n    // this.Downloader()\r\n   \r\n    // this.StartLogin()\r\n  },\r\n\r\n  /**\r\n   * 生命周期函数--监听页面初次渲染完成\r\n   */\r\n  onReady: function () {\r\n    this.RepetDraw()\r\n  }\r\n\r\n})A：退出的时候清除循环:clearInterval(timer).3、微信小程序input标签中文字被遮盖的问题wxml代码<input type='text' placeholder='请输入验证码' class='test'></input>wxss代码.test{\r\n  margin-top:100rpx;\r\n  width:50%;\r\n}\r\ninput {\r\n  display:block;\r\n  height:1.4rem;\r\n  text-overflow:clip;\r\n  overflow:hidden;\r\n  white-space:nowrap;\r\n  font-family:UICTFontTextStyleBody;\r\n  min-height:1.4rem;\r\n}\r\n疑惑：明明还有空间的，为什么文字会显示不全A:不知道是不是bug，微信小程序里input宽度缩小，input可输入文字的区域会缩小的更多，比如说你把input宽度设置为90%，则input文字输入可显示的区域可能只有80%左右。目前的解决方法：在input输入框外面套一层view，通过改变view的宽度控制input的长度，这样不会影响文字显示.4、小程序运用编译错误github想下载的demo 运行报错，大神求助A:问题解决了，在控制台输入openVendor() ，清除里面的wcsc wcsc.exe 然后重启工具。"}
{"title": "一个 JS 库就能解决小程序跨页传递事件消息和数据 ", "author": "Rolan", "pub_time": "2018-8-21 00:37", "content": "由于微信小程序 wx.navigateBack 方法并不支持返回传值，导致页面在返回后，不能方便地即时更新数据。一.需求分析此类需求大概意思是：A 页面进入 B 页面，B 页面返回并传值给 A或在B页面触发事件时，A页面也有事件触发改变。业务分析普遍方法为： 第一种：利用微信的 wx.setStorage，将数据缓存在小程序实例内。从 B 页面返回 A 页面时，B 页面先将数据缓存；然后在 A 页面的 onshow 方法里，调用 wx.getStorage 读取缓存来实现。但为日后维护带来大量隐患。（用全局变量方法类似）第二种：获取前一个 page 实例的方法，也可以实现此功能。部分代码如下：var pages = getCurrentPages();var currPage = pages[pages.length - 1];   //当前页面var prevPage = pages[pages.length - 2];  //上一个页面//直接调用上一个页面的 setData() 方法，把数据存到上一个页面中去prevPage.setData({  mdata:1 })这种方法的弊端：因为进入 B 页面的入口可能是很多个。这样做，可能会导致获取到的页面实例不正确。二.方法介绍（onfire.js的下载地址https://github.com/hustcc/onfire.js） 下面进入正题介绍onfire.js（） onfire.js 是一个很简单的事件分发 JavaScript 库（仅仅 0.9kb），简洁实用。它可以应用于: 1.简单的事件分发。 2.在 React、Vue.js、Angular 中用于跨组件的轻量级实现。 3.事件订阅和发布。使用思路：（做过移动端开发的都知道，类似于iOS的通知和安卓的广播） a.A 页面先订阅一个事件，并定义处理方法； b.从 B 页面返回时，发送消息； c.A 页面卸载时，解除订阅。我的使用方法为： A 页面代码：var onfire = require(\"../utils/onfire.js\");var that;var eventObj = onfire.on('key', function () {    // 当消息被传递时，做具体的事});Page({  data: {  },  onLoad: function(options) {    // Do some initialize when page load.  },  onReady: function() {    // Do something when page ready.  },  onUnload: function (e) {    onfire.un('key');    onfire.un(eventObj);//移除  }})我们可以在 A 页面直接调用 onfire.on 方法，订阅一个名字为 key 的消息。在上面的代码中，消息附带的参数无传参。 如果需要传参的话，直接在 function 里增加参数即可，例如：var eventObj = onfire.on('key', function (data){  // 执行操作})需要注意的是，一定要在 onUnload 里（在页面被关闭时）取消订阅消息，并取消绑定 eventObj。B 页面里代码在回调的地方加入以下代码：onfire.fire('key');//key 为上文中订阅的消息   // 有参数时   onfire.fire('key','test');三.分析库代码function _bind(eventName, callback, is_one, context) {    if (typeof eventName !== string_str || typeof callback !== function_str) {      throw new Error('args: '+string_str+', '+function_str+'');    }    if (! hasOwnKey(__onfireEvents, eventName)) {      __onfireEvents[eventName] = {};    }    __onfireEvents[eventName][++__cnt] = [callback, is_one, context];    return [eventName, __cnt];  }从代码中可以看出订阅 on 方法的时候，实际调用 _bind 方法。该方法利用一个二维数组，来存储订阅的对象。 function _fire_func(eventName, args) {    if (hasOwnKey(__onfireEvents, eventName)) {      _each(__onfireEvents[eventName], function(key, item) {        item[0].apply(item[2], args); //执行订阅时的方法        if (item[1]) delete __onfireEvents[eventName][key]; // 当类型为只订阅一次时，通知后即移除自己。      });    }  }而 fire 发送消息方法的实质，是调用 _fire_func 方法，通过名字（key）来遍历订阅者，然后通知订阅者。function un(event) {    var eventName, key, r = false, type = typeof event;    if (type === string_str) {      // 如果存在key值，则移除数组      if (hasOwnKey(__onfireEvents, event)) {        delete __onfireEvents[event];        return true;      }      return false;    }    else if (type === 'object') {      eventName = event[0];      key = event[1];      //如果找到这个对象则卸载      if (hasOwnKey(__onfireEvents, eventName) && hasOwnKey(__onfireEvents[eventName], key)) {        delete __onfireEvents[eventName][key];        return true;      }      //否则返回false      return false;    }    else if (type === function_str) {        //两层循环来判断方法名      _each(__onfireEvents, function(key_1, item_1) {        _each(item_1, function(key_2, item_2) {          if (item_2[0] === event) {            delete __onfireEvents[key_1][key_2];            r = true;          }        });      });      return r;    }    return true;  }调用un方法，通过名字（key）来遍历订阅者，找到后移除。注：因为卸载支持按 key、对象、方法卸载，所以需要先判断类型，然后按各自规则去解除绑定。作者：honey缘木鱼"}
{"title": "vue与微信小程序的一些区别 ", "author": "Rolan", "pub_time": "2018-2-27 00:21", "content": "一.条件渲染vue:使用v-if指令，v-else表示v-if的else块，v-else-if表示v-if 的“else-if 块” 1 <div v-if=\"type === 'A'\">\r\n 2   A\r\n 3 </div>\r\n 4 <div v-else-if=\"type === 'B'\">\r\n 5   B\r\n 6 </div>\r\n 7 <div v-else-if=\"type === 'C'\">\r\n 8   C\r\n 9 </div>\r\n10 <div v-else>\r\n11   Not A/B/C\r\n12 </div>微信小程序：使用wx:if,wx:else表示wx:if的else块，wx:elif表示wx:if的\"else-if\"块<view wx:if=\"{{length > 5}}\"> 1 </view>\r\n<view wx:elif=\"{{length > 2}}\"> 2 </view>\r\n<view wx:else> 3 </view>二.显示隐藏元素VUE:v-show=\"...\"微信小程序：hidden=\"{{...}}\"三.绑定classvue:全用v-bind，或者简写为:bind,和本有的class分开写<div class=\"test\" v-bind:class=\"{ active: isActive }\"></div>微信小程序：<view class=\"test {{isActive ? 'active':'' }}\"></view>四.事件处理VUE：使用v-on:event绑定事件，或者使用@event绑定事件<button v-on:click=\"counter += 1\">Add 1</button><button v-on:click.stop=\"counter+=1\">Add1</button>  //阻止事件冒泡微信小程序：全用bindtap(bind+event)，或者catchtap(catch+event)绑定事件<button bindtap=\"clickMe\">点击我</button><button catchtap=\"clickMe\">点击我</button>  //阻止事件冒泡五.绑定值VUE:vue动态绑定一个变量的值为元素的某个属性的时候，会在变量前面加上冒号：，例：<img :src=\"imgSrc\"/>微信小程序：绑定某个变量的值为元素属性时，会用两个大括号括起来。例：<image src=\"{{imgSrc}}\"></image>六.绑定事件传参VUE:vue绑定事件的函数传参数时，可以把参数写在函数后面的括号里<div @click=\"changeTab(1)\">哈哈</div>微信小程序：微信小程序的事件我试过只能传函数名，至于函数值，可以绑定到元素中，在函数中获取<view data-tab=\"1\" catchtap=\"changeTab\">哈哈</view>\r\njs:\r\nchangeTab(e){\r\n   var _tab = e.currentTarget.dataset.tab;  \r\n}七.设置值VUE:设置test的值可以用，this.test = true;获取test的值可以用this.test.微信小程序：设置test的值要用this.setData({test:true});获取test的值用this.data.test 注：微信小程序的表达式一般写在“{{}}”里面"}
{"title": "微信小程序技术教程：集成 Redux ", "author": "天下雪", "pub_time": "2016-10-15 21:48", "content": "示例Redux是什么Redux 是 JavaScript 状态容器，提供可预测化的状态管理。Redux官方文档为什么要使用Redux小程序俨然是一个类似Hybrid App的东西，前面是SPA，小程序提供一些原生功能的接口。现在前端程序规模都比较大，页面状态，数据缓存，需要管理的东西太多。引入Redux可以方便的管理这些状态。并且Redux丰富的周边工具也是很有吸引力的。集成Redux小程序的模块化微信的文档并没有指出如何使用第三方库，所以只能从微信小程序的模块化入手。文档中提到，模块化的关键是：module.exports = function(){}同时，如果我们去观察小程序开发环境的network面板，点击任何一个js，我们可以发现：项目目录中的所有js文件都会自动被加载，无论我们是否在代码中require所以的模块都会被套上下面的代码：define(\"reducers/visibilityFilter.js\", function(require, module){var window={Math:Math}/*兼容babel*/,location,document,navigator,self,localStorage,history,Caches;/*******************//******你写的代码******/                                                                 /********************/})这实际上是类似AMD的加载方式，但是跟标准的AMD又有些不同，缺少了依赖部分的声明。function(require, module){}: 这个函数包裹的是模块的实现，也就是我们自己写的代码，小程序给我们暴露了两个参数require和module，require用来在模块中加载其他模块，module用来将模块中的方法暴露出去：module.exports = function(){}所以只要需要让第三方库的代码使用这种形式的export就可以了。构建Redux的微信小程序包这里主要目标是打一个Redux包，让它可以兼容微信小城的加载方式下载Redux的代码到本地：git clone https://github.com/reactjs/redux.git安装依赖：npm install打包：npm run build:umd && npm run build:umd这些命令的详细内容可以到redux项目的package.json中查看。这些命令是是使用webpack构建UMD模式的包。也就是说所有的代码，包括依赖的库都会被打包到一个文件中，并且自带一段模块加载代码，文件可以在dist目录下找到。带min.js后缀的是minify过的。      4.微调加载方式：用编辑器打开dist目录下的redux.js文件(function webpackUniversalModuleDefinition(root, factory) {    if(typeof exports === 'object' && typeof module === 'object')        module.exports = factory();    else if(typeof define === 'function' && define.amd)        define([], factory);    else if(typeof exports === 'object')        exports[\"Redux\"] = factory();    else        root[\"Redux\"] = factory();})(this, function() {...  })这段代码是用来加载模块的，里面的factory函数的返回的内容是用webpack提供的loader组织起来的redux的代码和第三方依赖。如果我们把这个文件拷贝到小程序中，只需要让程序能正常进入第三行代码，就能把Redux加载进来。将第二行代码：if(typeof exports === 'object' && typeof module === 'object')      修改成：if(typeof module === 'object')这样修改的原因是，在微信小程序的环境中是没有exports变量的，所以就没办法正确进入这个分支，删除之后就可以正确进入了拷贝进工程目录例如，我们拷贝到libs目录下，那么我们在程序中使用时，只要当做是一个本地模块去require就可以了：var redux = require('./libs/redux.js')通过这里的示例，其实我们发现，我们可以通过类似的方法，使用Webpack打包第三方库，就可以集成任何库了。使用Redux我们可以使用Redux的微信小程序绑定库来简化一些代码：wechat-weapp-redux，详细的安装和使用说明可以参照wechat-weapp-redux的README集成Redux-devtools如果没有redux-devtools那么使用redux的效果可能是要减半的。因为微信小程序的开发环境是定制的，暂时没有发现办法直接安装redux-devtool的插件。这里使用remote-redux-devtools，remotedev-server安装remote-redux-devtools原版的remote-redux-devtools使用的一个websocket的依赖会使用原生的WebSocket，小程序是不支持的，所以需要改成小程序的websocket实现。修改好的包在这里：remote-redux-devtools把代码下载到工程目录里面就可以用了。安装和启动remotedev-servernpm install -g remotedev-serverremotedev --hostname=localhost --port=5678          因为没办法用npm安装到本地（开头提到的，微信小程序会尝试去加载项目目录中的所有js），所以这里使用全局安装，第二条命令是启动remotedev-server，hostname和port分别指定为localhost和5678。     3.  集成devtoolconst {createStore, compose} = require('./libs/redux.js');const devTools = require('./libs/remote-redux-devtools.js').default;const reducer = require('./reducers/index.js')function configureStore() {  return createStore(reducer, compose(devTools({    hostname: 'localhost',    port: 5678,    secure: false  })));}module.exports = configureStore;把devtool使用redux的compose加到store中去。hostname和port是指定为之前启动remotedev-server启动时候指定的参数。保存之后重启一下小程序，如果没有报错的话就OK了      4.  打开监视器          可以在浏览器中访问localhost:5678，这是remotedev-server自带的监视器，正常打开的话是这样的：          左边有一个@@INIT说明小程序的redux连接成功了。但是这里这个自带的监视器可能打不开，因为它的一些js包是存在国外的cdn上的，偶尔访问不到。这个时候可以使用http://remotedev.io/local/，点击下面的setting，设置使用本地的server。保存之后刷新页面，应该跟上面显示的结果一样。示例详细的代码示例，可以参照：wechat-weapp-redux-todos"}
{"title": "在小程序中集成redux/immutable/thunk第三方库 ", "author": "Rolan", "pub_time": "2018-8-13 00:04", "content": "小程序给我们暴露了两个参数 require 和 module ， require 用来在模块中加载其他模块，module 用来将模块中的方法暴露出去module.exports = function(){}\r\n所以只要需要让第三方库的代码使用这种形式的 export 就可以了二、构建Redux的微信小程序包打一个 Redux 包，让它可以兼容微信小城的加载方式git clone https://github.com/reactjs/redux.git\r\n\r\nnpm install\r\n\r\n# 详细内容可以到redux项目的package.json中查看\r\n# 这些命令是是使用webpack构建UMD模式的包。也就是说所有的代码，包括依赖的库都会被打包到一个文件中，并且自带一段模块加载代码，文件可以在dist目录下找到\r\nnpm run build:umd && npm run build:umd\r\n用编辑器打开 dist 目录下的 redux.js 文件(function webpackUniversalModuleDefinition(root, factory) {\r\n    if(typeof exports === 'object' && typeof module === 'object')\r\n        module.exports = factory();\r\n    else if(typeof define === 'function' && define.amd)\r\n        define([], factory);\r\n    else if(typeof exports === 'object')\r\n        exports[\"Redux\"] = factory();\r\n    else\r\n        root[\"Redux\"] = factory();\r\n})(this, function() {\r\n...  \r\n})\r\n这段代码是用来加载模块的，里面的factory函数的返回的内容是用webpack提供的loader组织起来的redux的代码和第三方依赖。如果我们把这个文件拷贝到小程序中，只需要让程序能正常进入第三行代码，就能把Redux加载进来将第二行代码： if(typeof exports === 'object' && typeof module === 'object') 修改成： if(typeof module === 'object')这样修改的原因是，在微信小程序的环境中是没有exports变量的，所以就没办法正确进入这个分支，删除之后就可以正确进入我们拷贝到 libs 目录下，那么我们在程序中使用时，只要当做是一个本地模块去 require就可以了 var redux = require('./libs/redux.js')我们可以通过类似的方法，使用 Webpack 打包第三方库，就可以集成任何库了三、集成Redux-devtools因为微信小程序的开发环境是定制的，暂时没有发现办法直接安装 redux-devtool 的插件安装remote-redux-devtools原版的 remote-redux-devtools 使用的一个 websocket 的依赖会使用原生的 WebSocket ，小程序是不支持的，所以需要改成小程序的 websocket 实现,修改好的代码 https://github.com/poetries/wx-redux-immutable-template/blob/master/wx-redux-immutable-template/public/libs/remote-redux-devtools.js把代码下载到工程目录里面就可以用了安装和启动remotedev-servernpm install -g remotedev-server\r\nremotedev --hostname=localhost --port=5678\r\n因为没办法用 npm 安装到本地（微信小程序会尝试去加载项目目录中的所有js），所以这里使用全局安装，第二条命令是启动 remotedev-server ， hostname 和 port 分别指定为 localhost和 5678集成devtool在 store 下集成 devtoolconst {createStore, compose} = require('./libs/redux.js');\r\nconst devTools = require('./libs/remote-redux-devtools.js').default;\r\nconst reducer = require('./reducers/index.js')\r\n\r\nfunction configureStore() {\r\n  return createStore(reducer, compose(devTools({\r\n    hostname: 'localhost',\r\n    port: 5678,\r\n    secure: false\r\n  })));\r\n}\r\n\r\nmodule.exports = configureStore;\r\n把 devtool 使用 redux 的 compose 加到 store 中去。 hostname 和 port 是指定为之前启动 remotedev-server 启动时候指定的参数。保存之后重启一下小程序，如果没有报错的话就OK了可以在浏览器中访问 localhost:5678四、小程序中集成immutableImmutable 是 Facebook 开发的不可变数据集合。不可变数据一旦创建就不能被修改，是的应用开发更简单，允许使用函数式编程技术，比如惰性评估。微信小程序无法直接使用 Immutable.js ，下面就来说说微信小程序如何使用第三方库 Immutable.jsImmutable使用了UMD模块化规范(function (global, factory) {\r\n typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n typeof define === 'function' && define.amd ? define(factory) :\r\n (global.Immutable = factory());\r\n}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;\r\n\r\n....\r\n\r\n}));\r\n修改 Immutable 代码，注释原有模块导出语句，使用 module.exports = factory() 强制导出(function(global, factory) {\r\n /*\r\n typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\r\n typeof define === 'function' && define.amd ? define(factory) :\r\n (global.Immutable = factory());\r\n */\r\n\r\n module.exports = factory();\r\n\r\n}(this, function() {\r\n导入修改好的 immutable 到小程序中即可 https://github.com/poetries/wx-redux-immutable-template/blob/master/wx-redux-immutable-template/public/libs/immutable.js"}
{"title": "微信小程序 canvas区间滑动选取 ", "author": "Rolan", "pub_time": "2018-9-1 00:21", "content": "目标js文件使用 import 引入; 然后在onLoad(){}里面要一下写入例如: this.selectInterval = new selectInterval({属性});        this.selectInterval = new SelectInterval({        canvasId:'canvas',             值必须是canvas组件的canvas-id属性的值        canvasHeight:100,              值必须是当前画布的高度        Xaxis:{left:30,right:345},     { left:30, 横条的左端 right:345, 横条的右端 }(right必须大于left,如果不传有默认值)        scale:[10,20,30],              刻度值Array类型,取值以一个不变数为常量不断递增,数组任何两个前后值相减要恒等于这个常量,如果数组第一个值不是0,                                      会默认在数组前面添加一个0,但是0这个值不会在canvas上显示,(当数组长度是2的时候,                                 可以设置任意大于零的数值,但第二个值必须大于第一个值);        Yaxis:[125,5],                 刻度值Array类型,第一个值是绘制的横条的起始高度,第二个值是横条本身的高度(如果不传默认[125,5])        manner:true,                   切换选择滑动点的上方在滑动的时候是否有跟随圆球，如果值为false那么明确显示区间滑动所得的最小值与最大值        bothEndsNear:310,              可以设置刻度值和尺度点距离横条的开头与终点的距离,不传默认居中        // decimalPoint:10,            刻度值/decimalPoint,可以使刻度值变小数,必须是10的倍数,可以不传        // rightSliderStop:2,          值为一个Boolean或者在manner的值为true的时候可填number,可以不传;而number的值就是最大值与最小值的差，设置后两个滑动点是不会滑动到小于这个number的距离        showTitle:{            name:'km',                   String类型,用作设置单位            size:15,                     标签字体大小,Number类型            title:'#1384e0',             头部标签的字体颜色或者圆球里面的字体颜色,String类型            positionX:100,               标签字体在canvas横向的位置,Number类型，只有manner为false或者不传的时候生效            positionY:80,                标签字体或者圆球在canvas纵向的位置,Number类型            isfollow:{                   跟随圆球大小与颜色的设置,manner的值为false或不传的时候,这个属性可以不给                view:true,           manner的值为true时，view的值必须为true                roundSize:12,        圆球大小                roundColor:'rgba(10, 113, 238, 0.8)' 圆球的颜色            }        },(如果不传不会显示头部标签)        scaleIn:{            name:'km',                   String类型,用作设置单位            size:10,                     控制刻度值字体的大小,Number类型            valueY:108,                  刻度值在canvas纵坐标的位置,Number类型            pointY:113                   尺度点在canvas纵坐标的位置,Number类型        },(如果不传不会显示刻度值)        colour:{            colorBar:['#e5e5e5','#1384e0'],     横条的颜色,Array类型,第一个是横条的底色,第二个是取值范围的颜色            roundColor:['#ffffff','#e5e5e5'],   圆圈颜色,Array类型,第一个是圆的颜色,第二个是圆的边框颜色            scale:['#000000','#999999']         刻度数值的字体颜色        },(如果不传会显示上面的默认参数)        selectedInterval:{            min:15,            max:23         },(min不能大区等于max,如果不传只会显示在横条的两端)        round:{            radius:10,            edgeLine:2        },(如果不传会默认圆的半径为10,边框为2)        // image:{        //  url:'../../assets/image/spot-a.png',   图片的本地路径值为String类型；值可以为数组，但是如果是数组时数组的长度必须是2        //  width:20,                              设置图片的宽度        //  height:24                              设置图片的高度        // },(如果不传不会显示图片)        followValue:{            name:'',                               String类型,用作设置单位            color:'#f8835f',            size:10,                               设置字体大小            leftY:151,                             随数值在canvas纵向的位置            rightY:151        }(如果不传不会显示跟随数值)    });/**Page({})里面创建如下属性 必须自定义(e){ bindtouchstart    this.selectInterval.move(e.changedTouches[0].x,e.changedTouches[0].y);},自定义(e){ bindtouchmove    this.selectInterval.meter(e.changedTouches[0].x);},自定义(e){ bindtouchend    this.selectInterval.texthints((min,max)=>{        参数min/max返回的值是最小/大价格,超过最大值max返回null        console.log(min,max);    },true);初始化时传入manner属性的值为true时候,这个函数的第二个参数的true就要传,不传也没什么问题，只是结果会有不同;},<canvas canvas-id=\"canvas\" bindtouchstart=\"自定义\" bindtouchmove=\"自定义\" bindtouchend=\"自定义\"></canvas>画布css样式width:100%;box-sizing: border-box;height: 自定义rpx;"}
{"title": "Codeigniter中创建LeanCloud云函数实现微信支付 ", "author": "yuzeng84", "pub_time": "2017-6-4 08:34", "content": "经过摸索，与官方提供的slim无异，同样使用__invoke魔法函数即可，步骤如下：1.config.php打开hook，即设置$config['enable_hooks'] = TRUE;详情文档参见：http://codeigniter.org.cn/user_guide/general/hooks.html2.在hook.php中实现php"}
{"title": "小程序微信支付php案例 ", "author": "天下雪", "pub_time": "2017-1-24 00:00", "content": "本文方便使用php环境的会员增加一个参考对象作者：未署名，来自原文地址前端代码：    wx.request({        url: 'https://www.yourhost.com/weixin/WeiActivity/payJoinfee',//改成你自己的链接        header: {            'Content-Type': 'application/x-www-form-urlencoded'        },        method:'POST',        success: function(res) {            console.log(res.data);            console.log('调起支付');            wx.requestPayment({                'timeStamp': res.data.timeStamp,                'nonceStr': res.data.nonceStr,                'package': res.data.package,                'signType': 'MD5',                'paySign': res.data.paySign,                'success':function(res){                    console.log('success');                    wx.showToast({                        title: '支付成功',                        icon: 'success',                        duration: 3000                    });                },                'fail':function(res){                    console.log('fail');                },                'complete':function(res){                    console.log('complete');                }            });        },        fail:function(res){            console.log(res.data)        }    });后端代码：赞赏 \n                             \n                 \n                邀请 \n              \n              \n               \n               \n              \n              \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (2 人)\r\n\r\n\r\n\r\n\r\nsuper007\r\n\r\n\r\n\r\n一笑而过。\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n            \n            \n             \n                         \n              跳坑《四十七》微信小程序支付（微信支付签名错误） \n              关于微信小程序的支付开发：40013错误 \n            \n             \n            \n                   \n                   \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序实战教程：微信支付跳坑流程\n                                    \n                  • PHP：微信小程序服务端集成微信支付\n                                  \n              \n            \n             \n            \n          \n          \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    5 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n     \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         wx_d9cdfb9c45\r\n                \r\n       \r\n       2017-8-16 17:15\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    支付类这里报错\r\n\r\n$xmlData=arrayToXml($parameters);\r\n$return=xmlToArray(postXmlSSLCurl($xmlData,$url,60));\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         wx_d9cdfb9c45\r\n                \r\n       \r\n       2017-8-16 17:13\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    微信支付类是不是不太完整，能不能发个完整的文件啊   谢谢了\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         super007\r\n                \r\n       \r\n       2017-5-10 17:10\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    大神，有源代码吗？\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         天下雪\r\n                \r\n       \r\n       2017-2-17 19:46\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    wx_8e86e56811: 大神 问一下  用户的 openid怎么获取wx.getUserInfo(OBJECT) 这个方法 里面的 encryptedData 是undfind参考一下其他登录的帖子：http://www.wxapp-union.com/portal.php?mod=list&catid=22\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         wx_8e86e56811\r\n                \r\n       \r\n       2017-2-17 17:09\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    大神 问一下  用户的 openid怎么获取wx.getUserInfo(OBJECT) 这个方法 里面的 encryptedData 是undfind\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n             \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSVKUK46', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n      \n      \n       \n    \n  \n  \n    \n    \n    \n     \n      \n      \n       \n    \n  \n\n\n\n \n  \n  \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880731|09868697e995d6164cadcc1970626bb8|2';"}
{"title": "微信小程序 | 切换按钮或者view的选中状态 ", "author": "Rolan", "pub_time": "2018-9-4 00:42", "content": "实现非常简单，通过一个简单的判断当前data中的选中值，点击按钮时更新data值，重新渲染页面。index.wxml文件<view class=\"switch-type\">\r\n    <view class=\"btn {{currentSelectTripType == 'pinche' ? 'active' : ''}}\" bindtap='selectedPinche' data-id='pinche'>拼车</view>\r\n    <view class=\"btn {{currentSelectTripType == 'baoche' ? 'active' : ''}}\" bindtap='selectedBaoche' data-id='baoche'>包车</view>\r\n  </view>\r\nindex.js文件Page({\r\n  data: {~~~~\r\n    currentSelectTripType: 'pinche',\r\n  },\r\n  // 更新data 切换选中状态\r\n  selectedPinche: function (e) {\r\n    this.setData({\r\n      currentSelectTripType: e.currentTarget.dataset.id\r\n    })\r\n  },\r\n  selectedBaoche: function(e) {\r\n    this.setData({\r\n      currentSelectTripType: e.currentTarget.dataset.id\r\n    })\r\n  },\r\n})\r\n附上一个简单的样式index.wxss.switch-type {\r\n  display: flex;\r\n}\r\n.switch-type .btn:first-child {\r\n  border-top-right-radius: 0;\r\n  border-bottom-right-radius: 0;\r\n}\r\n.switch-type .btn:last-child {\r\n  border-top-left-radius: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n.switch-type .btn {\r\n  background: #dfdfdf;\r\n  padding: 10rpx 40rpx;\r\n}\r\n.switch-type .btn.active {\r\n  border: 2rpx solid #007bff;\r\n  background: #fff;\r\n}"}
{"title": "微信小程序form表单提交（PHP后端） ", "author": "天下雪", "pub_time": "2017-1-12 15:37", "content": "作者：周起，原文来自授权地址1.小程序相对于之前的WEB+PHP建站来说，个人理解为只是将web放到了微信端，用小程序固定的格式前前端进行布局、事件触发和数据的输送和读取，服务器端可以用任何后端语言写，但是所有的数据都要以JSON的形式返回给小程序。2.昨天写了登录注册、忘记密码功能，他们实质上都是一个表单提交操作。因此就拿注册功能来写这个例子。"}
{"title": "微信官方悄悄告诉我们，这 3 个新能力即将开放 ", "author": "Rolan", "pub_time": "2017-11-23 00:29", "content": "半个月之内，微信又回到了成都，这次带来的是微信公开课的小程序专场。随着小程序的持续窜热，商家和企业加速进入小程序生态，越来越多人「严阵以待」着小程序新能力的发布和微信关于小程序未来规划的描述。而在 11 月 21 日的公开课，这些方面均有猛料爆出。嘘，小程序这 3 个新能力要来了！1. 两个音视频接口即将开放微信与腾讯云合作，要发力小程序中的多媒体了。腾讯云对话知晓程序（微信号 zxcx0101）时表示，小程序很快将正式上线两个音视频的标签接口：live-publisher，实时视频的发布live-player，实时视频的播放这意味着，小程序将可以做到实时音视频的分发与传输了。而在此前， 10 月份小程序发布的多媒体能力方面，小程序仍然只支持录音、拍照摄像和视频播放。对此，腾讯云方面表示，当小程序的应用场景不断扩展和深入，对直播和实时在线的应用需求也越发迫切，比如在金融保险的开户、在线教育、企业通信、政企类应用，以及视频节目的直播等等。2. 分包加载功能将上线进一步提高加载流畅性，打造媲美 App 的用户体验。为此，小程序对开发者的另一大利好是即将上线分包加载能力。把小程序完整的大包切换成不同小包，用户使用小程序具体页面时小包加载可以加快使用速度。虽然微信依然限制每个小程序代码包的大小，但将不限制小程序总体积包。企业还可以利用这个功能，降低不同团队间的协作难度。这个新能力，代表微信在响应企业用户希望通过小程序做更多内容展示的需求，比如像电商去做更多商品陈列，媒体平台的音视频等「大件内容」的投放，以及未来小程序有可能出现的游戏等产品。尽管后者目前还被写入小程序明令不做的类目当中。3. 微信小店升级小店小程序微信怎样来做「新零售」，具体的垂直行业会是什么？现在可以明确地举例了，比如说「小程序点餐」。本场微信公开课，微信首次发布了小程序点餐解决方案。通过该方案，不仅可以实现顾客到店餐饮使用小程序下单，商家根据用户数据信息以及偏好提供个性化菜单，还能在消费后经微信支付，提供社交立减金和优惠卡券，并经卡券的到期提醒、小程序服务通知等能力，实现顾客召回与二次消费。同时，在远程的场景下，用户也可以提前在小程序上预约，到店免排队入座；或者小程序点餐送外卖这样的 O2O 业务。应该说，当所有线下门店都可以轻松开发自己的小程序之后，餐饮行业会利用这个能力进行非常快的应用。"}
{"title": "微信小程序实现简易留言板 ", "author": "Rolan", "pub_time": "2017-5-30 00:45", "content": "微信小程序现在很火，于是也就玩玩，做了一个简易的留言板，让大家看看，你们会说no picture you say a j8 a,好吧先上图。样子就是的，功能一目了然，下面我们就贴实现的代码，首先是HTML页面，好吧，其实微信小程序的是wxml（微信ml）总感觉怪怪的，有木有。 1 <!--index.wxml--> 2 <view class=\"msg-box\"> 3 <!--留言--> 4    <view class=\"send-box\"> 5       <input bindinput=\"changeInputValue\" class=\"input\" type=\"text\" value=\"{{inputVal}}\" placeholder=\"请输入留言……\" placeholder-class=\"place-input\"/> 6       <button size=\"mini\" type=\"primary\" bindtap=\"addMsg\">添加</button> 7    </view> 8    <!--留言列表--> 9    <text class=\"msg-info\" wx:if=\"{{msgData.length==0}}\">暂无留言……^_^</text>10    <view class=\"list-view\">11       <view class=\"item\" wx:for=\"{{msgData}}\" wx:key=\"{{index}}\">12         <text class=\"text1\">{{item.msg}}</text>13         <!--button size=\"mini\" plain class=\"close-btn\" type=\"default\">删除</button-->14         <icon type=\"cancel\" bindtap=\"DelMsg\" data-index=\"{{index}}\" class=\"close-btn\" />15       </view>16    </view>17 </view>微信小程序里把div改成了view，听说div也可以用，没有实验过，不知道真假。不过就这样吧，反正原理都一样，页面效果主要看css，又错了，是wxss（微信ss）说实话总觉得……这种感觉不好多说。看我们的布局代码，超简单，完全和css一样 1 /**index.wxss**/ 2 .msg-box{ 3   padding: 20px; 4 } 5 .send-box{ 6   display: flex; 7 } 8 .input{ 9   border: 1px solid #B0C4DE;10   padding: 5px;11 }12 .msg-info{13   display: block;14   margin: 10px 0 0 0 ;15   color: #339900;16 17 }18 .place-input{19   color: salmon;20 }21 .list-view{22   margin: 20px 0 0 0;23 }24 .item{25   overflow: hidden;26   border-bottom: 1px dashed #87CEFF;27   height: 30px;28   line-height: 30px;29 }30 .text1{31   float: left;32 }33 .close-btn{34   float: right;35   margin: 5px 5px 0 0;36 }才36行，现在一看，好吧，真特么简单。微信小程序的功能实现主要看js部分，好在这个他们没有叫（wxjs），微信小程序的js写法，怎么说呢，假如你会vue.js React或者是AngularJS，完全是玩一样的就会了，好吧，不过这三个我暂时都不会！！！！！！！！！！！！！！！js代码如下： 1 //index.js 2 //获取应用实例 3 var app = getApp(); 4 Page({ 5   data: { 6     msgData:[]  7   }, 8   changeInputValue(ev){ 9     this.setData({10       inputVal:ev.detail.value11     })12   },13 //删除留言14   DelMsg(ev){15     var n=ev.target.dataset.index;16 17     var list = this.data.msgData;18     list.splice(n,1);19     20     this.setData({21       msgData:list22     });23   },24 //添加留言25   addMsg(){26     var list = this.data.msgData;27     list.push({28       msg:this.data.inputVal29     });30     //更新31     this.setData({32       msgData:list,33       inputVal:''34     }); 35   },36 })完美的36行，早知道wxml注释写一堆应该也凑个36，这个数字多顺啊。哈哈哈，好了，所有的功能代码都在这里了，大家赶快也去玩玩吧。注明一下代码出处，这个我是按照腾讯课堂里的某个课程写的，，，，，，，，，，，，具体的忘了，也不查了，好歹说明一下，不要说我盗版，因为这个本身就是为了大家学习用的，……………………不要纠结那么多了。"}
{"title": "Web直播，你需要先知道这些 ", "author": "Rolan", "pub_time": "2018-9-5 00:12", "content": "转自IMWeb社区，作者：Terrance，原文链接一、直播知识小科普一个典型的直播流程：录制->编码->网络传输（推流->服务器处理->CDN分发）->解码->播放IPB：一种常用的视频压缩方案，用I帧表示关键帧，B帧表示前向差别帧，P帧表示双向差别帧GOP (Group of Pictures)：GOP 越长（I帧之间的间隔越大），B 帧所占比例越高，编码的率失真性能越高。虽然B帧压缩率高，但解码时CPU压力会更大。音视频直播质量好坏的主要指标： 内容延时 、 卡顿（流畅度） 、 首帧时长音视频直播需要克服的主要问题：网络环境、多人连麦、主辅路、浏览器兼容性、CDN支持等MSE (Media Source Extensions)：W3C 标准API，解决 HTML5 的流问题（HTML5 原生仅支持播放 mp4/webm 非流格式，不支持 FLV），允许JavaScript动态构建 <video> 和 <audio>的媒体流。可以用MediaSource.isTypeSupported() 判断是否支持某种MINE类型。在ios Safari中不支持。文件格式/封装格式/容器格式 ：一种承载视频的格式，比如flv、avi、mpg、vob、mov、mp4等。而视频是用什么方式进行编解码的，则与Codec相关。举个栗子，MP4格式根据编解码的不同，又分为nMP4、fMP4。nMP4是由嵌套的Boxes 组成，fMP4格式则是由一系列的片段组成，因此只有后者不需要加载整个文件进行播放。Codec ：多媒体数字信号编码解码器，能够对音视频进行压缩（CO）与解压缩( DEC ) 。CODEC技术能有效减少数字存储占用的空间，在计算机系统中，使用硬件完成CODEC可以节省CPU的资源，提高系统的运行效率。常用视频编码 ：MPEG、H264、RealVideo、WMV、QuickTime。。。常用音频编码 ：PCM、WAV、OGG、APE、AAC、MP3、Vorbis、Opus。。。二、现有方案比较RTMP协议基于TCPadobe垄断，国内支持度高浏览器端依赖Flash进行播放2~5秒的延迟RTP协议Real-time Transport Protocol，IETF于1996提出的一个标准基于UDP实时性强用于视频监控、视频会议、IP电话CDN厂商、浏览器不支持HLS 协议Http Live Streaming，苹果提出的基于HTTP的流媒体传输协议HTML5直接支持(video)，适合APP直播，PC断只有Safari、Edge支持必须是H264+AAC编码因为传输的是切割后的音视频片段，导致内容延时较大flv.jsBilibli开源，解析flv数据，通过MSE封装成fMP4喂给video标签编码为H264+AAC使用HTTP的流式IO(fetch或stream)或WebSocket协议流式的传输媒体内容2~5秒的延迟，首帧比RTMP更快WebRTC协议1、Google力推，已成为W3C标准2、现代浏览器支持趋势，X5也支持（微信、QQ）3、基于UDP，低延迟，弱网抗性强，比flv.js更有优势4、支持Web上行能力5、编码为H264+OPUS6、提供NAT穿透技术（ICE）实际情况下，当用户数量很大时，对推流设备的性能要求很高，复杂的权限管理也难以实现，采用P2P的架构基本不可行。对于个别用户提供上行流、海量用户只进行拉流的场景，腾讯课堂实现了一种P2S的解决方案。 进一步学习可阅读jaychen的系列文章《WebRTC直播技术》。三、小程序+直播技术方案基于RTMP，官方说底层使用HTTP/2的一种内部传输机制，但又说是基于UDP的，这就搞不懂了。。。live-pusher 和 live-player 没有限制第三方云服务可直接使用腾讯云视频直播能力，只需配置好推流url、播放url即可推流url：播放url：下面是我根据官网教程搭建的一个音视频小程序，搭建过程简单，同一个局域网下直播体验也很流畅（读者也可直接搜索 腾讯视频云 小程序进行体验）：前端核心代码还是相当简洁的：live-pusher组件：设置好url推流地址（仅支持 flv, rtmp 格式）等参数即可，使用bindstatechange获取播放状态变化<view id='video-box'>  \r\n    <live-pusher\r\n          id=\"pusher\"\r\n          mode=\"RTC\"\r\n          url=\"{{pusher.push_url}}\" \r\n          autopush='true'\r\n          bindstatechange=\"onPush\">\r\n    </live-pusher>  \r\n </view>\r\n复制代码live-player组件：设置后src音视频地址（仅支持 flv, rtmp 格式）等参数即可，使用bindstatechange获取播放状态变化<view id='video-box'>  \r\n    <live-player\r\n        wx:for=\"{{player}}\"\r\n        id=\"player_{{index}}\"\r\n        mode=\"RTC\"\r\n        object-fit=\"fillCrop\"\r\n        src=\"{{item.playUrl}}\" \r\n        autoplay='true'\r\n        bindstatechange=\"onPlay\">\r\n   </live-player>\r\n </view>\r\n复制代码能否和WebRTC同时使用?对于腾讯课堂的应用场景，老师上课推流采用的是RTMP协议，考虑到WebRTC目前只能用于PC端拉流，那么在移动端能否让用户可以直接通过小程序来观看直播课呢？我觉得在技术层面可行的，接入小程序直播对于扩大平台影响力、社交圈分享、提高收费转化都会产生很大的帮助。难点在于复杂的权限控制、多路音视频流、多人连麦等问题，比如权限控制只能单独放到房间控制逻辑中完成，而音视频流本身缺乏这种校验；主辅路的切换还需要添加单独的信令控制，同时在小程序中加入相应的判断逻辑。"}
{"title": "在微信小程序里使用 watch 和 computed ", "author": "Rolan", "pub_time": "2018-4-2 00:11", "content": "在开发 vue 的时候，我们可以使用 watch 和 computed 很方便的检测数据的变化，从而做出相应的改变，但是在小程序里，只能在数据改变时手动触发 this.setData()，那么如何给小程序也加上这两个功能呢？我们知道在 vue 里是通过 Object.defineProperty 来实现数据变化检测的，给该变量的 setter 里注入所有的绑定操作，就可以在该变量变化时带动其它数据的变化。那么是不是可以把这种方法运用在小程序上呢？实际上，在小程序里实现要比 vue 里简单，应为对于 data 里对象来说，vue 要递归的绑定对象里的每一个变量，使之响应式化。但是在微信小程序里，不管是对于对象还是基本类型，只能通过 this.setData() 来改变，这样我们只需检测 data 里面的 key 值的变化，而不用检测 key 值里面的 key 。先上测试代码<view>{{ test.a }}</view>\r\n<view>{{ test1 }}</view>\r\n<view>{{ test2 }}</view>\r\n<view>{{ test3 }}</view>\r\n<button bindtap=\"changeTest\">change</button>const { watch, computed } = require('./vuefy.js')\r\nPage({\r\n  data: {\r\n    test: { a: 123 },\r\n    test1: 'test1',\r\n  },\r\n  onLoad() {\r\n    computed(this, {\r\n      test2: function() {\r\n        return this.data.test.a + '2222222'\r\n      },\r\n      test3: function() {\r\n        return this.data.test.a + '3333333'\r\n      }\r\n    })\r\n    watch(this, {\r\n      test: function(newVal) {\r\n        console.log('invoke watch')\r\n        this.setData({ test1: newVal.a + '11111111' })\r\n      }\r\n    })\r\n  },\r\n  changeTest() {\r\n    this.setData({ test: { a: Math.random().toFixed(5) } })\r\n  },\r\n})现在我们要实现 watch 和 computed 方法，使得 test 变化时，test1、test2、test3 也变化，为此，我们增加了一个按钮，当点击这个按钮时，test 会改变。watch 方法相对简单点，首先我们定义一个函数来检测变化：function defineReactive(data, key, val, fn) {\r\n  Object.defineProperty(data, key, {\r\n    configurable: true,\r\n    enumerable: true,\r\n    get: function() {\r\n      return val\r\n    },\r\n    set: function(newVal) {\r\n      if (newVal === val) return\r\n      fn && fn(newVal)\r\n      val = newVal\r\n    },\r\n  })\r\n}然后遍历 watch 函数传入的对象，给每个键调用该方法function watch(ctx, obj) {\r\n  Object.keys(obj).forEach(key => {\r\n    defineReactive(ctx.data, key, ctx.data[key], function(value) {\r\n      obj[key].call(ctx, value)\r\n    })\r\n  })\r\n}这里有参数是 fn ，即上面 watch 方法里 test 的值，这里把该方法包一层，绑定 context。接着来看 computed，这个稍微复杂，因为我们无法得知 computed 里依赖的是 data 里面的哪个变量，因此只能遍历 data 里的每一个变量。function computed(ctx, obj) {\r\n  let keys = Object.keys(obj)\r\n  let dataKeys = Object.keys(ctx.data)\r\n  dataKeys.forEach(dataKey => {\r\n    defineReactive(ctx.data, dataKey, ctx.data[dataKey])\r\n  })\r\n  let firstComputedObj = keys.reduce((prev, next) => {\r\n    ctx.data.$target = function() {\r\n      ctx.setData({ [next]: obj[next].call(ctx) })\r\n    }\r\n    prev[next] = obj[next].call(ctx)\r\n    ctx.data.$target = null\r\n    return prev\r\n  }, {})\r\n  ctx.setData(firstComputedObj)\r\n}详细解释下这段代码，首先给 data 里的每个属性调用 defineReactive 方法。接着计算 computed 里面每个属性第一次的值，也就是上例中的 test2、test3。computed(this, {\r\n  test2: function() {\r\n    return this.data.test.a + '2222222'\r\n  },\r\n  test3: function() {\r\n    return this.data.test.a + '3333333'\r\n  }\r\n})这里分别调用 test2 和 test3 的值，将返回值与对应的 key 值组合成一个对象，然后再调用 setData() ，这样就会第一次计算这两个值，这里使用了 reduce 方法。但是你可能会发现其中这两行代码，它们好像都没有被提到是干嘛用的。  ctx.data.$target = function() {\r\n    ctx.setData({ [next]: obj[next].call(ctx) })\r\n  }\r\n  \r\n  ctx.data.$target = null可以看到，test2 和 test3 都是依赖 test 的，这样必须在 test 改变的时候在其的 setter 函数中调用 test2 和 test3 中对应的函数，并通过 setData 来设置这两个变量。为此，需要将 defineReactive 改动一下。function defineReactive(data, key, val, fn) {\r\n  let subs = [] // 新增\r\n  Object.defineProperty(data, key, {\r\n    configurable: true,\r\n    enumerable: true,\r\n    get: function() {\r\n      // 新增\r\n      if (data.$target) {\r\n        subs.push(data.$target)\r\n      }\r\n      return val\r\n    },\r\n    set: function(newVal) {\r\n      if (newVal === val) return\r\n      fn && fn(newVal)\r\n      // 新增\r\n      if (subs.length) {\r\n        // 用 setTimeout 因为此时 this.data 还没更新\r\n        setTimeout(() => {\r\n          subs.forEach(sub => sub())\r\n        }, 0)\r\n      }\r\n      val = newVal\r\n    },\r\n  })\r\n}相较于之前，增加了几行代码，我们声明了一个变量来保存所有在变化时需要执行的函数，在 set 时执行每一个函数，因为此时 this.data.test 的值还未改变，使用 setTimeout 在下一轮再执行。现在就有一个问题，怎么将函数添加到 subs 中。不知道各位还是否记得上面我们说到的在 reduce 里的那两行代码。因为在执行计算 test1 和 test2 第一次 computed 值的时候，会调用 test 的 getter 方法，此刻就是一个好机会将函数注入到 subs 中，在 data 上声明一个 $target 变量，并将需要执行的函数赋值给该变量，这样在 getter 中就可以判断 data 上有无 target 值，从而就可以 push 进 subs，要注意的是需要马上将 target 设为 null，这就是第二句的用途，这样就达到了一石二鸟的作用。当然，这其实就是 vue 里的原理，只不过这里没那么复杂。到此为止已经实现了 watch 和 computed，但是还没完，有个问题。当同时使用这两者的时候，watch 里的对象的键也同时存在于 data 中，这样就会重复在该变量上调用 Object.defineProperty ，后面会覆盖前面。因为这里不像 vue 里可以决定两者的调用顺序，因此我们推荐先写 computed 再写 watch，这样可以 watch computed 里的值。这样就有一个问题，computed 会因覆盖而无效。思考一下为什么？很明显，这时因为之前的 subs 被重新声明为空数组了。这时，我们想一个简单的方法就是把之前 computed 里的 subs 存在一个地方，下一次调用 defineReactive 的时候看对应的 key 是否已经有了 subs，这样就可以解决问题。修改一下代码。function defineReactive(data, key, val, fn) {\r\n  let subs = data['$' + key] || [] // 新增\r\n  Object.defineProperty(data, key, {\r\n    configurable: true,\r\n    enumerable: true,\r\n    get: function() {\r\n      if (data.$target) {\r\n        subs.push(data.$target)\r\n        data['$' + key] = subs // 新增\r\n      }\r\n      return val\r\n    },\r\n    set: function(newVal) {\r\n      if (newVal === val) return\r\n      fn && fn(newVal)\r\n      if (subs.length) {\r\n        // 用 setTimeout 因为此时 this.data 还没更新\r\n        setTimeout(() => {\r\n          subs.forEach(sub => sub())\r\n        }, 0)\r\n      }\r\n      val = newVal\r\n    },\r\n  })\r\n}这样，我们就一步一步的实现了所需的功能。完整的代码和例子请戳。虽然经过了一些测试，但不保证没有其它未知错误，欢迎提出问题。"}
{"title": "微信小程序把页面做成图片分享【原创】 ", "author": "Rolan", "pub_time": "2018-3-16 00:22", "content": "开发微信小程序的时候，经常要遇到如上图这样的，保存小程序二维码图片的分享功能。网上找了很多都没有具体的写法，于是自己看官方文档写了一个，分享一下。首先，需要在 wxml 中 创建一个 画板 canvas 。wxml : \r\n<view class='more' bindtap='saveImageToPhotosAlbum'>保存图片</view>   //保存图片按钮\r\n<canvas canvas-id='share' style='width:100vw;height:90vh;' hidden='{{canvasHidden}}'></canvas> \r\n\r\n    //这里的 canvas-id 后面要用的上。 \r\n    //style里的宽高要用上，不设置宽高画板会失效。\r\n    //canvasHidden是控制画板显示隐藏的参数，画板直接设置display none，会导致失效。data : \r\n\r\n\r\n\r\n    data: {\r\n        canvasHidden:true,     //设置画板的显示与隐藏，画板不隐藏会影响页面正常显示\r\n        avatarUrl: '',         //用户头像\r\n        nickName: '',          //用户昵称\r\n        wxappName: app.globalData.wxappName,    //小程序名称\r\n        shareImgPath: '',      \r\n        screenWidth: '',       //设备屏幕宽度\r\n        description: app.globalData.description,    //奖品描述\r\n        FilePath:'',           //头像路径\r\n    },js :onLoad: function (options) {\r\n      var that = this\r\n      var userInfo, nickName, avatarUrl\r\n      //获取用户信息，头像，昵称之类的数据\r\n      wx.getUserInfo({\r\n          success: function (res) {\r\n              console.log(res);\r\n              userInfo = res.userInfo\r\n              nickName = userInfo.nickName\r\n              avatarUrl = userInfo.avatarUrl\r\n              that.setData({\r\n                  avatarUrl: res.userInfo.avatarUrl,\r\n                  nickName: res.userInfo.nickName,\r\n              })\r\n              wx.downloadFile({\r\n                  url: res.userInfo.avatarUrl\r\n              })\r\n          }\r\n      })\r\n      //获取用户设备信息，屏幕宽度\r\n      wx.getSystemInfo({\r\n          success: res => {\r\n              that.setData({\r\n                  screenWidth: res.screenWidth\r\n              })\r\n              console.log(that.data.screenWidth)\r\n          }\r\n      })\r\n\r\n//定义的保存图片方法\r\nsaveImageToPhotosAlbum:\r\n  function () {\r\n      wx.showLoading({\r\n          title: '保存中...',\r\n      })\r\n      var that = this;\r\n      //设置画板显示，才能开始绘图\r\n      that.setData({\r\n          canvasHidden: false\r\n      })\r\n      var unit = that.data.screenWidth / 375\r\n      var path1 = \"../images/bg3.png\"\r\n      var avatarUrl = that.data.avatarUrl\r\n      console.log(avatarUrl + \"头像\")\r\n      var path2 = \"../images/award.png\"\r\n      var path3 = \"../images/qrcode.png\"\r\n      var path4 = \"../images/headborder.png\"\r\n      var path5 = \"../images/border.png\"\r\n      var unlight = \"../images/unlight.png\"\r\n      var nickName = that.data.nickName\r\n      console.log(nickName + \"昵称\")\r\n      var context = wx.createCanvasContext('share')\r\n      var description = that.data.description\r\n      var wxappName = \"来「 \" + that.data.wxappName + \" 」试试运气\"\r\n      context.drawImage(path1, 0, 0, unit * 375, unit * 462.5)\r\n      //   context.drawImage(path4, unit * 164, unit * 40, unit * 50, unit * 50)\r\n      context.drawImage(path2, unit * 48, unit * 120, unit * 280, unit * 178)\r\n      context.drawImage(path5, unit * 48, unit * 120, unit * 280, unit * 178)\r\n      context.drawImage(unlight, unit * 82, unit * 145, unit * 22, unit * 32)\r\n      context.drawImage(unlight, unit * 178 , unit * 145, unit * 22, unit * 32)\r\n      context.drawImage(unlight, unit * 274, unit * 145, unit * 22, unit * 32)\r\n      context.drawImage(unlight, unit * 82, unit * 240, unit * 22, unit * 32)\r\n      context.drawImage(unlight, unit * 178, unit * 240, unit * 22, unit * 32)\r\n      context.drawImage(unlight, unit * 274, unit * 240, unit * 22, unit * 32)\r\n      context.drawImage(path3, unit * 20, unit * 385, unit * 55, unit * 55)\r\n      //   context.drawImage(path4, 48, 200, 280, 128)\r\n      context.setFontSize(14)\r\n      context.setFillStyle(\"#999\")\r\n      context.fillText(\"长按识别小程序\", unit * 90, unit * 408)\r\n      context.fillText(wxappName, unit * 90, unit * 428)\r\n      //把画板内容绘制成图片，并回调 画板图片路径\r\n      context.draw(false, function () {\r\n          wx.canvasToTempFilePath({\r\n              x: 0,\r\n              y: 0,\r\n              width: unit * 375,\r\n              height: unit * 462.5,\r\n              destWidth: unit * 375,\r\n              destHeight: unit * 462.5,\r\n              canvasId: 'share',\r\n              success: function (res) {\r\n                  that.setData({\r\n                      shareImgPath: res.tempFilePath\r\n                  })\r\n                  if (!res.tempFilePath) {\r\n                      wx.showModal({\r\n                          title: '提示',\r\n                          content: '图片绘制中，请稍后重试',\r\n                          showCancel: false\r\n                      })\r\n                  }\r\n                  console.log(that.data.shareImgPath)\r\n                  //画板路径保存成功后，调用方法吧图片保存到用户相册\r\n                  wx.saveImageToPhotosAlbum({\r\n                      filePath: res.tempFilePath,\r\n                      //保存成功失败之后，都要隐藏画板，否则影响界面显示。\r\n                      success: (res) => {\r\n                          console.log(res)\r\n                          wx.hideLoading()\r\n                          that.setData({\r\n                              canvasHidden: true\r\n                          })\r\n                      },\r\n                      fail: (err) => {\r\n                          console.log(err)\r\n                          wx.hideLoading()\r\n                          that.setData({\r\n                              canvasHidden: true\r\n                          })\r\n                      }\r\n                  })\r\n              }\r\n          })\r\n      });\r\n\r\n\r\n\r\n  \r\n  },转载时请注明出处及相应链接，本文永久地址：http://blog.yayuanzi.com/23508.html"}
{"title": "微信小程序之判断页面滚动方向 ", "author": "Rolan", "pub_time": "2018-8-31 00:25", "content": "需求微信小程序中如果判断页面滚动方向？解决方案1.用到微信小程序API获取页面实际高度 nodesRef.boundingClientRect([callback])监听用户滑动页面事件onPageScroll。2.获取页面实际高度<!--WXML-->\r\n<view id=\"box\">\r\n   <view class=\"list\" wx:for=\"{{List}}\" wx:key=\"List{{index}}\">\r\n        <image mode='aspectFill' class='list_img'  src=\"{{item.imgUrl}}\"  ></image>\r\n   </view>\r\n</view>    /* JS */\r\n  // 封装函数获取ID为box的元素实际高度 \r\n  getScrollHeight: function() {\r\n    wx.createSelectorQuery().select('#box').boundingClientRect((rect) => {\r\n      this.setData({\r\n        scrollHeight: rect.height\r\n      })\r\n      console.log(this.data.scrollHeight)\r\n    }).exec()\r\n  },\r\n  // 假设数据请求\r\n  getDataList: function() {\r\n    wx.request({\r\n      url: 'test.php', //仅为示例，并非真实的接口地址\r\n      success: function(res) {\r\n      // 如果该元素下面的数据是动态获取的，此方法在wx.request请求成功的回调函数中调用\r\n        this.getScrollHeight()\r\n      }\r\n    })\r\n  },\r\n3.监听用户滑动页面事件    //监听用户滑动页面事件\r\n  onPageScroll: function(e) {\r\n   \r\n    if (e.scrollTop <= 0) {\r\n     // 滚动到最顶部\r\n      e.scrollTop = 0;\r\n    } else if (e.scrollTop > this.data.scrollHeight) {\r\n      // 滚动到最底部\r\n      e.scrollTop = this.data.scrollHeight;\r\n    }\r\n    if (e.scrollTop > this.data.scrollTop || e.scrollTop >= this.data.scrollHeight) {\r\n      //向下滚动 \r\n      console.log('向下 ', this.data.scrollHeight)\r\n    } else {\r\n      //向上滚动 \r\n      console.log('向上滚动 ', this.data.scrollHeight)\r\n    }\r\n    //给scrollTop重新赋值 \r\n    this.setData({\r\n      scrollTop: e.scrollTop\r\n    })\r\n  },参考：微信小程序如何判断页面上下滚动"}
{"title": "微信小程序抽奖-翻牌 ", "author": "Rolan", "pub_time": "2018-8-31 00:21", "content": "背景ps：本次开发基于wepy框架 由于最近接到一个需求--抽奖活动； 翻牌打乱活动抽奖活动，大概需求是这样的，九宫格卡牌，先正面展示所有奖品，然后卡牌翻转，打乱排序，点击卡牌，然后抽奖。这个需求本身其实不难，主要是分为三步；展示所有卡牌，然后翻转。打乱所有卡牌点击其中一张卡牌，抽奖第一步：卡牌翻转我们先在dom中渲染9个卡牌。<view class=\"card-module\">  <view class=\"card {{showClass ? 'change' : ''}}>    <view class=\"front card-item\">{{cardItem.front}}</view>    <view class=\"back card-item\">{{cardItem.back}}</view>  </view>  </repeat></view>在数据中生成模拟卡牌数据cardData: [    {      animationData: {},      front: '正面1',      back: '反面1'    },    ...    ...    {      animationData: {},      front: '正面9',      back: '反面9'    }  ],  showClass: false,在样式中把卡牌的基本样式渲染出来.card-module{  padding: 45rpx;  display: flex;  flex-direction: row;  flex-wrap: wrap;  transform:translate3d(0,0,0);  .card{    width: 200rpx;    height: 200rpx;    line-height: 200rpx;    text-align: center;    color: #fff;    margin: 10rpx;    position:relative;    overflow:hidden;    .card-item{      position:absolute;      left:0;      top:0;      width:100%;      height:100%;      transition:all .5s ease-in-out;      transform-style:preserve-3d;      backface-visibility:hidden;      box-sizing:border-box;    }    .front{      background-color: red;      transform: rotateY(0deg);      z-index:2;    }    .back{      background-color: #009fff;      transform: rotateY(180deg);      z-index:1;    }  }  .card.change{    .front{      z-index:1;      transform: rotateY(180deg);    }    .back{      z-index:2;        transform: rotateY(0deg);    }  }}效果如下这里有些css属性可能需要大部补充学习一下css3 backface-visibility 属性定义和用法 backface-visibility 属性定义当元素不面向屏幕时是否可见。 如果在旋转元素不希望看到其背面时，该属性很有用。CSS3 perspective 属性perspective 属性定义 3D 元素距视图的距离，以像素计。该属性允许您改变 3D 元素查看 3D 元素的视图。 当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。第二步：卡牌打乱由于业务上是抽奖使用的，所以选择的方案是：翻转后，卡牌收回到中间的卡牌中间，然后再让卡牌回到原来的位置。 关于小程序的原生框架有支持的动画接口，若不了解的请前往： developers.weixin.qq.com/miniprogram… 在对动画有基本了解之后，我们可以开始在翻转的基础上加上打乱的动画了 微信小程序的动画接口使用方式是在dom对象上面加上animation对象。 dom<view class=\"card-module\">  <view class=\"card {{showClass ? 'change' : ''}} animation=\"{{cardItem.animationData}}\" >    <view class=\"front card-item\">{{cardItem.front}}</view>    <view class=\"back card-item\">{{cardItem.back}}</view>  </view>  </repeat></view>scriptallMove () {    // 110 是卡牌宽度加边距    this.methods.shuffle.call(this, 110)    let timer = setTimeout(() => {      clearTimeout(timer)      this.methods.shuffle.call(this, 0)      this.$apply()    }, 1000)},// 洗牌shuffle (translateUnit) {    let curCardData = this.cardData    curCardData.map((item, index) => {      let animation = wepy.createAnimation({        duration: 500,        timingFunction: 'ease'      })      animation.export()      switch (index) {        case 0:          animation.translate(translateUnit, translateUnit).step()          break        case 1:          animation.translate(0, translateUnit).step()          break        case 2:          animation.translate(-translateUnit, translateUnit).step()          break        case 3:          animation.translate(translateUnit, 0).step()          break        case 4:          animation.translate(0, 0).step()          break        case 5:          animation.translate(-translateUnit, 0).step()          break        case 6:          animation.translate(translateUnit, -translateUnit).step()          break        case 7:          animation.translate(0, -translateUnit).step()          break        case 8:          animation.translate(-translateUnit, -translateUnit).step()          break      }      item.animationData = animation.export()    })    this.cardData = curCardData    this.$apply()},算法后面需要优化，我们先完成功能效果， 效果如下第三步：卡牌翻转dom代码<view class=\"card-module\">  <view class=\"card {{showClass ? 'change' : ''}}  {{curIndex === index ? 'getprize' : ''}}\" @tap=\"itemChage({{cardItem}}, {{index}})\" animation=\"{{cardItem.animationData}}\" >    <view class=\"front card-item\">{{cardItem.front}}</view>    <view class=\"back card-item\">{{cardItem.back}}</view>  </view>  </repeat></view>script代码data中定义一个curIndex = -1的对象data = {      curOpen: -1,      }methods = {    // 抽奖      itemChage (item, curIndex) {        this.cardData[curIndex].front = 'iphone x'        console.log(item, curIndex)        this.curOpen = curIndex      }}less.card.getprize{    .front{      z-index:2;      transform: rotateY(0deg);    }    .back{      z-index:1;        transform: rotateY(180deg);    }  }效果如下现在我们就已经完成了基本的需求；但是在位移动画时候代码写的太丑陋了。 我们来想想怎么优化算法； 我们现在就九宫格布局，我们可以看成是二维布局那我们是不是可以在卡牌中也使用二维数组布局属性resetData () {    const total = 9 // 总数    const lineTotal = 3 // 单行数    curCardData.map((item, index) => {      let curCardData = this.cardData      let x = index % lineTotal      let y = parseInt(index / lineTotal)      item.twoArry = {x, y}    })}在位移动画中使用二维布局的差值进行位移// 洗牌shuffle (translateUnit) {    let curCardData = this.cardData    curCardData.map((item, index) => {      let animation = wepy.createAnimation({        duration: 500,        timingFunction: 'ease'      })      animation.export()      const translateUnitX = translateUnit * (1 - item.twoArry.x)      const translateUnitY = translateUnit * (1 - item.twoArry.y)      animation.translate(translateUnitX, translateUnitY).step()      item.animationData = animation.export()    })    this.cardData = curCardData    this.$apply()},这样整个动画就算完成了，demo请前往githubgithub.com/fishmankkk/…作者：fishman 链接：https://juejin.im/post/5b867460f265da435743a8de 来源：掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}
{"title": "微信小程序开发入门与实践 ", "author": "Rolan", "pub_time": "2017-10-31 00:07", "content": "基础知识MINA 框架为方便微信小程序开发，微信为小程序提供了 MINA 框架，这套框架集成了大量的原生组件以及 API。通过这套框架，我们可以方便快捷的完成相关的小程序开发工作。MINA 框架提供了自己的视图层描述语言 WXML 和 WXSS，以及基于 JavaScript 的逻辑层框架，并在视图层与逻辑层间提供了数据传输和事件系统，因此我们主要聚焦于数据与逻辑上。响应的数据绑定框架的核心是一个响应的数据绑定系统。整个系统分为两块：视图层（View）和逻辑层（App Service），通过框架，可以让数据与视图保持同步变得很简单。当我们修改数据的时候，只需要在逻辑层修改数据，视图层就会做相应的更新。通过下面的例子来看：<!-- This is our View -->\r\n<view> Hello {{name}}! </view>\r\n<button bindtap=\"onChangeName\"> Click me! </button>// This is our App Service.\r\n// Register a Page.\r\nPage({\r\n  data: 'Baixing',\r\n  onChangeName: function(e) {\r\n    // sent data change to view\r\n    this.setData({\r\n      name: 'MINA'\r\n    })\r\n  }\r\n})以上通过框架将逻辑层数据中的 name 与视图层的 name 进行了绑定，所以在页面打开的时候会显示 \"Hello Baixing!\"，当点击按钮的时候，视图层会发送 onChangeName 的事件给逻辑层，逻辑层找到对应的事件处理函数。逻辑层执行了 setData() 的操作，将 name 从 Baixing 变为 MINA，因为该数据和视图层已经绑定了，从而视图层会自动改变为 \"Hello MINA!\" 。页面管理框架管理小程序的页面路由，可以做到页面间的无缝切换，并给以页面完整的生命周期。开发者需要做的只是将页面的数据、方法、生命周期函数注册进框架中，其他的一切复杂的操作都交由框架处理。基础组件框架提供了一套基础的组件，这些组件自带微信风格的样式以及特殊的逻辑，我们通过组合基础组件，就可以很方便的创建出强大的微信小程序。详情参考微信小程序组件文档。丰富的 APIMINA 框架提供丰富的微信原生 API，可以方便地调起微信提供的能力，如获取用户信息，本地存储，支付功能等。如果想了解更多，请参考微信小程序 API 文档。小程序目录结构小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。一个小程序主体部分由三个文件组成，必须放在项目的根目录下：文件作用app.js小程序启动入口文件app.json小程序公共设置，如注册路由信息app.wxss小程序公共样式表一个小程序页面由四个文件组成，分别是：文件作用js页面的具体逻辑功能，如页面的分享等逻辑方法wxml页面的结构，MINA 框架提供的各种组件便用于此wxss页面样式表，类似 Web 开发的 CSS 文件，用于控制页面的具体显示样式json页面配置，用以配置 MINA 框架提供的特有功能，如下拉刷新是否启用等配置信息注意：以上的四个文件必须具有相同的路径和文件名。小程序的运行机制注意小程序是没有重启的概念的，主要的运行机制如下：当小程序进入后台，客户端会维持一段时间的运行状态，超过一定时间后 (温馨官方文档 5 分钟) 会被微信主动销毁。被置顶的小程序不会被微信主动销毁。当收到系统内存警告也会进行小程序的销毁。开发实践讲了很多原理性的东西，如果没有实际实践的话，也只是一纸空谈。下面将以一个记账小程序作为开发实践，这个小程序用以记录每日花费以及具体花费说明。在开始前，请下载小程序开发工具。创建项目这里因为没有申请 AppID，所以选择了无 AppID 开发模式。如果有要使用 AppID 进行开发，可通过微信小程序官网进行配置，这里就不细说，具体参考微信小程序官网文档说明。开发工具的开始页面：如上，我们填写好项目名称，选择项目目录后，点击添加项目，就进入所创建项目的开发界面，如下:在左侧的编辑选项卡下，可以进行代码的编辑工作。在调试选项卡下，可以进行调试工作，如断点调试、查看当前存储信息、模拟坐标等。在项目选项卡下，可以配置当前的程序运行选项，如是切换基础库版本、生成小程序预览等。创建页面我们的程序主要有两个页面，一个是展示所有记账记录的首页页面，一个是添加记账的页面。在开发工具编辑选项卡下，点击添加新建，输入要创建的文件就可以了。完成后具体的目录如下：在上面的（Pages）目录中，每个不同的页面目录下存在 4 种不同的文件格式。在基础知识部分，有讲解过不同格式具体的作用，这里不再赘述。接下来就进入实际的编码工作吧。编写代码1. 首页的具体功能包括：统计花费总额展示每次记录的概要信息页面主要逻辑代码如下：import {\r\n  loadAllRecord,\r\n  deleteRecordById \r\n} from '../../services/tallyService.js'\r\nvar app = getApp()\r\n\r\nPage({\r\n  data: {\r\n    userInfo: {},\r\n    list: [],\r\n    totalMoney: 0\r\n  },\r\n  ...\r\n  // 加载已存的每日花费记录，且统计总共花费的金额。\r\n  fetchData() {\r\n    wx.showLoading({\r\n      title: '加载数据中...',\r\n    })\r\n\r\n    var self = this\r\n    loadAllRecords((list) => {\r\n      var totalMoney = 0\r\n      list.forEach((item) => {\r\n        totalMoney += Number(item.money)\r\n      }) \r\n      self.setData({list, totalMoney})\r\n\r\n      self.customerData.isFirstShow = false\r\n      setTimeout(() => {\r\n        wx.hideLoading()\r\n      }, 1000)\r\n    })\r\n  }\r\n  ...\r\n})页面结构代码如下：<!--index.wxml-->\r\n<view class=\"container\">\r\n  <view  bindtap=\"bindViewTap\" class=\"userinfo\">\r\n    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\r\n    <view class=\"info-view\">\r\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\r\n      <text class=\"money-text\">总花费：{{totalMoney}}元</text>\r\n    </view>\r\n  </view>\r\n  <view class=\"list-view\">\r\n    <block wx:for=\"{{list}}\" wx:key=\"*this\">\r\n      <view class=\"tally-cell\">\r\n        <text class=\"detail-text\">{{item.detail}}</text>\r\n        <text class=\"money-text\">{{item.money}}元</text>\r\n        <text class=\"time-text\">{{item.time}}</text>\r\n      </view>\r\n    </block>\r\n  </view>\r\n  <navigator class=\"add-button\" url=\"../record/record\" open-type=\"navigate\">记一笔</navigator>\r\n</view>2. 记录页面主要功能：用于记录具体的花费金额以及花费详情页面主要逻辑代码如下：import {addNewRecord} from '../../services/tallyService.js'\r\nvar app = getApp()\r\n\r\nPage({\r\n  ...\r\n  onSaveRecord() {\r\n    let record = {\r\n      money: this.customerData.money, \r\n      detail: this.customerData.detail\r\n    }\r\n    addNewRecord(record, (res)=>{\r\n      console.log(res)\r\n      wx.navigateBack({})\r\n    })\r\n  }\r\n})页面结构代码如下：<!--record.wxml-->\r\n<view class=\"container record-view\">\r\n  <view class=\"money-view\">\r\n    金额：\r\n    <input placeholder=\"请输入要记录的花费金额...\" \r\n      bindblur=\"onMoneyBlured\" \r\n      maxlength=\"10\" \r\n      placeholder-style=\"font-size: 14px;\"\r\n      confirm-type=\"done\" \r\n      type=\"digit\" \r\n      auto-focus\r\n      value=\"{{money}}\"\r\n      bindinput=\"onMoneyChanged\"/>\r\n  </view>\r\n  <view class=\"detail-view\">\r\n    花费记录：\r\n    <textarea class=\"detail-textarea\"\r\n      placeholder-style=\"font-size: 14px;\"\r\n      placeholder=\"请输入具体的花费详细吧...\"\r\n      maxlength=\"160\"\r\n      cursor-spacing=\"10\"\r\n      bindinput=\"onDetailChanged\"/>\r\n  </view>\r\n  <button class=\"save-button\" \r\n    catchtap=\"onSaveRecord\" \r\n    formType=\"submit\" \r\n    disabled=\"{{ !canSave }}\">\r\n    保存\r\n  </button>\r\n</view>3. 记录 Dao 类主要逻辑代码如下：var records = []\r\nimport {formatTime} from '../utils/util.js'\r\n\r\nfunction addNewRecord({money, detail}, callback) {\r\n  let id = records.length\r\n  let time = formatTime(new Date())\r\n  let record = {id, money, detail, time}\r\n  records.push(record)\r\n\r\n  if (typeof callback === 'function') {\r\n    callback(true)\r\n  }\r\n}\r\n\r\nfunction loadAllRecord(callback) {\r\n  if (typeof callback === 'function') {\r\n    callback(records)\r\n  }\r\n}\r\n\r\nmodule.exports = {\r\n  addNewRecord,\r\n  loadAllRecord\r\n}预览如果是通过填写 AppID 进行开发，在开发工具的项目选项卡下，点击预览即可生成当前小程序二维码。然后使用具有开发者或体验者权限的微信帐号扫一扫二维码，即可真机操作小程序。具体设置如下图所示：我这里因为是通过无 AppID 开发，所以只能通过开发工具进行预览了。最终的程序运行页面如下：本文完整代码下载：github.com/wanghongli1…尾注当前小程序开发的热度已然越演越烈，各种小程序层出不穷。希望本文能给正打算开发微信小程序或者对微信小程序开发感兴趣的小伙伴们带来一些帮助，感谢阅读。作者：王洪礼简介：百姓网 iOS 开发工程师。"}
{"title": "微信小程序修改自定义input ", "author": "Rolan", "pub_time": "2018-5-22 00:31", "content": "在微信小程序中是不能修改input样式的 甚至修改大小也不能，那么怎么做一个自定义样式的input呢说一下我做的input的原理 有两张图片 一张是未选中的(input.png)一张是已经选中的 (input_n.png) 更具点击事件bindtap 事件来更换图片的路径实现首先请求后台接口获取数据wx.request({      url: imgsrc + '/wechar/product/getproduct',      data: '',      header: {},      method: 'GET',      dataType: 'json',      responseType: 'text',      success: function (res) {        console.log(res);        that.setData({          product: res.data,        });      },    })　　获得数据格式把这些数据存入data里面在wxml中写循环给图片写入事件cli1 把数组下标存入data-id 用于区分点击了哪个按钮<view class=\"boxaa\" wx:for=\"{{product}}\" >    <view class='gongpin'>      <image src='{{imgsrc+item.pro_imgs}}'></image>      <view class='descript'>{{item.pro_name}}</view>      <view class='price'>{{item.pro_price}}</view>     </view>    <image class='radiocheck' data-proid=\"{{item.pro_id}}\" bindtap='cli1' src='../../imgs/{{item.imgsrc}}'data-name=\"{{item.pro_name}}\" data-id=\"{{index}}\"  ></image>js代码 cli1:function(res)  {　　　　//获取数组的下标 用来确认点击的是那个按钮　　 var id = res.currentTarget.dataset.id;　　　　//把选中的商品名字存起来    selectedProName = res.currentTarget.dataset.name;    　　//把选中的商品id存起来 　　 selectedProId = res.currentTarget.dataset.proid;　　  　　//因为是单选按钮首先循环所有的商品把input改为未选中的状态    for (var x in product) {      product[x].imgsrc = \"radio.png\";    }　　//根据获取过来的数组下标判断input是否是选中状态 如果是切换为未选中状态 如果不是改为选中状态    if (product[id].imgsrc == \"radio.png\") {      product[id].imgsrc = \"radio_n.png\";    } else {      product[id].imgsrc = \"radio.png\";    }　　把整个数组存入data中    this.setData({      product: product,    });  }"}
{"title": "强烈推荐：支持Vue家族全系框架的跨平台http请求库-fly.js ", "author": "Rolan", "pub_time": "2018-3-21 00:16", "content": "Fly.js 一个基于Promise的、强大的、支持多种JavaScript运行时的http请求库. 有了它，您可以使用一份http请求代码在浏览器、微信小程序、Weex、Node中都能正常运行。同时可以方便配合 Vue家族的框架，最大可能的实现 Write Once Run Everywhere。Github: https://github.com/wendux/fly问题随着 Weex 、mpvue 的发布，他们都是支持Vue.js语法。目前vue已经你能够运行在浏览器、小程序和Native了。尽管各个平台仍有差异，但已经基本能实现 Write Once Run Everywhere 。这使得我们可以在多个端上实现尽可能大限度在代码复用。但是无论是 vue 还是Weex 、mpvue，它们本质上都只是一个View层，也就说最好的情况，也只能实现UI复用。但对于一个应用程序来说，除了UI，最重要的就是数据了，而数据来源一般都是来自网络请求（大多数都是http）。在使用这些框架时，您的网络请求，都需要使用平台特定的API！这很糟糕，意味着您网络请求的代码不能复用，所以尽管UI可以复用，但我们还需要去适配网络请求部分的代码。一致的网络请求要解决这个问题，就需要一个能支持多个平台网络库，用户层提供统一的API，将平台差异在底层屏蔽。而 Fly.js就是这酱紫的一个网络库，为了方便axios使用者迁移，fly.js API设计风格和axios相似（但不完全相同）！Fly.js 通过在不同 JavaScript 运行时通过在底层切换不同的 Http Engine来实现多环境支持，但同时对用户层提供统一、标准的Promise API。不仅如此，Fly.js还支持请求/响应拦截器、自动转化JSON、请求转发等功能，详情请参考：https://github.com/wendux/fly已支持的平台目前Fly.js支持的平台包括：Node.js 、微信小程序 、Weex 和浏览器，这些平台的 JavaScript 运行时都是不同的。更多的平台正在持续添加中，请保持关注。Fly简单使用示例下面示例如无特殊说明，则在所有支持的平台下都能执行。发起GET请求//不同平台可能需要引入不同文件，详情见文档\r\nvar fly=require(\"flyio\")\r\n\r\n//通过用户id获取信息,参数直接写在url中\r\nfly.get('/user?id=133')\r\n  .then(function (response) {\r\n    console.log(response);\r\n  })\r\n  .catch(function (error) {\r\n    console.log(error);\r\n  });\r\n\r\n//query参数通过对象传递\r\nfly.get('/user', {\r\n      id: 133\r\n  })\r\n  .then(function (response) {\r\n    console.log(response);\r\n  })\r\n  .catch(function (error) {\r\n    console.log(error);\r\n});\r\n发起POST请求fly.post('/user', {\r\n    name: 'Doris',\r\n    age: 24\r\n    phone:\"18513222525\"\r\n  })\r\n  .then(function (response) {\r\n    console.log(response);\r\n  })\r\n  .catch(function (error) {\r\n    console.log(error);\r\n  });发起多个并发请求function getUserRecords() {\r\n  return fly.get('/user/133/records');\r\n}\r\n\r\nfunction getUserProjects() {\r\n  return fly.get('/user/133/projects');\r\n}\r\n\r\nfly.all([getUserRecords(), getUserProjects()])\r\n  .then(fly.spread(function (records, projects) {\r\n    //两个请求都完成\r\n  }))\r\n  .catch(function(error){\r\n    console.log(error)\r\n  })拦截器Fly支持请求／响应拦截器，可以通过它在请求发起之前和收到响应数据之后做一些预处理。\r\n//添加请求拦截器\r\nfly.interceptors.request.use((request)=>{\r\n    //给所有请求添加自定义header\r\n    request.headers[\"X-Tag\"]=\"flyio\";\r\n      //打印出请求体\r\n      console.log(request.body)\r\n      //终止请求\r\n      //var err=new Error(\"xxx\")\r\n      //err.request=request\r\n      //return Promise.reject(new Error(\"\"))\r\n  \r\n    //可以显式返回request, 也可以不返回，没有返回值时拦截器中默认返回request\r\n    return request;\r\n})\r\n\r\n//添加响应拦截器，响应拦截器会在then/catch处理之前执行\r\nfly.interceptors.response.use(\r\n    (response) => {\r\n        //只将请求结果的data字段返回\r\n        return response.data\r\n    },\r\n    (err) => {\r\n        //发生网络错误后会走到这里\r\n        //return Promise.resolve(\"ssss\")\r\n    }\r\n)除过以上这些使用，Fly.js 还有很多其它强大的功能，详情请移步Fly.js.反馈如果您有问题欢迎在 在github 提issue . fly.js github: https://github.com/wendux/fly"}
{"title": "微信小程序之二：元宵灯笼连连看小游戏 ", "author": "Rolan", "pub_time": "2018-3-7 00:44", "content": "20180301 by 慕容秋写在前面前些天闲聊中跟家里的领导说，微信也可以做小游戏诶。然后她说，那你做个连连看游戏给我玩玩呗。再然后就有了这几天的摸索和下面的一些小结：演示效果: http://link.muroqiu.com源码地址: https://gitee.com/muroqiu/LinkUp开发工具：Cocos Creator v1.8.1Visual Studio Code 1.20.1Adob illustrator CC 2018微信开发者工具 1.02.1802270主要的工作是在Cocos Creator和Visual Studio Code里完成的，illustrator CC 用来资源切图，微信开发者工具是最后打包微信小游戏用到；Cocos Creator对微信小游戏的支持已经很到位了，游戏写好后只要在构建时选择发布平台为Wechat Game就好。目前微信还未开放小游戏注册与上架，只能用开发者的微信测试体验。好在Cocos Creator跨平台发布很方便，构建了个Web Mobile版本，发布到服务器上，大家有兴趣就一起可以体验咯^_^主要的逻辑：A、洗牌 shuffle：遍历图片数组，取1个随机位置的图片和当前位置交换；B、用一个二维数组（各个方向均比图片数组大1）保存图片的状态值，搜索路径时映射到这个数组搜索；C、搜索顺序：1、同一条直线：判断直线间有无图片；2、有一个拐角：先定位出两个拐角点，若拐角点没有图片，再转换成一条直线的情况继续处理；3、两个拐角：某个方向移动，若到达点没有图片，再转换成一个拐角的情况继续处理；若到达点有图片，此方向不再继续搜索；/**\r\n     * 直连\r\n     */\r\n    matchBlockLine: function (x1, y1, x2, y2) {\r\n        // cc.warn('matchBlock  ' + x1 + ', ' + y1 + '  : ' + x2 + ', ' + y2); if (x1 != x2 && y1 != y2) {\r\n            return false;\r\n        }\r\n\r\n        if (x1 == x2) {\r\n            // 同一列 if (x1 < 0 || x1 >= this.rows) {\r\n                return true;\r\n            }\r\n            var Ymin = Math.min(y1, y2) + 1;\r\n            var Ymax = Math.max(y1, y2);\r\n            for (Ymin; Ymin < Ymax; Ymin++) {\r\n                if (this._canvasGrids[x1 + 1][Ymin + 1] > this._TYPE_INIT) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else if (y1 == y2) {\r\n            // 同一行 if (y1 < 0 || y1 >= this.columns) {\r\n                return true;\r\n            }\r\n            var Xmin = Math.min(x1, x2) + 1;\r\n            var Xmax = Math.max(x1, x2);\r\n            for (Xmin; Xmin < Xmax; Xmin++) {\r\n                if (this._canvasGrids[Xmin + 1][y1 + 1] > this._TYPE_INIT) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    },\r\n/**\r\n     * 一个转角\r\n     * 搜索到路径时，返回转角坐标 x3, y3\r\n     */\r\n    matchBlockCorner: function (x1, y1, x2, y2, isAxis_X) {\r\n        // cc.warn('matchBlockCorner  ' + x1 + ', ' + y1 + '  : ' + x2 + ', ' + y2); var result;\r\n        // 直连的返回 if (x1 == x2 || y1 == y2) {\r\n            return null;\r\n        }\r\n\r\n        // 转角点1 (x1, y2)，Y方向 if (this._canvasGrids[x1 + 1][y2 + 1] <= this._TYPE_INIT && isAxis_X != false) {\r\n            result = this.matchBlockCorner_point(x1, y1, x2, y2, x1, y2);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        // 转角点2 (x2, y1)，X方向 if (this._canvasGrids[x2 + 1][y1 + 1] <= this._TYPE_INIT && isAxis_X != true) {\r\n            result = this.matchBlockCorner_point(x1, y1, x2, y2, x2, y1);\r\n            if (result) {\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * 转角逻辑\r\n     */\r\n    matchBlockCorner_point: function (x1, y1, x2, y2, x3, y3) {\r\n        var stMatch = this.matchBlockLine(x1, y1, x3, y3);\r\n        if (stMatch) {\r\n            var tdMatch = this.matchBlockLine(x3, y3, x2, y2);\r\n            if (tdMatch) {\r\n                return [x3, y3];\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n/**\r\n     * 两个转角\r\n     * 由中心往外展开搜索路径，某个方向当碰到有图片时，这个方向就不再继续搜索\r\n     * 搜索到路径时，返回两个转角点坐标 x3, y3, x4, y4\r\n     */\r\n    matchBlockUnfold: function (x1, y1, x2, y2) {\r\n        var result;\r\n        var x3 = 0;\r\n        var y3 = 0;\r\n        var canUp = true;\r\n        var canDown = true;\r\n        var canLeft = true;\r\n        var canRight = true;\r\n\r\n        // cc.warn('matchBlockUnfold  ' + x1 + ', ' + y1 + '  : ' + x2 + ', ' + y2); for (var i = 1; i < this.rows; i++) {\r\n            // 上\r\n            x3 = x1;\r\n            y3 = y1 + i;\r\n            if (canUp && y3 <= this.columns) {\r\n                canUp = this._canvasGrids[x3 + 1][y3 + 1] <= this._TYPE_INIT;\r\n                result = this.matchBlockUnfold_axis(x1, y1, x2, y2, x3, y3, false);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n\r\n            // 下\r\n            x3 = x1;\r\n            y3 = y1 - i;\r\n            if (canDown && y3 >= -1) {\r\n                canDown = this._canvasGrids[x3 + 1][y3 + 1] <= this._TYPE_INIT;\r\n                result = this.matchBlockUnfold_axis(x1, y1, x2, y2, x3, y3, false);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n\r\n            // 左\r\n            x3 = x1 - i;\r\n            y3 = y1;\r\n            if (canLeft && x3 >= -1) {\r\n                canLeft = this._canvasGrids[x3 + 1][y3 + 1] <= this._TYPE_INIT;\r\n                result = this.matchBlockUnfold_axis(x1, y1, x2, y2, x3, y3, true);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n\r\n            // 右\r\n            x3 = x1 + i;\r\n            y3 = y1;\r\n            if (canRight && x3 <= this.rows) {\r\n                canRight = this._canvasGrids[x3 + 1][y3 + 1] <= this._TYPE_INIT;\r\n                result = this.matchBlockUnfold_axis(x1, y1, x2, y2, x3, y3, true);\r\n                if (result) {\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * 某个方向上的搜索逻辑\r\n     */\r\n    matchBlockUnfold_axis: function (x1, y1, x2, y2, x3, y3, isAxis_X) {\r\n        // cc.warn(\"matchBlockUnfold_axis  \" + x3 + ', ' + y3); var tmpXY = [];\r\n        if (this._canvasGrids[x3 + 1][y3 + 1] <= this._TYPE_INIT) {\r\n            tmpXY = this.matchBlockCorner(x3, y3, x2, y2, isAxis_X);\r\n            if (tmpXY) {\r\n                return [x3, y3].concat(tmpXY);;\r\n            }\r\n        }\r\n        return null;\r\n    },\r\n参考资料http://blog.csdn.net/artzok/article/details/51622782"}
{"title": "微信小程序-两个input叠加，多次点击字体变粗或闪动 ", "author": "Rolan", "pub_time": "2018-5-17 00:18", "content": "问题描述：当两个input叠加，多次点击input框， placeholder 字体变粗或input框闪动。如图：代码：<!--  最上层input-1 --><input  placeholder='请输入昵称，手机号，客户名称' ></input><!--  底层input-2 点击后会遮盖上层input-1 --><input  placeholder='请输入昵称，手机号，客户名称' ></input>效果示意图：解决办法：input-1添加 disabled=\"disabled\" ，input-2 的 placeholder 去掉<!--  最上层input-1 --><input  placeholder='请输入昵称，手机号，客户名称' disabled=\"disabled\"></input><!--  底层input-2 点击后会遮盖上层input-1 -->"}
{"title": "小程序生成海报保存分享图片完全指南 ", "author": "Rolan", "pub_time": "2018-8-21 00:28", "content": "小程序生成海报保存分享图片完全指南（包括：头像，文字）作者：starkwang原文：https://segmentfault.com/a/1190000016039298业务在小程序中生成海报（包括用户头像和自定义文字）并且保存到本地实现思路利用canvas画布，把用户头像和自定义文字定位好，用户点击按钮保存到本地注意事项 难点小程序canvas不支持自定义宽高，反正我没找到，canvas画布大部分业务都需要全屏，响应式，至少宽100%解决方案：判断到屏幕尺寸，传到wxml 里面远程图片不能直接使用 getImageInfo 获取，需要保存到本地解决方案：canvas直接支持远程图片，不需要使用这个api先来个ui （嘿嘿！此图经过公司的设计授权过）技术栈canvaswx.createCanvasContextwx.canvasToTempFilePathPromise实战首先我们在wxml里面写一个canvas占位注意这里的宽度是100%，响应式，海报的高posterHeight 是从js里面动态计算的<canvas canvas-id=\"starkImg\" style=\"width:100%;height:{{posterHeight}}px;\"></canvas>根据屏幕动态计算海报的尺寸data: {\r\n  motto: 'Hello World',\r\n  hidden: true,\r\n  userInfo: {},\r\n  hasUserInfo: false,\r\n  windowWidth: '',\r\n  posterHeight: '',\r\n},\r\nonLoad: function () {\r\n  const poster = {\r\n    \"with\": 375,\r\n    \"height\": 587\r\n  }\r\n  const systemInfo = wx.getSystemInfoSync()\r\n  let windowWidth = systemInfo.windowWidth\r\n  let windowHeight = systemInfo.windowHeight\r\n  let posterHeight = parseInt((windowWidth / poster.with) * poster.height)\r\n  this.setData({\r\n    windowWidth: windowWidth,\r\n    posterHeight: posterHeight\r\n  })\r\n}背景图片生成  const that = this\r\n  // 图片路径\r\n  const imagePath = '../../static/image/common/'\r\n  let bgimgPromise = new Promise(function (resolve, reject) {\r\n    console.log('data', that.data)\r\n    wx.getImageInfo({\r\n      src: imagePath + \"base.png\",\r\n      success: function (res) {\r\n        resolve(res);\r\n      }\r\n    })\r\n  });头像直接使用远程头像初始化的时候，调取，一定在生成海报之前此处可以存储本地，或使用状态都可以wxml// 可以从后端接口获取 或 官方本身远程地址\r\n\r\n \r\n  <button class=\"share\" type=\"primary\" open-type=\"getUserInfo\" bindgetuserinfo=\"getUserInfo\">开始答题（获取用户信息）</button>\r\njs  getUserInfo: function (e) {\r\n    app.globalData.userInfo = e.detail.userInfo\r\n    let userInfo = e.detail.userInfo\r\n    console.log('userInfo', userInfo)\r\n    // 更新用户信息\r\n    // api.post('更新用户信息的url', userInfo)\r\n    this.setData({\r\n      userInfo: e.detail.userInfo,\r\n      hasUserInfo: true\r\n    })\r\n  },生成海报背景和图片wxmlbgimgPromise.then(res => {\r\n      console.log('Promise.all', res)\r\n      const ctx = wx.createCanvasContext('shareImg')\r\n      ctx.width = windowWidth\r\n      ctx.height = posterHeight\r\n      console.log(windowWidth, posterHeight)\r\n      // 背景图\r\n      ctx.drawImage('../../' + res[0].path, 0, 0, windowWidth, posterHeight, 0, 0)\r\n      // 头像\r\n      ctx.drawImage(that.data.userInfo.avatarUrl, 48, 182, 58, 58, 0, 0)\r\n      ctx.setTextAlign('center')\r\n      ctx.setFillStyle('#000')\r\n      ctx.setFontSize(22)\r\n      // ctx.fillText('分享文字2：stark.wang出品', 88, 414)\r\n      ctx.fillText('分享文字1我的博客：https://shudong.wang', 55, 414)\r\n      ctx.stroke()\r\n      ctx.draw()\r\n    })保存到本地onLoad: function () {\r\n  share: function () {\r\n    var that = this\r\n    wx.showLoading({\r\n      title: '正在制作海报。。。'\r\n    })\r\n    new Promise(function (resolve, reject) {\r\n      wx.canvasToTempFilePath({\r\n        x: 0,\r\n        y: 0,\r\n        width: 444,\r\n        height: 500,\r\n        destWidth: 555,\r\n        destHeight: 666,\r\n        canvasId: 'starkImg',\r\n        success: function (res) {\r\n          console.log(res.tempFilePath);\r\n          that.setData({\r\n            prurl: res.tempFilePath,\r\n            hidden: false\r\n          })\r\n          wx.hideLoading()\r\n          resolve(res)\r\n        },\r\n        fail: function (res) {\r\n          console.log(res)\r\n        }\r\n      })\r\n    }).then(res => {\r\n      console.log(res)\r\n      this.save()\r\n    })\r\n  }\r\n}结果更新头像裁剪为圆形ctx.save() // 对当前区域保存\r\nctx.beginPath() // 开始新的区域\r\nctx.arc(73, 224, 38, 0, 2 * Math.PI);\r\nctx.clip();  // 从画布上裁剪出这个圆形\r\nctx.drawImage(res[1], 36, 186, 94, 94, 0, 0) // 把图片填充进裁剪的圆形\r\nctx.restore() // 恢复上面是远程连接容易发生请求失败把头像提前存到本地存储中解决getImg: function () {\r\n  let avatarUrl = this.data.userInfo.avatarUrl\r\n  downLoadFile(avatarUrl).then((res) => {\r\n    console.log(res)\r\n    wx.saveFile({\r\n      tempFilePath: res.data.tempFilePath,\r\n      success: function (res) {\r\n        wx.setStorageSync('avatarUrl', res.savedFilePath)\r\n      }\r\n    })\r\n  })\r\n},获取头像// 头像\r\nlet promiseAvatarUrl = new Promise(function (resolve, reject) {\r\n  resolve(wx.getStorageSync('avatarUrl'))\r\n}).catch(res=>{\r\n  console.log('catch',res)\r\n});背景还是不变const that = this\r\nlet promiseBdImg = new Promise(function (resolve, reject) {\r\n  console.log('data', that.data)\r\n  wx.getImageInfo({\r\n    src: imagePath + \"base1.png\",\r\n    success: function (res) {\r\n      console.log('promiseBdImg', res)\r\n      resolve(res);\r\n    }\r\n  })此时生成canvas更新Promise.all([\r\n    promiseBdImg, promiseAvatarUrl\r\n  ]).then(res => {\r\n    console.log('Promise.all', res)\r\n    const ctx = wx.createCanvasContext('shareImg')\r\n    ctx.width = windowWidth\r\n    ctx.height = posterHeight\r\n    console.log(windowWidth, posterHeight)\r\n    //主要就是计算好各个图文的位置\r\n    ctx.drawImage('../../' + res[0].path, 0, 0, windowWidth, posterHeight, 0, 0)\r\n    ctx.save() // 对当前区域保存\r\n    ctx.beginPath() // 开始新的区域\r\n    ctx.arc(73, 224, 38, 0, 2 * Math.PI);\r\n    ctx.clip();  // 从画布上裁剪出这个圆形\r\n    ctx.drawImage(res[1], 36, 186, 94, 94, 0, 0) // 把图片填充进裁剪的圆形\r\n    ctx.restore() // 恢复\r\n    ctx.setTextAlign('center')\r\n    ctx.setFillStyle('#000')\r\n    ctx.setFontSize(22)\r\n    ctx.save()\r\n    ctx.beginPath();\r\n    ctx.fillText('作者：stark.wang', 545 / 2, 130)\r\n    ctx.fillText('我的博客：http://shudong.wang', 190, 414)\r\n    ctx.stroke()\r\n    ctx.draw()\r\n  })结果完美ok，如果能帮助你，请赞一个。感觉日后会需要，推荐收藏"}
{"title": "微信小程序 - IOS 仿饿了么\"我的\",下拉橡皮筋效果 ", "author": "Rolan", "pub_time": "2017-11-29 00:31", "content": "这个需求是在wepy交流群里有群友提到的. 一个小花样.注册mixins/** * IOS专用 顶部下拉橡皮筋效果 * 安卓的Page在到达顶部的时候,不能继续下拉...略过 *  *  效果见  饿了么送餐服务 \"我的\" 页面 IOS环境  上下拖动 *  * 下拉时, 顶部色块拉伸,上划时,顶部色块收缩. * wxml  :   <view style='background-color: #0000ff;min-height:50vh;z-index:-1;height:{{elastic_topHeight||50}}px;width:100%;position:fixed;top:{{elastic_top}}px;'></view> *  */ var obj = {  onLoad(){    /**获取当前是何种平台 */    var SystemInfo = getApp().globalData.SystemInfo||{};    this.__IS_IOS = SystemInfo.system && SystemInfo.system.toLowerCase().indexOf(\"ios\")>=0;  },  onPageScroll(e) {   //非ios 略过效果    if (!this.__IS_IOS)return;    // console.log(e)    var top = e.scrollTop;    if (top > 0) {  //上划时, 整个view上移 , 避免因为持续上划,看到 后面的view      this.setData({        elastic_top: -top      });      return;    }    this.setData({  //动态设置 高度      elastic_topHeight: Math.abs(top * 2)+50    });  }};module.exports= obj;wxml很简单.在你的最外层增加 <view style='background-color: #0000ff;min-height:50vh;z-index:-1;height:{{elastic_topHeight||50}}px;width:100%;position:fixed;top:{{elastic_top}}px;'></view>style中颜色自定义,其他根据需要来注意,他上拉的时候,背景色还是白色,和顶部颜色并不一样.这种方式实现,要求你的 顶级view要有一个背景色,否则这个橡皮筋效果就会暴露出来"}
{"title": "微信小程序模板消息群发解决思路 ", "author": "Rolan", "pub_time": "2017-11-28 00:31", "content": "基于微信的通知渠道，微信为开发者提供了可以高效触达用户的模板消息能力，以便实现服务的闭环并提供更佳的体验。（微信6.5.2及以上版本支持模板功能。低于该版本将无法收到模板消息。）模板推送位置：服务通知（点击查看详情还能跳转到下发消息的小程序的指定页面）模板下发条件：用户本人在微信体系内与页面有交互行为后触发微信小程序模板消息使用说明（官方文档）：https://mp.weixin.qq.com/debug/wxadoc/dev/api/notice.html为了防止对模板消息的滥用，带来不好的用户体验，小程序对模板消息推送做了相应的限制。下发条件说明（触发模板消息下发的两个场景）：1. 支付当用户在小程序内完成过支付行为，可允许开发者向用户在7天内推送有限条数的模板消息（1次支付可下发3条，多次支付下发条数独立，互相不影响）2. 提交表单当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）也就是说，用户提交一次表单，会提供给开发者一次推送权限，多次提交的情况下下发条数独立。所以如果开发者想要哎7天内无限制的为用户推送消息，需要做的就是-->从用户那里获取足够多的推送权限（推送权限就是form表单的formid）。所以，我们可以在前端页面来收集用户的formid，然后保存在服务器上。根据小程序的文档说明：用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，只能在用户发生提交行为的时候收集formid，所以，我们可以把页面上用户可点击的按钮或其他元素用表单组件中的button按钮组件来代替，把用户的交互点击的bindtap事件通过表单的bindsubmit来代替 ，从而捕获用户的点击事件来产生更多的formId。等到真正需要网络请求的时候将收集到的formid发送至服务器保存。发送成功以后清空formid，以便再次收集新的formid。后端在发送模板消息的时候先从保存的formid中挑出未过期的一条formid，删除已过期的不可用的fromid以及当前将要用的formid。注：这只是一个解决思路，请务必在严格遵守小程序运营规范的前提下把本思路作为一个参考。未解决问题：如果用户在一周内没有访问或点击过小程序中的任何组件，那我们就收集不到有效的fromid，也就意味着我们失去了给用户发送模板消息的权限，这种情况下该怎么办？"}
{"title": "小程序常见问题汇总 ", "author": "Rolan", "pub_time": "2017-11-27 00:08", "content": "1.微信小程序规定页面路径最多只能是五层，当进入第五层页面之后，wx.navigateTo将不能正常打开新页面。请避免多层级的交互方式，或者使用如下方式解决：（1）wx.navigateBack({  delta: 2})关闭当前页面，返回上一页面或多级页面delta--返回的页面层数（2）wx.reLaunch({  url: 'index?id=1'})关闭所有页面，打开到应用内的某个页面。（3）wx.redirectTo({  url: 'test?id=1'})使用redirectTo代替navigateTo（关闭当前页面，跳转到应用内的某个页面） 注：tab定义过的页面跳转只能用wx.switchTab跳转，wx.navigateTo等跳转无效2.tabBar图标必须是相对路径3.防止重复提交和打开多个页面的方法：（1）定义一个data来作为判断依据，如　　bindtap=\"{{(isConfirmBuy==0)?'':'confirmBuy'}}\"（此方法仅针对多次点击按钮事件，表单重复提交无效）（2）根据点击事件的时间戳来判断，如function bindViewTap(e) {//该方法针对快速点击多次跳转多次引起的BUGvar time = e.timeStamp;//console.log(time+\"---\"+app.globalData.lastTapTime+\"---\"+Math.abs(time-app.globalData.lastTapTime))//设置无效点击，根据自己的需求设置，这里navigateTo切换页面到动画结束需要的时间为500毫秒左右if (Math.abs(time - app.globalData.lastTapTime) < 500 && app.globalData.lastTapTime != 0) {//app.globalData.lastTapTime = time; //这里一定更新无效点击的时间return false;}else{app.globalData.lastTapTime = time;return true;}//更新有效点击的时间}//定义公共方法var bvt = common.bindViewTap(e);if(!bvt) return false;//事件最开始调用（推荐）4.赋值写法：this.setData({ 'status':false }); 有效         this.data.status= true 无效5.注意将上传下载网络请求等接口地址设置白名单。6.小程序onLaunch里面异步取值导致首页onload取值取不到的问题方案：（1）做个启动页过度 （2）把下面的方法放到异步请求成功后的success里面if (getCurrentPages().length != 0) {  getCurrentPages()[getCurrentPages().length - 1].onLoad()}7.小程序之间的跳转问题：（https://mp.weixin.qq.com/debug/wxadoc/dev/api/navigateToMiniProgram.html）（1）相互跳转的小程序必须关联同一个公众号（2）小程序跳转需通过extraData传值和取值，可通过App.onShow()获取，App.onLaunch()获取好像拿不到。8.理论上只有表单提交和支付场景下可以发送模板消息（表单提交场景下，为 submit 事件带上的 formId；支付场景下，为本次支付的 prepay_id）（1）支付当用户在小程序内完成过支付行为，可允许开发者向用户在7天内推送有限条数的模板消息（1次支付可下发3条，多次支付下发条数独立，互相不影响）（2）提交表单当用户在小程序内发生过提交表单行为且该表单声明为要发模板消息的，开发者需要向用户提供服务时，可允许开发者向用户在7天内推送有限条数的模板消息（1次提交表单可下发1条，多次提交下发条数独立，相互不影响）实际应用时可以通过模拟表单提交获取多个formId再保存下来，这样7天之内就可以随时给用户发送模板消息，以实现批量发送的效果。如：<form bindsubmit=\"goOrderList\" report-submit=\"true\"><button class=\"list\" data-za-title=\"我的订单\" formType=\"submit\" hover-class=\"none\">我的订单</button></form>9.map、canvas、video、textarea 是由客户端创建的原生组件，原生组件的层级是最高的，所以页面中的其他组件无论设置 z-index 为多少，都无法盖在原生组件上。 原生组件暂时还无法放在 scroll-view 上，也无法对原生组件设置 css 动画10.微信小程序showToast都是带icon的，如果需要不带icon的toast需要自己封装11.wx.showModal微信自带对话框，content不支持html类型数据，仅支持txt，支持\\n\\r，所以扩展性不好。(复杂情况下推荐自己写)12.连续快速点击input获取焦点后马上点击按钮，input不会失去焦点键盘不会收起，应用场景如发送验证码。13.微信小程序授权问题：如果拒绝授权，短时间内微信不会重新调起授权框让用户重新授权。处理方案：1.判断用户授权操作，如果拒绝，弹出确认框提示用户“将无法正常使用小程序，建议删除小程序重新进入或者手动授权，是否手动授权？”，用户点击确定，跳到设置界面，手动授权，用户点击取消，跳到取消授权页面（需开发）"}
{"title": "微信小程序实战开发教程-抽屉菜单 ", "author": "天下雪", "pub_time": "2017-1-11 00:49", "content": "作者：crazytea，来自授权地址抽屉菜单是app上常见的菜单设计方式，典型的抽屉菜单如下图所示下面展示如何基于微信小程序实现抽屉菜单,最终效果如下图所示： 页面包含一个主页和抽屉菜单页，为了实现滑动效果，页面采用absolute布局，代码如下 index.wxml<view id='id-main-page' class='main-page' animation='{{animationData}}' style='left:{{mainPageLeft}}rpx;' bindtouchstart='onMainPageTouchstart' catchtouchmove='onMainPageTouchmove' bindtouchend='onMainPageTouchend' bindtap='onMainPageTap'>  <view class=\"userinfo\">    <image class=\"userinfo-avatar\" src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\""}
{"title": "微信小程序问题汇总及详《一》form表单 ", "author": "天下雪", "pub_time": "2017-4-11 00:10", "content": "作者：JoyJin，来自原文地址 附上微信小程序开发文档链接：https://mp.weixin.qq.com/debug/wxadoc/dev/framework/MINA.htmlform表单：当点击 <form/> 表单中 formType 为 submit 的 <button/> 组件时，会将表单组件中的 value 值进行提交，需要在表单组件中加上 name 来作为 key。bindtap 用户点击时触发bindchange 用户输入完成时触发（建议要输入中文的input采用这个点击事件）判断两次密码不一致用 !== 相比较 例如：if(that.data.password !== that.data.password_confirmation){ } <form bindsubmit=\"loginTap\">    <view class=\"section\">      <input placeholder=\"输入手机号\"  maxlength=\"11\" placeholder-style=\"color:#fff\" name=\"phone\" bindtap=\"phone\"/>    //placeholder-style 设置样式     </view>                                                                                           //hover-class=\"none\" 设置按钮按下的样式及状态    <button  hover-class=\"other-button-hover\" form-type=\"submit\" bindtap=\"phoneBtn\"> 登录 </button>  </form>Page({        data: loginData,        loginTap: function (e) {            var that = this    //这句很重要            var loginData = e.detail.value  //获取表单里所有key的值            wx.request({                method: 'POST',                url: 'https://....',   //小程序只能采用https                data: loginData,   //请求的数据                header: {'content-type': 'application/json'},                success: function (res) {                    var tokend = res.data.token;  //获取后台token                    wx.setStorageSync('tokend', tokend)  //存储token                    if (res.code == 200) {                        wx.switchTab({   //跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面,路径后不能带参数（需在 app.json 的 tabBar 字段定义的页面）                            url: '../index/index',                        })                    }if (res.code == 400) {                        wx.showToast({   //消息提示框，默认只能success，loading两种形式，可引进图片方式                            title: '手机号码不正确',                            image: '../Image/error.png',                            duration: 2000                        })                    }                },            })        }    })也可以就单独获取每个input的值Page({        data:{            phone:''        },        phone:function(e){         //获取input值            var that = this;            that.setData({                phone: e.detail.value            })        },       phoneBtn: function (e) {            var that = this;            wx.request({                url: 'https://....',                method: 'GET',                header: { 'content-type': 'application/json' },                data: {                    'phone': that.data.phone   //请求的数据                },                success: function (res) {}            })        },    })"}
{"title": "微信小程序组件系列：form表单讲解 ", "author": "天下雪", "pub_time": "2017-4-5 00:00", "content": "form表单组件说明: 表单，将组件内的用户输入的<switch/> <input/> <checkbox/> <slider/> <radio/> <picker/> 提交。 当点击 <form/> 表单中 formType 为 submit 的<button/> 组件时，会将表单组件中的 value 值进行提交，需要在表单组件中加上 name 来作为 key。form表单组件用法： 重置:<button formType=\"reset\">Reset</button>form表单组件示例代码运行效果如下：提交: <button formType=\"submit\">Submit</button>下面是WXML代码：<view class=\"page\">  <view class=\"page__hd\">    <text class=\"page__title\">表单控件</text>  </view>  <form class=\"page__bd\" catchsubmit=\"formSubmit\" catchreset=\"formReset\">    <view class=\"section\">      <view class=\"section__title\">您的姓名：</view>      <input name=\"name\" placeholder=\"姓名：\" />    </view>    <view class=\"section section_gap\">      <view class=\"section__title\">性别：</view>      <radio-group name=\"gender\">        <label><radio value=\"男\"/>男</label>        <label><radio value=\"女\"/>女</label>        <label><radio value=\"其他\"/>其他</label>      </radio-group>    </view>    <view class=\"section section_gap\">      <view class=\"section__title\">年龄：</view>      <slider value=\"18\" name=\"age\" show-value ></slider>    </view>    <view class=\"section section_gap\">      <view class=\"section__title\">擅长的开发语言：</view>      <checkbox-group name=\"technology\">        <label><checkbox value=\"Java\"/>Java</label>        <label><checkbox value=\"JavaScript\"/>JavaScript</label>        <label><checkbox value=\"C++\"/>C++</label>        <label><checkbox value=\"C\"/>C</label>        <label><checkbox value=\"Object-C\"/>Object-C</label>        <label><checkbox value=\"C#\"/>C#</label>        <label><checkbox value=\"Python\"/>;Python</label>        <label><checkbox value=\"PHP\"/>;PHP</label>        <label><checkbox value=\"Ruby\"/>Ruby</label>        <label><checkbox value=\"Swift\"/>Swift</label>      </checkbox-group>    </view>    <view class=\"section section_gap\">      <view class=\"section__title\">是否公开信息：</view>      <switch name=\"isPublic\"/>    </view>    <view class=\"btn-area\">      <button formType=\"submit\">Submit</button>      <button formType=\"reset\">Reset</button>    </view>    <modal class=\"modal\" hidden=\"{{modalHidden}}\" no-cancel bindconfirm=\"modalChange\">      <view> 您填写的表单如下 </view>      <view> 姓名:{{name}} </view>      <view> 性别：{{gender}} </view>      <view> 年龄：{{age}} </view>      <view> 擅长的开发语言：{{technology}} </view>      <view> 是否公开信息：{{isPublic}} </view>    </modal>  </form></view>下面是JS代码："}
{"title": "小程序新能力：四大功能让小程序更火爆 ", "author": "yuzeng84", "pub_time": "2017-12-27 10:33", "content": "“ 小程序升级实时音视频录制及播放能力，开放 Wi-Fi、NFC(HCE) 等硬件连接功能。同时提供按需加载、自定义组件和更多访问层级等新特性，增强了第三方平台的能力，以满足日趋丰富的业务需求。”01—升级实时音视频录制及播放能力为更高效地连接用户与商家，小程序提供了实时音视频录制及播放组件。符合类目要求的小程序自助开通后，可自建或使用云服务，实现单向、双向甚至多向的音视频功能，如在线授课、远程咨询、视频客服，以及多人会议等。详见《实时音视频录制组件》《实时音视频播放组件》02—开放更多的硬件连接功能为丰富商家的服务场景，小程序开放了更多的硬件连接功能。小程序提供 HCE 模式的 NFC 能力，支持将安卓手机模拟成交通卡、诊疗卡等实体智能卡。用户打开小程序并贴近刷卡机具，即可完成卡的识别、消费等操作。详见《NFC 文档》小程序内支持搜索周边的 Wi-Fi，或在知道密码后连接指定的 Wi-Fi，获得更快的上网体验。详见《Wi-Fi 文档》微信连 Wi-Fi 联网完成页或商家主页，支持打开小程序，获取相关资讯或服务。详见《连 Wi-Fi 小程序文档》03—优化基础特性在承载商家更完善服务的同时，为保证用户快捷获取服务，小程序优化了一批基础特性。开发者可以将小程序代码分成多个包，每个包不超过2M，总大小不超过4M。从而根据用户需要，在合适时机下载指定包而非全部，提升打开速度。详见《分包加载》开发者可编写自定义组件，供自己使用或开源给其他开发者，减少开发工作量。详见《自定义组件》小程序页面访问层级限制放宽至10级，方便承载更长的服务流程。04—增强第三方平台能力第三方平台能力持续增强，新增了一批接口及配置项目。设置 web-view 组件的业务域名。回退小程序版本。查询以及设置小程序最低基础库版本。新增不通过模板直接代第三方提交审核的能力。详见《第三方平台》"}
{"title": "趣店落水、阿里流泪、腾讯小跑，金融新时代来临前的悸动 ", "author": "Rolan", "pub_time": "2017-11-28 00:02", "content": "题图来自：视觉中国房价连年大涨，银行也越来越愿意将贷款发放给地产开发商，可是市场需求却跟不上开发商指数级的欲望，所以楼市风险越来越大。这是近些年的市场困境。国家为了调控房地产行业，四处围堵开发商们的资金来源，银行贷款也被各种限制收紧。这同时也切断了各种实业企业的资金链，于是这些企业的贷款需求就被释放到了民间，民间贷款业务需求跟着水涨船高涨了起来。特别是2015年遭遇A股腰斩、创投基金手里的资金也大幅缩水、创投市场也迎来资本寒冬，资本市场寒冬下中产手中的钱变得无处投资。最终中产市民们手中的钱在市场的引导下，逐渐流进了民间贷款的渠道。供需双方都到齐了，这一市场也就开始暴利横生，迅速长大。网络小贷市场正开往万亿规模，监管形势严峻如果你稍作留心，生活中各种犄角旮旯都充斥着贷款广告。电线杆牛皮癣、马路喷涂、地铁传单、注册送充电宝……甚至手机升个级就能多出来一堆贷款APP。尽管一个贷款APP的推广安装成本一口气顶到100元以上，也丝毫没影响市场的积极性。各家手机厂商也加班加点在手机系统里定制出自家的贷款服务，电话黄页里都能蹦出贷款入口来！2013年，现金贷、网络小额贷、P2P、PPP理财等企业如雨后春笋一般，迅速在全国各地遍地开花。2014年，宜人贷、趣分期、人人贷、好贷网、易贷网、融360等等企业，乘着时代的东风快速发展起来。当年，国家也明确表示对网贷、P2P理财、互联网股权众筹等互联网金融业务持以开放的监管态度，实时监控但不限制其创新。国家开放整个金融市场的决心还是非常坚定。这些开放的举措缓解了各地实体企业创业者的资金需求，缓解了金融市场的压力，一定程度上保证了整个金融体系的安全。整个网贷市场也飞速发展起来，据业内人士透露，目前业内最大的放贷平台——掌众，每天放贷量超百亿元人民币。按这个数据核算下来，整个网贷市场今年涉及的资金量三万亿人民币起，今年上半年国内GDP总量才18万亿。这么大的体量如果持续无监管的发展下去，对市场的影响可想而知——如果有人通过网贷的缺口，在金融市场做手脚，将是巨大危机。网贷不得不面临监管问题。同样的，有钱的地方就有利益熏心。诸多网络小贷平台，与传统的高利贷没有什么本质区别，只不过在运营过程中加入了一个互联网交易平台，挂上“网络小贷”的名号后，敢光明正大的在开设各种门店。但是年利率动辄就超过36%这个法律准线，或者合同上年利率贴着36%走，另外再收取高昂的手续费服务费。随之而来的e租宝、泛亚、PPP诈骗、solomo等各种庞氏骗局传销骗局，浑水摸鱼接踵而来。特别是裸贷、校园贷这些群体性恶性暴力贷款案件的发生，这跟原本设想的“靠市场力量解决中小企业融资贷款难问题”南辕北辙。强监管行动就不得不出马了！金融系统监管全面改革下，阿里最受伤今年 4 月，银监会发布《中国银监会关于银行业风险防控工作的指导意见》。在这份文件中，列了一份详细的现金贷产品名单，其中包括 429 个 App，72 个微信公众号和 117 个网站，要求各地进行重点排查这些网络现金贷的利率和服务费、放贷对象、催收方式、数据来源和放贷资质。也是4月，中纪委也开展了金融反腐。肖建华、吴小晖、张峻、刘益谦等保险业大鳄被控制，保监会原主席项俊波、银监会原主席助理杨家才、中国人民保险集团股份有限公司原总裁王银成也相继落马。今年以来互联网支付平台，也迎来了全新的变革。为了更好的监控金融市场，互联网支付平台不能再与银行直连交易，所有结算只能通过新的网联平台。今年 1 月 23 日，“网联清算有限公司”就已正式出现在国家工商管理系统里，3 月 31 日，中国支付清算协会宣布，非银行支付机构网络支付清算平台（即网联）将正式启动试运行。8月2日，一份《网联清算有限公司设立协议书》流出。《协议书》证实了央行是网联清算有限公司的最大股东。在全部45个股东中，央行下属7家单位共同出资7.6亿持股比例达到37%，其中，第一大股东为央行直属的中国人民银行清算中心，占12%股份，第二大股是国家外汇管理局直属机构东梧桐树投资平台，占10%股份。而支付宝和财付通占股比例都为9.61%，位列第三大股东；京东旗下网银在线以4.71%占比，位列为第四大股东。在刘士余“害人精”“妖精”的论述下，今年金融市场正式开始执行去杠杆化，金融行业的改革也进入政策密集期。在这样的市场背景下，现金贷公司开始预备上市，用上市即上岸来保证公司业务的稳定性。近期在美股纳斯达克上市的趣店、拍拍贷算是“成功上岸”的代表，但随后像趣店这样引发整个市场乃至社会声讨的，也展示着现金贷企业所遇到的末路穷途。毕竟，面向普通消费市场的现金贷业务，本来就存在各种各样不合规的问题。趣店风波之后，网络小贷现金贷的监管就已经提上了日程。北京金融局最先出动，对北京地区的现金贷平台资金来源作出限制，要求各平台只能用自有资金放贷，不再允许与持牌金融机构联合放贷。这种切断方式，直接断绝了现金贷公司的大单业务，大大缩小了现金贷业务规模。企业贷款用户将受到影响。前两天，11 月 21 日，《关于立即暂停批设网络小额贷款公司的通知》被媒体曝光。《通知》要求全国立即暂停批设网络小贷公司。现金贷市场将会何去何从？是否会一夜间变成梦幻泡影？这需要看接下来楼市如何调控。无论趣店们怎么折腾，其实心中最憋屈的要数马云。2003年，在金融市场极为杂乱的时候，阿里推出了支付宝服务以解决国内的信用支付问题。2004年支付宝从淘宝拆分，成为独立的支付平台。此后13年的时间里，阿里打造了各种基础设施连接线上线下银行用户，搭建起了完善的信用系统。现在央行要求所有互联网金融结算都必须经过网联平台，一夜之间，马云十多年的辛苦努力搞出的支付宝，现在跟微信支付、京东钱包、百度钱包等等站到了同一起跑线上。曾经为了分拆支付宝业务，马云不惜得罪投资人孙正义杨致远，阿里在金融上的布局费尽了心思。可惜央妈的一纸政策，改变了整个市场。当然，对比其他家产品、即便是微信支付，支付宝也还是有很多领先优势的。但是跟之前压倒性的垄断优势相比，不值得一提。阿里看了现在的局面，只能默默流泪。先行者阿里，用征信能力确定了自己的行业地位金融业务开展的最大难点是征信系统的搭建，目前互联网领域金融业务做的最成功的两家——阿里、腾讯，一直以来都在通过各种手段构建自己的基础服务，打造出一整套个人征信采集系统。阿里在这方面一直走在最前面。从支付宝开始，与各大银行建立资金池，解决支付信用问题。支付宝能做到今天的地位，要归功于阿里野心够大，从一开始就是要打造全新的互联网金融系统。淘宝支付宝业务逻辑也很明确，目标就是做征信系统。2011年，阿里第一个拿下支付牌照，2015年，阿里的芝麻信用又第一个拿下征信牌照。目前阿里手中持有支付、征信、银行、保险、基金等等牌照。是国内所有民营公司里，金融牌照最全的公司。每次新的金融牌照发放，在互联网领域，毫无疑问都是支付宝第一个拿到牌照。从支付宝的资金池担保交易，到淘宝用户评价系统，当然还有对用户资料的详细收录，整个一套系统都是冲着征信去的。有这些产品数据作保障，才使得支付宝敢在2005年喊出“全额赔付”。加上淘宝免费的商家服务政策，大批的个人用户在体验完淘宝购物后不久，便开通了个人店铺，一时间淘宝店主成为城市流行风潮。可以说当年的淘宝，更像今天的闲鱼，是一个购物社交论坛。在B2C为王的时代，阿里选择做淘宝这样的C2C产品模式，也都是为征信做规划。当时阿里的1688 B2B业务已经为其带来了大量B端客户，表面上看，阿里去做B2C才是最好的选择，也是最适应资本市场的选择。但是B2C是个大坑，当年国内的B端客户对网购还抱以质疑的态度，害怕其过于激进的价格策略打垮了自己辛辛苦苦建立起来的渠道。并且B端公司并不一定会去积极配合运营电商平台，原本市场就质疑电商的信用问题，B端又不积极，很容易就引发信用危机。当年同期的卓越网，直接是到全国各大区域做社区，目标就是服务当地的渠道商，整个卓越网更像是当地渠道商的一个宣传渠道。另一个当当网则是靠着图书品类，切入高素质人群，以货到付款打开市场。阿里选择了C2C模式做淘宝则轻松不少。用户对产品质量不会报以太高的期望，甚至只要对方能发货自己能收到货就已经很心满意足了。这样的情况下商户不必承担维护公司品牌形象的负担，可以以个人卖家的姿态、或者说是“倒爷”的姿态面向用户，释放了人们心中对“黑市”文化的想象力。同时淘宝官方时不时与各地渠道商、供应商合作活动，优势秒杀又是抢购，又是放优惠券、发红包，又是做抽奖小游戏。做足了氛围。当年用户逛淘宝，真实目的其实不是网购，而是做实名社交。逛淘宝更像是一场大型的网络社交活动，支付宝担保交易是这个网络世界的法律，淘宝小二如同法官一样的存在，淘宝店则是真实社会的映射。很长时间内，整个互联网上，只有淘宝上的用户是真实可信的，逛淘宝有一种假面舞会的新奇感。不过讽刺的是，今天的阿里，无论如何也做不好社交产品。是因为现在太有钱了吗？在大批普通用户涌入之后，支付宝也顺利打造了完善的征信体系。所有支付宝用户，都录入了自己的银行卡、身份证、手机号、指纹、声纹、甚至是面部信息等等。有了核心的征信目标做支撑，阿里才会投入更大的成本做，这些投入成本到用户面前就变成了一场场优惠活动。在风控数据丰富之后，优惠活动成本越来越低，用户就能够得到更多优惠福利。可以说，每年阿里的双十一活动，都是一次阿里对自家风控能力的一次炫耀。同样对比另一个大佬——腾讯的电商之路，则可以明显看出，阿里这种征信策略的优势。后知后觉的腾讯，为了征信用尽了心机腾讯很早就做了自己的支付系统，2002年5月腾讯就已经推出了虚拟货币系统Q币，方便用户购买会员、皮肤、游戏服务。2005年，腾讯在支付宝之后，推出了自己的担保交易产品——财付通。可是QQ是一个匿名的社交平台，用户不愿意在QQ上分享自己真实的个人信息。腾讯也一直抱着靠QQ导流变现的思维，只想做一套支付产品方便变现，并没有用心做成一个金融系统。赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              关于微信小程序web-view组件内嵌h5的具体配置流程 \n              等了20天，终于看到“小店小程序”的真面目 \n            \n             \n            \n                  原作者: 水上焱 \n                  来自: 钛媒体 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 聚焦一站式智慧教育，腾讯企业级产品如何玩转智慧校园\n                                    \n                  • 继支付宝之后，微信支付也可以买火车票了\n                                    \n                  • 小程序+电商红利到来，或将颠覆传统电商？\n                                    \n                  • 微信官方悄悄告诉我们，这 3 个新能力即将开放\n                                    \n                  • 开发者不必再为小程序入口纠结，微信如今更操心怎么让开发者赚到钱 ... ...\n                                    \n                  • 事到如今，微信小程序到底是不是风口，心里该有点数了\n                                    \n                  • 小程序是中国剩余6亿流量的钥匙，头部小程序的共性是什么？ ...\n                                    \n                  • 微信怎么诞生的？小程序“葵花码”的未来是啥？财富论坛马化腾亲口揭晓 ...\n                                    \n                  • 我们这一代人的腾讯\n                                    \n                  • 阿里腾讯布局小程序生态，生活服务或成主战场\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cStWBsW9', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐阅读\r\n\r\n\r\n微信小程序开发早知道2019-04-04微信小程序上线“页面收录”功能，真正的SE2019-04-04小程序侵权“生死局”2019-04-04微信小程序搭建mpvue+vant+flyio2019-04-04微信小程序自定义导航栏2019-04-08使用weixin-java-miniapp配置进行单个小程2019-04-04全国首例微信小程序侵权案已判决，腾讯要承2019-04-08微信小程序ad自适应布局2019-04-08从产品角度，看小程序的设计2019-04-09\r\n\r\n便民服务\r\n  \r\n    \r\n      \r\n        加入QQ群\r\n        给我们建议\r\n        立刻投稿\r\n      \r\n    \r\n\t\r\n    \r\n      400-8826-226\r\n      电话服务热线时间：9:00 - 21:00\r\n    \r\n  \r\n关注我们\r\n  \r\n    官方QQ群\r\n  \r\n  \r\n    微信公众号\r\n  \r\n社区新手\r\n\r\n我的好友\r\n我的收藏\r\n我的帖子\r\n\r\n我的任务\r\n\r\n\r\ninitTab(\"tabOfm3Y5\",\"mouseover\");\n     \n       \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880733|f075d09d5f87a64b5224f3c93ffd7141|2';"}
{"title": "微信小程序地区选择器 ", "author": "Rolan", "pub_time": "2017-5-27 14:04", "content": "微信小程序自带了时间选择器、日期选择器，但是没有地区选择器。于是只能撸代码撸了一个出来展现方式有两种方式可以选择：picker 普通选择器方式（分成三个选项）picker-view 滚动选择器方式（三个选项合并成一个）输出数据数据使用form表单进行提交，对各项内容进行了校验，以下条件通过才可提交（不过你可以自己改）各选项值不能为空姓名必须为中文名手机号码格式正确如果所有条件通过，会在console打印表单的数据，然后可以进行之后的操作输出的书话剧可以是中文的地区名称北京，可以是地区编码 110000切换方法：在wxml页面文件中，{{provinceName[provinceSelIndex]}}为地区名称，如果改成{{provinceCode[provinceSelIndex]}}就是地区编号数据存在隐藏的input中（如果直接使用input会唤起键盘）"}
{"title": "微信小程序接入百度统计 ", "author": "Rolan", "pub_time": "2018-9-5 00:28", "content": "一. 百度统计添加应用，获取appkey和微信小程序统计sdk:百度统计首页，点击“我的全部应用”右侧的添加按钮：“应用类型”选择小程序统计，选择微信小程序，填写应用名称信息，选择内容分类，然后点击创建应用：获取到AppKey,下载微信小程序统计SDK，然后就可以在小程序中接入统计了，在这个页面下边就有SDK接入说明了。二. 微信小程序接入：把下载的微信小程序统计SDK解压后的mtj-wx-sdk.js和mtj-wx-sdk.config.js复制到小程序项目的utils文件夹中去：打开mtj-wx-sdk.config.js文件，将上边复制的appkey填写进去：编辑app.js,最顶部添加以下代码：const mtjwxsdk = require('./utils/mtj-wx-sdk.js');登录微信公众平台，进入小程序的设置->开发设置->服务器域名，把https://hmma.baidu.com加入request合法域名：三. 微信开发者工具中刷新项目配置：首次配置百度统计SDK，微信开发工具可能会报以下错误：如果已经在微信公众平台中把https://hmma.baidu.com加入request合法域名，那么就要刷新下开发工具的项目配置，如图,点下工具栏最右侧的“详情”，在详情弹窗界面中点击下“域名信息”，然后开发者工具就会自动刷新配置的，等https://hmma.baidu.com的域名刷新出来，就可以重新编译项目了："}
{"title": "微信小程序之 tabBar 不显示 ", "author": "Rolan", "pub_time": "2017-5-31 00:25", "content": "第一步，按照index创建了myBus第二步：更改app.json，即全局变量重点在于：最后：完成"}
{"title": "微信小程序：开发之前要知道的三件事 ", "author": "Rolan", "pub_time": "2017-10-30 00:31", "content": "前言微信之父张小龙在年初的那次演讲中曾表示：“我自己是很多年的程序员，我觉得我们应该为开发的团队做一些事情”。几个月后，微信正式推出微信应用号（即微信小程序），在互联网中掀起了又一波热潮。 于是，很多人准备要开发微信的小程序，如果你真的想要开发小程序，就要先学会一套微信特制的“开发语言”。为了更好地上手这门开发语言，下面这三件事你一定要知道：语言与文件微信小程序来发与其他平台开发的最大差异在于：微信使用的开发语言和文件很“个性”。 小程序所使用的程序文件类型大致分为以下几种：WXML（WeiXin Mark Language，微信标记语言）WXSS（WeiXin Style Sheet，微信样式表）JS（JavaScript，小游戏的主体）在语言方面，下程序看似重新定义了一套标准。但实际上，他们与“前端三件套”（HTML、CSS和JavaScript）差不太多。来来来，看一下微信小程序开发语言和“前端三件套”的异同点。  界面搭建1、基本逻辑WXML和WXSS两种文件是小程序界面元素声明及样式描述文件。WXML最大的特点是以视图（View）的方式串联界面元素，并通过程序逻辑（AppService）将信息更新实时传递至视图层。View类似于HTML中的div元素，在构建的时候，View可以被多级嵌套，View内可以放置任意视觉元素。需要注意的是，元素一旦超出屏幕之外，用户就无法看到了，这是与HTML哟较大的不同。小程序哟专门用于滚动的视图。如果希望界面是一个可以自由滚动的界面（例如列表等），可以使用scroll-view视图，在WXSS中将其大小调整为整个屏幕，并设置scroll-y（上下滚动）或scroll-x（左右滚动）为true，注意，小程序中不能直接使用DOM控制WXML元素。如果需要进行数据更新，就要使用WXML提供的数据绑定及元素渲染方法，还有一点，小程序的栅格排版系统使用的是Flex布局，它是W3C在2009年提出的一种排版标准。2、绑定数据对于单个字段，开发者可以使用数据绑定的方法进行信息更新。绑定的数据除了在加载的时候可以更新，也可以在JS主程序中以函数形式进行更新，更新同样可以反应到界面上被绑定的数据中。3、条件渲染与列表（循环）渲染条件渲染适用于有意外情况提示的页面（如无法加载列表或详情时，做出提示等等）。它的渲染带有触发条件，即符合条件时渲染这个页面，否则忽略或渲染另一端代码。两个花括号所包含的判断条件中的变量于主程序JS代码中的data中声明。将同一元素渲染代码进行集合。循环的数据可以通过数组的方式写入data中供WXML访问。渲染完毕后，渲染判断条件的变动可以影响界面变动。4、模板与引用WXML支持使用模板与引用减少代码体积。模板是在WXML代码中对相同的代码进行复用的方式。可以将多个模板写入至同一个文件，并使用import在其他文件中进行引用。如果需要整个页面引用，需要使用include。5、样式通过WXSS样式表，开发者可以定义WXML中的元素样式。WXSS与CSS代码一样，可以直接使用选择器选择元素，在WXML中也可以直接定义元素的id和class以便于在WXSS文件中进行样式定义。6、用户操作与事件响应由于微信使用的不是HTML，所以也不能通过添加超链接（a元素）的方式来检测用户的点击事件。对于需要监听点击事件的元素，应该在WXML中使用bindtap属性或catchtap属性进行绑定。除了点击一次，微信也提供按住、开始触摸、松手等事件响应。在WXML中绑定好一个事件之后，就能在主程序中使用。其他的API中也有相应的事件，这些事件乐意在微信小程序的官方文档中查阅到。当需要在小程序的页面间进行跳转时，应该使用wx.navigateTo()方式。 注意，有关于页面层级跳转，微信将层级跳转限制在5层。在开发时一定注意不要超过了相应限制。网络请求方式网络访问小程序支持三种请求方式：HTTP连接、WebSocket、文件收发连接。HTTP连接：请求后直接返回结果，连接结束；Socket连接：持续性连接，当一方主动关闭连接时，连接结束；文件收发连接：顾名思义，发生在文件传输时的连接。（录制的语音和选择的照片都需要这个连接完成）。注意，通过小程序访问网络需要服务器必须支持HTTPS连接，且端口必须为443。同时，小程序只能访问开发者在登记小程序时设定的服务器地址。开发语言和“前端三件套”的异同点HTML与WXML：两者差异比较大，如果之前没有接触过Android开发，可能会觉得有些头疼。事实上，WXML更像是Android开发中的界面XML描述文件，适合于程序界面的构建；而HTML则倾向于文章的展示（这与HTML的历史有关），以及互联网页面的构建。WXSS与CSS：两者在语言上几乎没有差别，可以直接通用。JS文件：小程序的JS文件与前端开发使用的JS几乎没有区别，只是小程序的JS新增了微信的一些API接口，并去除了一些不必要的功能（如DOM）。在有眼上，小程序完全向学习成本最低的前端开发看齐，但这不代表所有开发者都能无缝迁移。如果你是从前端开发转向小程序，就要注意这两点：1、HTML与WXML两种文件的构建思想差异较大，如果之前只接触过前端开发，需要一点时间才能适应WXML的编写方法。2、虽然小程序使用的是前端语言，但不代表可以继续沿用的开发思想进行开发。小程序对前端开发的要求从【构建界面】升级成【开发完整应用】，前端开发需要在意识上进行转变。"}
{"title": "微信小程序开发最佳实践 ", "author": "Rolan", "pub_time": "2018-1-25 00:34", "content": "weapp-starter微信小程序开发最佳实践项目地址为什么会有这个 repo在小程序之初便开发应用了，现在小程序的开发也越来越成熟了，完善了很多的API、组件、架构等，社区也由原来的零星点点到现在的不大不小，但也算是有了，期间也诞生了很多的开发框架，越来越多的三方辅助库，我也捣鼓出很多。比较有名的算是 wepy 和 labrador ， wepy是 vue 风格的小程序开发框架， labrador 则比较亲和 React ，各有千秋，也各有深坑，而labrador 作者目前已经停止更新了 TnT，作为React深度使用者的我来说是忧伤的，于是我捣鼓出 wn-cli 来用类 React 快速开发微信小程序，然而在这个过程中，想了很多，为什么需要开发框架呢？小程序本身在一开始就强调框架，且现在做的也不差，后来总结了下，无非是不熟悉小程序这套框架，但学习新的中间框架去开发小程序，这不是更加加大了熟悉成本吗？且出了问题增加了处理的代价。于是，我重新思考了下，最佳的微信小程序开发实践应该是无痛的，且舒服的，无痛的是指在小程序的飞速发展变更中，我们不用重复的浪费学习第三方框架和原生框架。舒服的是指，我们能用上我们熟悉的流行工程流，如：less 预编译、async/await 异步请求，redux数据管理等。以上，便是这个 repo 的意义与原因。设计概要[x] 优化小程序 APIPromise 化异步接口突破请求数量限制（队列）[x] 使用 async/await[x] 接入 Redux 管理页面数据流直接接入，添加可配置项添加 saga 管理操作[x] 样式书写采用 less 预编译使用 Gulp 管理自动编译，持续集成[x] wxs 管理工具库数据的格式化操作，如时间格式化、金币格式化等[x] 按需加载，子页面分包（除却 tab 页面的其他页面）按功能模块分包加载（推荐）按 tab 分包ps: 小程序 原生分包[x] 资源自动化管理上传 CDNPromise 化异步接口由于微信的API中异步接口都是有三个回调函数的，分别是 success ， fail ， complete，执行时机同字面上意思（ complete 一定会在接口的最后执行）。于是 结合 Promise ，简单的描述如下：（以下为简版，具体的可以看源码）原生微信小程序API：wx.request({\r\n  // ... 其他一些配置项\r\n  success: () => {},\r\n  fail: () => {},\r\n  complete: () => {}\r\n});添加 Promise 后：new Promise((resolve, reject) => {\r\n  wx.request({\r\n    // ... 其他一些配置项\r\n    success: resolve,\r\n    fail: reject,\r\n    complete: resolve, // 这里暂取 resolve 来解决\r\n  });\r\n});Promise 化后，使用起来就简单了：wx.request({ /* ...一些配置项 */}).then(res => {\r\n  console.log(res)\r\n}, err => {\r\n  console.error(err)\r\n})结合下面的 async/await 就可以更加方便的书写同步代码使用 async/await添加 babel :yarn add babel-core安装 env presetsyarn add babel-preset-env使用 .babelrc{\r\n  \"presets\": [\r\n    \"env\"\r\n  ]\r\n}在 Gulp 中使用 babel// install\r\nyarn add gulp-babel\r\n\r\nconst babel = require('gulp-babel');\r\n// ...\r\n.pipe(babel())\r\n// ...添加 runtime ，在使用 async/await 的地方引入 ./src/utils/lib/runtime.js 文件，幸运的是这件事情在这个repo中的 Gulp 任务中自动处理了。以上，便可以在微信小程序中使用 async/await 了。样式书写采用 less 预编译为什么选择 less ，因为简单方便，前端编译，轻量级。注意：由于小程序本身的限制，在书写样式的时候，不要使用 less 的嵌套功能！添加less 变量库等// ...\r\n.pipe(addLessImport({\r\n      themePath: path.join(__dirname, './src/theme/index.less'),\r\n      commomPath: path.join(__dirname, './src/app.less'),\r\n    }))\r\n// ...编译// ...\r\n.pipe(less({\r\n      paths: [path.join(__dirname, './src/theme')]\r\n    }))\r\n// ...重命名样式文件，以便小程序识别// ...\r\n  .pipe(rename((path) => {\r\n    path.extname = '.wxss';\r\n  }))\r\n// ...资源自动化管理目前接入阿里云，监测 assert 文件夹，自动上传图片资源根据配置自动生成 less 配置 config.lessgulp.src('src/theme/config.less', { allowEmpty: true })\r\n    .pipe(file('config.less', `@cdn: ~'${config.cdn}';`))\r\n    .pipe(changed('src/theme'))\r\n    .pipe(gulp.dest('src/theme'))使用page {\r\n  background-image: url('@{cdn}/index-bg.png');\r\n  background-attachment: fixed;\r\n}项目地址"}
{"title": "小程序 - 简单入门 ", "author": "Rolan", "pub_time": "2018-4-18 00:03", "content": "开发小程序的第一步，你需要拥有一个小程序帐号，通过这个帐号你就可以管理你的小程序。点击 https://mp.weixin.qq.com/wxopen/waregister?action=step1 根据指引填写信息和提交相应的资料，就可以拥有自己的小程序帐号。登录 https://mp.weixin.qq.com ，我们可以在菜单 “设置”-“开发设置” 看到小程序的 AppID 了 。小程序的 AppID 相当于小程序平台的一个身份证，后续你会在很多地方要用到 AppID (注意这里要区别于服务号或订阅号的 AppID)。有了小程序帐号之后，我们需要一个工具来开发小程序。安装开发工具前往开发者工具下载页面 ，根据自己的操作系统下载对应的安装包进行安装，有关开发者工具更详细的介绍可以查看《开发者工具介绍》 。打开小程序开发者工具，用微信扫码登录开发者工具，准备开发你的第一个小程序吧！第一个小程序新建项目选择小程序项目，选择代码存放的硬盘路径，填入刚刚申请到的小程序的 AppID，给你的项目起一个好听的名字，最后，勾选 \"创建 QuickStart 项目\" (注意: 你要选择一个空的目录才会有这个选项)，点击确定，你就得到了你的第一个小程序了，点击顶部菜单编译就可以在 IDE 预览你的第一个小程序。编译预览修改小程序必须要先编译才能看到修改后的效果。点击工具上的编译按钮，可以在工具的左侧模拟器界面看到这个小程序的表现，也可以点击预览按钮，通过微信的扫一扫在手机上体验你的第一个小程序。代码构成在上一章中，我们通过开发者工具快速创建了一个 QuickStart 项目。你可以留意到这个项目里边生成了不同类型的文件:.json 后缀的 JSON 配置文件 .wxml 后缀的 WXML 模板文件 .wxss 后缀的 WXSS 样式文件 .js 后缀的 JS 脚本逻辑文件 接下来我们分别看看这4种文件的作用。JSON配置我们可以看到在项目的根目录有一个 app.json 和 project.config.json，此外在 pages/logs 目录下还有一个 logs.json，我们依次来说明一下他们的用途。工具配置 project.config.json通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 project.config.json，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。小程序配置 app.jsonapp.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。QuickStart 项目里边的 app.json 配置内容如下：简单说一下这个配置各个项的含义:pages字段 —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。window字段 —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的。其他配置项细节可以参考文档 小程序的配置 app.json 。页面配置 page.json这里的 page.json 其实用来表示 pages/logs 目录下的 logs.json 这类和小程序页面相关的配置。如果你整个小程序的风格是蓝色调，那么你可以在 app.json 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 page.json，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等。 其他配置项细节可以参考文档 小程序的配置 page.json。WXML 模板HTML 是用来描述当前这个页面的结构，WXML 的作用和HTML一样，只不过是里面的元素标签是用小程序自己封装的标签名。打开 pages/index/index.wxml，你会看到以下的内容:虽然WXML 和 HTML 非常相似，有标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：标签名字有点不一样 往往写 HTML 的时候，经常会用到的标签是 div, p, span，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。 从上边的例子可以看到，小程序的 WXML 用的标签是 view, button, text 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力 更多详细的组件讲述参考下个章节小程序的能力多了一些 wx:if 这样的属性以及 {{ }} 这样的表达式 在网页的一般开发流程中，我们通常会通过 JS 操作 DOM (对应 HTML 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，JS 会记录一些状态到 JS 变量里边，同时通过 DOM API 操控 DOM 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式(例如 React, Vue)，提倡把渲染和逻辑分离。简单来说就是不要再让 JS 直接操控 DOM，JS只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。 小程序的框架也是用到了这个思路，如果你需要把一个 Hello World 的字符串显示在界面上。 WXML 是这么写 :<text>{{msg}}</text>JS 只需要管理状态即可:this.setData({ msg: \"Hello World\" })通过 {{ }} 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 if/else, for等控制能力，在小程序里边，这些控制能力都用 wx: 开头的属性来表达。 更详细的文档可以参考WXMLWXSS 样式WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。新增了尺寸单位。在写 CSS 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。WXSS 在底层支持新的尺寸单位 rpx ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。提供了全局的样式和局部样式。和前边 app.json, page.json 的概念相同，你可以写一个 app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效。此外 WXSS 仅支持部分 CSS 选择器更详细的文档可以参考WXSS 。JS 交互逻辑一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。<view>{{ msg }}</view>\r\n<button bindtap=\"clickMe\">点击我</button>点击 button 按钮的时候，我们希望把界面上 msg 显示成 \"Hello World\"，于是我们在 button 上声明一个属性: bindtap ，在 JS 文件里边声明了 clickMe 方法来响应这次点击操作：Page({\r\n  clickMe: function() {\r\n    this.setData({ msg: \"Hello World\" })\r\n  }\r\n})响应用户的操作就是这么简单，更详细的事件可以参考文档WXML - 事件 。 此外你还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 QuickStart 例子中，在 pages/index/index.js 就调用了 wx.getUserInfo 获取微信用户的头像和昵称，最后通过 setData 把获取到的信息显示到界面上。更多 API 可以参考文档小程序的API 。地图demo如果要在当前的小程序中新增一个地图页面，需要再app.json中增加配置，然后，在pages文件夹下新增 map文件夹以及map.js、map.json、map.wxml、map.wxss：小程序提供了很多组件，我们仅仅需要在map.wxml 使用map组件，并设置相应的属性名即可：map元素上绑定了两个变量longitude、latitude，需要再map.js对其进行赋值：图中在onReady生命周期中利用 小程序api - wx.getLocation获取到当前的经度、纬度，获取到之后 利用setData方法对longitude、latitude进行初始化。最后地图页面效果："}
{"title": "微信小程序（创建页面、设置页面标题） ", "author": "Rolan", "pub_time": "2017-11-3 00:08", "content": "好了 hello world 创建好了 ，咱开始写页面了，那么如何创建一个简单的页面呢，废话不多说，开始撸代码 新建一个页面需要以下几步：1. 在pages 中添加一个目录（当然如果你觉得写在现有的目录里面就好 那这一步就省略啦）点击左侧的 编辑  -->  点中 pages 文件夹  -->   点击右上角的  +  号  --> 在下拉菜单中选择 目录  --> 弹出框中 填写目录 名称 （这里我们写了test）--> 点击 确定2. 新建一个wxml 文件选中 test  文件夹 --> 点击 右上角  + 号  --->  选择  wxml 类型 文件  --> 填入文件名  （注意 这里必须填写 后缀名 至少 我的版本是必须填入的）3. 编辑test.wxml 文件为了方便测试 我们随便 填写点内容进去4. 创建test.js文件使用同样的方法在test 目录下创建一个 test.js 文件5. 将test 页面加入 app.json在pages 属性中 加入一条 test 页面所在的目录 这里是相对路径 首部不必填写 /6. 在首页加入访问链接好了 上面路径也加好了 我们得加个入口 才能看到自己写的页面啊 ， 小程序的首页一般是默认显示 pages 属性中的第一条路径所指向的页面  ，如果我们不想破坏原有的 那么 我们直接找到首页  pages/index/index.wxml  添加一个链接7. 访问一且准备就绪 ，点击左下角的 “编译”，出现如下 页面  然后 点击 “”跳转test页面“” 哇哈哈，看到了没，你的页面做好了！！！（注意所有页面编辑后 请按 ctrl + s 保存键）设置页面标题页面写好了，总感觉哪里不爽，对，就是那，每个页面的标题都一样，都是 Wechatcou 呀 真cou, 那咱就单独说说，如何设置 页面标题。找到所在页面的目录，新建一个 json 文件，比如我们上一次建造的 test 页面我们  找到 pages/test/ 目录 新建一个 test.json 文件 加入如下代码 效果如下：是不是很霸气，这节就写这么多，下节更精彩！"}
{"title": "微信小程序如何裁剪图片作为转发封面 ", "author": "Rolan", "pub_time": "2018-8-20 00:39", "content": "我们知道微信小程序的转发时的封面图片比例固定为5:4，具体内容详见小程序开发文档：但是，在实际开发时我们有时需要将某张动态请求的网络图片作为转发封面图（比如文章封面），而这张图片又往往不符合 5:4 的比例要求。这时，如果我们直接将这张图片作为封面图其实也是可以的，只不过将长宽比大于 5:4 作为转发封面时，封面下可能会留有部分空白。我们可以直接以简书为例，简书目前分享文章到微信时是以小程序的方式分享，而其分享封面也正是取自该文章的封面，所以，如果我们从小程序中转发可能会看到类似下图的转发封面图：可以看到，封面图下面存在大块空白，如果图片长宽比例更大，那么下面的空白也将更大。因此，为了更加美观，我们必须将图片按照 5:4 比例进行适当地裁剪，而我写本文的目的也正是如此。1. 创建Canvas画布前端要裁剪图片，我们首先就要想到用Canvas，写H5如此，微信小程序当然也是如此。<canvas style=\"position: absolute; top: -1000px; left: -1000px; width: 640px; height: 640px; background: #000\" canvas-id=\"canvas\"></canvas>我们要用到的canvas当然不能直接在页面中显示，所以可以使用负定位值的方式将其隐藏。2. 下载网络图片我们可以使用wx.downloadFile()来下载网络图片，也可以使用wx.getImageInfo()，因为我们这里需要获取到图片的宽高，所以这里就要用到wx.getImageInfo()来进行图片的下载。wx.getImageInfo({      src: \"\",  // 这里填写网络图片路径       success: (res) => {        // 这个是我封装的裁剪图片方法（下面将会说到）        clipImage(res.path, res.width, res.height, (img) => {          console.log(img);  // img为最终裁剪后生成的图片路径，我们可以用来做为转发封面图        });       }});3. 裁剪图片并导出以下是我封装的专门用于裁剪图片比例大于 5:4 的图片，裁剪方式是截取图片中间部分（当然你也可以试着写下裁剪小于 5:4 的图片）：/* 裁剪封面，   src为本地图片路径或临时文件路径，   imgW为原图宽度，   imgH为原图高度，   cb为裁剪成功后的回调函数*/const clipImage = (src, imgW, imgH, cb) => {    // ‘canvas’为前面创建的canvas标签的canvas-id属性值  let ctx = wx.createCanvasContext('canvas');    let canvasW = 640, canvasH = imgH;  if (imgW / imgH > 5 / 4) { // 长宽比大于5:4    canvasW = imgH * 5 / 4;  }  // 将图片绘制到画布  ctx.drawImage(src, (imgW - canvasW) / 2, 0, canvasW, canvasH, 0, 0, canvasW, canvasH) // draw()必须要用到，并且需要在绘制成功后导出图片 ctx.draw(false, () => {    setTimeout(() => {      //  导出图片      wx.canvasToTempFilePath({        width: canvasW,        height: canvasH,        destWidth: canvasW,        destHeight: canvasH,        canvasId: 'canvas',        fileType: 'jpg',        success: (res) => {          // res.tempFilePath为导出的图片路径          typeof cb == 'function' && cb(res.tempFilePath);        }      })    }, 1000);  })}本文重点总结① 使用Canvas画布进行图片裁剪② 裁剪网络图片前，必须使用wx.getImageInfo()下载图片并同时获取图片的宽高作者：前端王睿 链接：https://www.jianshu.com/p/12fdfb152906"}
{"title": "微信小程序input表单页面实例,redio和下拉列表获取数据 ", "author": "Rolan", "pub_time": "2017-9-12 00:00", "content": "一个简单的预约类型的表单，效果 主要代码：    <form bindsubmit=\"bindSave\">\r\n      <view class=\"form-box\">\r\n        <view class=\"row-wrap\">\r\n          <view class=\"label\">联系人</view>\r\n          <view class=\"label-right\">\r\n            <input name=\"userName\" class=\"input\" type=\"text\" placeholder=\"姓名\" value=\"{{addressData.userName}}\" />\r\n          </view>\r\n        </view>\r\n\r\n        <view class=\"row-wrap\">\r\n          <view class=\"label\">性别</view>\r\n          <radio-group class=\"radio-group\" bindchange=\"radioChange\">\r\n            <label class=\"radio\" wx:for=\"{{items}}\">\r\n              <radio value=\"{{item.name}}\" checked=\"{{item.checked}}\" />{{item.value}}\r\n            </label>\r\n          </radio-group>\r\n\r\n        </view>\r\n        <view class=\"row-wrap\">\r\n          <view class=\"label\">手机号码</view>\r\n          <view class=\"label-right\">\r\n            <input name=\"mobile\" class=\"input\" maxlength=\"11\" type=\"number\" placeholder=\"11位手机号码\" value=\"{{addressData.mobile}}\" />\r\n          </view>\r\n        </view>\r\n\r\n        <view class=\"row-wrap\">\r\n          <view class=\"label\">预约项目</view>\r\n          <picker bindchange=\"bindCasPickerChange\" value=\"{{casIndex1}}\" range=\"{{casArray}}\">\r\n            <view>\r\n              <text>{{casArray[casIndex]}}</text>\r\n            </view>\r\n          </picker>\r\n\r\n\r\n        </view>\r\n\r\n      </view>\r\n\r\n      <view class=\"btn-tyc\">\r\n\r\n        <button size=\"mini\" bindtap=\"tapAddCart\" class=\"submit\" type=\"primary\" formType=\"submit\">提交预约</button>\r\n      </view>\r\n\r\n      <button size=\"mini\" bindtap=\"tlp_phone\" class=\"phone\" type=\"primary\">拨打电话</button>\r\n    </form>\r\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546.js文件  data: {\r\n    nickName: \"\",\r\n    avatarUrl: \"\",\r\n    casArray: ['双眼皮', 'TBM', '隆胸', '减肥', 'qita'],\r\n    userName: '',\r\n    mobile: '',\r\n    Gender: 'female',\r\n    casIndex: 0,\r\n    items: [\r\n      { name: 'male', value: '男' },\r\n      { name: 'female', value: '女', checked: 'true' },\r\n    ]\r\n  },\r\n  radioChange: function (e) {\r\n    console.log('值：', e.detail.value)\r\n    this.setData({\r\n      Gender: e.detail.value\r\n    })\r\n  },\r\n  /**\r\n   * 生命周期函数--监听页面加载\r\n   */\r\n  bindCasPickerChange: function (e) {\r\n    console.log(this.data.casArray);\r\n    console.log('下拉选择的是', this.data.casArray[e.detail.value])\r\n    this.setData({\r\n      casIndex: e.detail.value\r\n    })\r\n  },1234567891011121314151617181920212223242526272829具体的表单样式可以自己调整，wxss样式文件代码不写了参照官方文档form组件https://mp.weixin.qq.com/debug/wxadoc/dev/component/form.html1"}
{"title": "小程序之canvas图片及文本适配 ", "author": "Rolan", "pub_time": "2018-9-3 00:32", "content": "场景需求小程序目前不支持直接分享到朋友圈，所以对于有分享到朋友圈的需求，一般是生成一张图片，例如，生成一张带有小程序码的图片，用户可以将这张图片保存到手机本地，然后将这张图片分享到朋友圈。这张图片需要使用canvas画出来。今天我们不讲怎么生成码，这个一般是后端封装一个API，前端通过调用API得到一个小程序码的url，通过image去画到canvas上，跟在canvas上画一个image是一样的逻辑。这篇文章主要是讲怎么在canvas上适配图片和文字，也就是怎么将图片和文本画到canvas上的正确的位置，能在不同的手机上都能正确的展示。效果图展示（以下图片是在微信开发者工具中显示的） 这里演示的Demo是： “选择图片”button选择一张图片，可以居中显示在以下图中的黄色区域，即canvas中，并在canvas的顶部居中展示文本“你若盛开，蝴蝶自来”。以下是两个不同尺寸的图片画在canvas上，分别在iphone5、iphone6、iphone6 plus上的展示效果图。这里的猫图片的原始尺寸：658*658这里的girl图片的原始尺寸是：700*699代码说明小程序尺寸单位小程序尺寸单位2. wxml<button bindtap=\"chooseImg\">选择图片</button><view class=\"canvas-box\">    <canvas class=\"canvas\" canvas-id=\"shareCanvas\" bindlongtap=\"saveShareImage\"></canvas></view>$3. scss（wxss） 这里我用的是scss去写样式代码，在webStorm中可以通过配置，将scss解析成wxss，至于具体怎么配置，可以自行百度。 PS1：这里定义了一个scss rpx function，是因为在webStrom中格式化代码的时候会将数字和单位rpx中间添加一个空格，导致编译报错，所以用一个function去处理 PS2：样式说明（设计稿是基于iphone6视觉稿标准）： button宽高：700rpx * 92rpx (350px * 46px) 包裹canvas的容器的view（.canvas-box）position:fixed,占据除顶部button的高度之外，填满剩余全部空间，canvas居中显示，宽高：700rpx， 100%@function rpx($value) {  @return $value*1rpx;}page {  background-color: #fff6f6;  button {    width: rpx(700);    height: rpx(92);    background-color: #ffddab !important;  }  .canvas-box {    position: fixed;    top: rpx(92);    left: 0;    right: 0;    bottom: 0;    canvas {      position: absolute;      width: rpx(700);      height: 100%;      top: 50%;      left: 50%;      transform: translate(-50%, -50%);    }  }}$4. js 1、在data中定义三个变量data: {        windowWidth: 0, // 可使用窗口宽度        windowHeight: 0, // 可使用窗口高度        ratio: 0 // 根据尺寸动态计算 1px换算成多少rpx    }2、通过wx.getSystemInfo获得系统信息，并且计算ratio    onReady: function (e) {        // 获取系统信息        wx.getSystemInfo({            success: res => {                console.log(res);                this.setData({                    windowWidth: res.windowWidth,                    windowHeight: res.windowHeight,                });                this.setData({                    // 屏幕宽度 375px = 750rpx，1px=2rpx                    // 1px = （750 / 屏幕宽度）rpx；                    // 1rpx = （屏幕宽度 / 750）px;                    ratio: 750 / this.data.windowWidth                });            }        });    },3、button的触发事件chooseImg，通过wx.chooseImage选择图片，通过wx.getImageInfo获取选择的图片的大小chooseImg: function () {        wx.chooseImage({            count: 1,            success: res => {                let imgUrl = res.tempFilePaths[0];                // 获取图片大小                wx.getImageInfo({                    src: imgUrl,                    success: data => {                        let imgWidth = data.width;                        let imgHeight = data.height;                        // 创建canvas，根据选择的图片大小，在canvas上绘制图片和文字                        this.createCanvasShareImage(imgUrl, imgWidth, imgHeight);                    }                });            }        });    }4、创建canvas并在canvas上添加图片和文本 createCanvasShareImage: function (imgUrl, imgW, imgH) {        // 使用wx.createCanvasContext获取绘图上下文 context        let context = wx.createCanvasContext('shareCanvas');        console.log('context: ', context);        // 获取canvas的宽度：        // 750的设计稿基于iphone6的尺寸（屏幕宽度： 375px）在小程序中的比例是： 1px = 2rpx ==> 375px = 750rpx ==> 屏幕宽度(px) = 750rpx        // 所以 1rpx = 屏幕宽度 / 750        // 我们这里css中设置的 canvas 的width：700rpx, 所以 canvas的宽度计算是： [（屏幕宽度 / 750）* 700]rpx， 这样就可以做到在不同手机上都可以适配        let canvasWidthPx = 700 / this.data.ratio;        // 设置 canvas 的背景并填充canvas        context.fillStyle = '#ffdc22';        context.fillRect(0, 0, canvasWidthPx, this.data.windowHeight);        // 绘制图片：图片居中显示在 canvas 中        let imgX = (700 - imgW) / 2;        let imgY = (this.data.windowHeight * this.data.ratio - 46 * this.data.ratio - imgH) / 2;        let clipWidth = imgW * this.data.ratio;        let clipHeight = imgH * this.data.ratio;        context.drawImage(imgUrl, -imgX, -imgY, clipWidth, clipHeight, 0, 0, imgW, imgH);        // 设置字体大小、文本颜色        context.setFontSize(20);        context.fillStyle = \"#000\";        // 计算文本的宽度：measureText() 取到文本的 width        let txtWidth = context.measureText('你若盛开，蝴蝶自来').width;        // 绘制居中文本：这个地方的 (x, y)的坐标是在文本的左下角位置        context.fillText(\"你若盛开，蝴蝶自来\", (canvasWidthPx - txtWidth) / 2, 20 * this.data.ratio);        context.draw();    }5、长按bindlongtapcanva保存图片或者直接预览图片，先通过wx.canvasToTempFilePath将当前画布指定区域的内容导出生成指定大小的的图片，再通过wx.saveImageToPhotosAlbum将图片保存到本地，或者通过wx.previewImage直接预览图片。    saveShareImage() {        wx.canvasToTempFilePath({            canvasId: 'shareCanvas',            success: (res) => {                console.log('canvasToTempFilePath： ', res);                // 将图片保存到相册                wx.saveImageToPhotosAlbum({                    filePath: res.tempFilePath,                    success: (data) => {                        console.log(data);                    }                });                // 直接预览图片                wx.previewImage({                    urls: [res.tempFilePath]                })            }        })    }真机效果图显示（一加六手机） 一加6手机显示的小程序效果图.png保存到手机本地的图片.png作者：豆豆的故事 链接：https://www.jianshu.com/p/75fa54f6caa8"}
{"title": "轻松生成小程序分享海报 ", "author": "Rolan", "pub_time": "2018-8-29 00:15", "content": "作者：jasondu原文：https://segmentfault.com/a/1190000016121303小程序海报组件https://github.com/jasondu/wx...需求小程序分享到朋友圈只能使用小程序码海报来实现，生成小程序码的方式有两种，一种是使用后端方式，一种是使用小程序自带的canvas生成；后端的方式开发难度大，由于生成图片耗用内存比较大对服务端也是不小的压力；所以使用小程序的canvas是一个不错的选择，但由于canvas水比较深，坑比较多，还有不同海报需要重现写渲染流程，导致代码冗余难以维护，加上不同设备版本的情况不一样，因此小程序海报生成组件的需求十分迫切。在实际开发中，我发现海报中的元素无非一下几种，只要实现这几种，就可以通过一份配置文件生成各种各样的海报了。海报中的元素分类要解决的问题单位问题canvas隐藏问题圆角矩形、圆角图片多段文字超长文字和多行文字缩略问题矩形包含文字多个元素间的层级问题图片尺寸和渲染尺寸不一致问题canvas转图片IOS 6.6.7 clip问题关于获取canvas实例单位问题canvas绘制使用的是px单位，但不同设备的px是需要换算的，所以在组件中统一使用rpx单位，这里就涉及到单位怎么换算问题。通过wx.getSystemInfoSync获取设备屏幕尺寸，从而得到比例，进而做转换，代码如下：const sysInfo = wx.getSystemInfoSync();\r\nconst screenWidth = sysInfo.screenWidth;\r\nthis.factor = screenWidth / 750;    // 获取比例\r\nfunction toPx(rpx) {    // rpx转px\r\n    return rpx * this.factor;\r\n}\r\nfunction toRpx(px) {    // px转rpx\r\n    return px / this.factor;\r\n},canvas隐藏问题在绘制海报过程时，我们不想让用户看到canvas，所以我们必须把canvas隐藏起来，一开始想到的是使用display:none; 但这样在转化成图片时会空白，所以这个是行不通的，所以只能控制canvas的绝对定位，将其移出可视界面，代码如下：.canvas.pro {\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: -9999rpx;\r\n}圆角矩形、圆角图片由于canvas没有提供现成的圆角api，所以我们只能手工画啦，实际上圆角矩形就是由4条线（黄色）和4个圆弧（红色）组成的，如下：圆弧可以使用canvasContext.arcTo这个api实现，这个api的入参由两个控制点一个半径组成，对应上图的示例canvasContext.arcTo(x1, y1, x2, y2, r)接下来我们就可以非常轻松的写出生成圆角矩形的函数啦/**\r\n * 画圆角矩形\r\n */\r\n_drawRadiusRect(x, y, w, h, r) {\r\n    const br = r / 2;\r\n    this.ctx.beginPath();\r\n    this.ctx.moveTo(this.toPx(x + br), this.toPx(y));            // 移动到左上角的点\r\n    this.ctx.lineTo(this.toPx(x + w - br), this.toPx(y));        // 画上边的线\r\n    this.ctx.arcTo(this.toPx(x + w), this.toPx(y), this.toPx(x + w), this.toPx(y + br), this.toPx(br));                                                    // 画右上角的弧        \r\n    this.ctx.lineTo(this.toPx(x + w), this.toPx(y + h - br));    // 画右边的线\r\n    this.ctx.arcTo(this.toPx(x + w), this.toPx(y + h), this.toPx(x + w - br), this.toPx(y + h), this.toPx(br));                                              // 画右下角的弧\r\n    this.ctx.lineTo(this.toPx(x + br), this.toPx(y + h));        // 画下边的线\r\n    this.ctx.arcTo(this.toPx(x), this.toPx(y + h), this.toPx(x), this.toPx(y + h - br), this.toPx(br));                                                    // 画左下角的弧\r\n    this.ctx.lineTo(this.toPx(x), this.toPx(y + br));            // 画左边的线\r\n    this.ctx.arcTo(this.toPx(x), this.toPx(y), this.toPx(x + br), this.toPx(y), this.toPx(br));                                                    // 画左上角的弧\r\n}如果是 画线框 就使用 this.ctx.stroke();如果是 画色块 就使用 this.ctx.fill();如果是 圆角图片 就使用this.ctx.clip();\r\nthis.ctx.drawImage(***);clip() 方法从原始画布中剪切任意形状和尺寸。一旦剪切了某个区域，则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。可以在使用 clip() 方法前通过使用 save() 方法对当前画布区域进行保存，并在以后的任意时间对其进行恢复（通过 restore() 方法）。多段文字如果是连续多段不同格式的文字，如果让用户每段文字都指定坐标是不现实的，因为上一段文字的长度是不固定的，这里的解决方案是使用 ctx.measureText （基础库 1.9.90 开始支持）Api来计算一段文字的宽度，记住这里返回宽度的单位是px（ 坑 ），从而知道下一段文字的坐标。超长文字和多行文字缩略问题设置文字的宽度，通过 ctx.measureText 知道文字的宽度，如果超出设定的宽度，超出部分使用“...”代替；对于多行文字，经测试发现字体的高度大约等于字体大小，并提供lineHeight参数让用户可以自定义行高，这样我们就可以知道下一行的y轴坐标了。矩形包含文字这个同样使用 ctx.measureText 接口，从而控制矩形的宽度，当然这里用户还可以设置paddingLeft和paddingRight字段；文字的垂直居中问题可以设置文字的基线对齐方式为middle（ this.ctx.setTextBaseline('middle'); ），设置文字的坐标为矩形的中线就可以了；水平居中 this.ctx.setTextAlign('center'); ;多个元素间的层级问题由于canvas没有Api可以设置绘制元素的层级，只能是根据后绘制层级高于前面绘制的方式，所以需要用户传入zIndex字段，利用数组排序（Array.prototype.sort）后再根据顺序绘制。图片尺寸和渲染尺寸不一致问题绘制图片我们使用 ctx.drawImage() API；如果使用 drawImage(dx, dy, dWidth, dHeight) ，图片会压缩尺寸以适应绘制的尺寸，图片会变形，如下图：在基础库1.9.0起支持 drawImage(sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)  ，sx和sy是源图像的矩形选择框左上角的坐标，sWidth和sHeight是源图像的矩形选择框的宽度和高度，如下图：如果绘制尺寸比源图尺寸宽，那么绘制尺寸的宽度就等于源图宽度；反之，绘制尺寸比源图尺寸高，那么绘制尺寸的高度等于源图高度；我们可以通过 wx.getImageInfo Api获取源图的尺寸；canvas转图片在canvas绘制完成后调用 wx.canvasToTempFilePath Api将canvas转为图片输出，这样需要注意， wx.canvasToTempFilePath 需要写在 this.ctx.draw 的回调中，并且在组件中使用这个接口需要在第二个入参传入this（ 坑 ），如下this.ctx.draw(false, () => {\r\n    wx.canvasToTempFilePath({\r\n        canvasId: 'canvasid',\r\n        success: (res) => {\r\n            wx.hideLoading();\r\n            this.triggerEvent('success', res.tempFilePath);\r\n        },\r\n        fail: (err) => {\r\n            wx.hideLoading();\r\n            this.triggerEvent('fail', err);\r\n        }\r\n    }, this);\r\n});IOS 6.6.7 clip问题在IOS 6.6.7版本中clip方法连续裁剪图片时,只有第一张有效，这是微信的bug，官方也证实了（ https://developers.weixin.qq.... ）关于获取canvas实例我们可以使用 wx.createCanvasContext 获取小程序实例，但在组件中使用切记第二个参数需要带上this，如下this.ctx = wx.createCanvasContext('canvasid', this);如何使用组件https://github.com/jasondu/wx..."}
{"title": "黄秀杰--Node后端优雅使用Bmob ", "author": "Rolan", "pub_time": "2017-11-27 00:24", "content": "数据库CRUD使用JS SDK对于增删改查、连表操作，直接使用浏览器JS SDK，在bmob.js，https://www.bmob.cn/static/bmob_jssdk_quickstart.zip，仅需加一个module.exports = Bmob导出，就可以在Node使用了，语法与小程序里写法一样优雅，比Bmob提供的npm包要好用N倍。JS SDK的使用xmlhttprequest作ajax请求，所以node下，还要依赖xmlhttprequest npm包，将\"xmlhttprequest\": \"^1.8.0\"添加到package.json dependencies里，同样再加上\"localStorage\": \"^1.0.3\"。这样就改造完成了。代码说话，看对比以下是Bmob npm库var BC = require('bmob');BC.initialize(\"9a22a7cb3217e88cac2e81fe7e88c600\", \"025c1282712e387a62b2bcd5a970f93c\");var db = new BC.Db;db.find({  \"table\":\"XXX\",          //表名  \"keys\":\"a,b,c\",         //返回字段列表，多个字段用,分隔  \"where\":{\"a\":\"XXXX\",\"b\":\"XXXX\"},       //查询条件是一个JSON object  //\"where\":{\"c\":{\"$ne\":1}},       //条件查询 查询c字段值不为1的记录  \"order\":\"-a,b\",         //排序列表，[-]字段名称,-表示降序，默认为升序  \"limit\":10,            //limit大小，一页返回多少条记录，默认为0  \"skip\":2,             //skip,分页offset，(page-1)*limit  \"count\":1            //count,只返回符合条件的记录总数 },function(err,data){    //回调函数 });注：对于表关联include操作，一直没有发现怎么处理，这是一个硬伤，npm库也2年多没有维护了。以下是改造过的浏览器JS SDK//app.jsvar Bmob = require('./bmob.js');Bmob.initialize(\"9a22a7cb3217e88cac2e81fe7e88c600\", \"025c1282712e387a62b2bcd5a970f93c\");// bmobvar Food = Bmob.Object.extend(\"Food\");var query = new Bmob.Query(Food);query.include('category');query.limit(this.pageSize);query.skip(this.pageIndex * this.pageSize);query.find({    success: function(object) {        console.log(object);    },    error: function(object, error) {        alert(\"query object fail\");    }});使用connect-multiparty+request.js+RESTFul上传附件经过上面的改造，可以操作数据库，但对于附件上传，还是要自己再增强'use strict';var router = require('express').Router();var multipart = require('connect-multiparty');var multipartMiddleware = multipart();var path = require('path');var fs = require('fs');var Bmob = require('../util/bmob.js');var {appId, appSecret} = require('../util/config');// 添加分类router.post('/upload', multipartMiddleware, function(req, res) {    console.log('uploading');    // 临时文件完整路径    var file_url = req.files.file.path;    // 截取文件名    var filename = path.basename(file_url);    console.log(filename)    /* request 上传 */    var request = require('request');    request.post({        headers: {            \"X-Bmob-Application-Id\": appId,            \"X-Bmob-REST-API-Key\": appSecret        },        url: 'https://api.bmob.cn/2/files/' + filename,        body: fs.readFileSync(file_url)    }, function optionalCallback(err, httpResponse, body) {        if (err) {            return console.error('upload failed:', err);        }        res.send(body);    });});module.exports = router;这里要注意，不能像传统自己服务端那样使用formData的方式上传，而是直接给body值——感谢Bmob的magic大大指点，才从坑里出来。//formData: var formData = {//     file: fs.createReadStream(file_url),//}//或者//formData: var formData = {//     file: fs.readFileSync(file_url),//}经过以上2大改造，就可以在Node中优雅得使用Bmob了，我的灵犀外卖后端就是基于这个做出的。源码：https://git.oschina.net/laeser/dinner-web"}
{"title": "微信小程序客服消息模块 ", "author": "Rolan", "pub_time": "2018-1-29 00:27", "content": "weapp-kefu微信小程序客服消息模块,基于驱动开发，可以有效解决群发消息的问题，单个类型的消息独立不干扰发送文字消息$type = 'text'; // 可选参数，text,link,image,miniprogrampage\r\n$kefu = new \\Com\\Kefu($type,$token); //群发消息一般都是群发一种类型的消息的，所以将type加载到构造中\r\n$data = array(\r\n    'touser'=>'xxxxx',\r\n    'text'=>'您好'\r\n)\r\n$kefu->set($data);\r\n$kefu->run();\r\n发送图片消息$type = 'image'; // 可选参数，text,link,image,miniprogrampage\r\n$kefu = new \\Com\\Kefu($type,$token); //群发消息一般都是群发一种类型的消息的，所以将type加载到构造中\r\n$data = array(\r\n    'touser'=>'xxxxx',\r\n    'media_id'=>'media_id'\r\n)\r\n$kefu->set($data);\r\n$kefu->run();\r\n发送图文消息$type = 'link'; // 可选参数，text,link,image,miniprogrampage\r\n$kefu = new \\Com\\Kefu($type,$token); //群发消息一般都是群发一种类型的消息的，所以将type加载到构造中\r\n$data = array(\r\n    'touser'=>'xxxxx',\r\n    'title'=>'你好',\r\n    'description'=>'今天的天气不错',\r\n    'url'=>'https://wwww.xxx.xxx',\r\n    'thumb_url'=>'thumb_image_url'\r\n)\r\n$kefu->set($data);\r\n$kefu->run();\r\n发送小程序卡片$type = 'miniprogrampage'; // 可选参数，text,link,image,miniprogrampage\r\n$kefu = new \\Com\\Kefu($type,$token); //群发消息一般都是群发一种类型的消息的，所以将type加载到构造中\r\n$data = array(\r\n    'touser'=>'xxxxx',\r\n    'title'=>'xxx小程序',\r\n    'pagepath'=>'/pages/index',\r\n    'thumb_media_id'=>'thumb_media_id',\r\n)\r\n$kefu->set($data);\r\n$kefu->run();"}
{"title": "微信小程序开发之formId使用（模板消息）、跨页面获取数据示例 ... ", "author": "Rolan", "pub_time": "2017-7-8 00:34", "content": "小程序的模板消息\" style=\"height: 35px; line-height: 1.5; color: rgb(255, 255, 255); padding: 0px 10px; border-radius: 3px; box-shadow: rgb(43, 62, 83) 3px 3px 5px; font-size: 22px; margin: 10px 20px 10px 0px; text-indent: 10px; background: rgb(128, 128, 128);\">基于微信小程序的模板消息官方文档基于微信的通知渠道，我们为开发者提供了可以高效触达用户的模板消息能力，以便实现服务的闭环并提供更佳的体验。模板推送位置：服务通知模板下发条件：用户本人在微信体系内与页面有交互行为后触发，详见下发条件说明模板跳转能力：点击查看详情仅能跳转下发模板的该帐号的各个页面使用案例场景描述：前台获取 formId 送至后台，由后台实现模板消息的发送。（此处由于 formId 只能由用户触发表单提交操作产生，故前台需要将每次产生的formId发送至后台，由后台保存并在适当时候调用微信接口向用户发送模板消息）代码实现：//example.wxml\r\n<form bindsubmit=\"submit\" report-submit='true' >\r\n  <button form-type=\"submit\" type=\"default\" size=\"mini\">提交</button>\r\n</form>\r\n\r\n//example.js\r\nsubmit: function (e) {\r\n  console.log(e.detail.formId);\r\n}注意：因为我们是在开发者工具中测试，所以得到的formId值为the formId is a mock one。在真机中我们可以得到一个具体的值，利用该值结合其他参数就可以发送模板消息啦，所以测试真实场景务必在真机中测试微信目前的限制是在如下两种情况下小程序才能够正常的使用模板消息：在小程序内使用了微信支付接口，在小程序里用户点击了表单，而且该表单的report-submit属性值为true时。index.wxml<navigator  class=\"navs\" url=\"{{urls}}\">\r\n    中国\r\n</navigator>index.jsPage({\r\n  data: {\r\n    urls:'/pages/lanbo/lanbo?title=我是Index里面的title数据'\r\n  }\r\n}) 要跳转的页面lanbo页面lanbo.wxml<text>pages/lanbo/lanbo.wxml</text>lanbo.jsPage({\r\n  data: {\r\n  \r\n  },\r\n  onLoad: function (options) {\r\n    this.setData({\r\n      title:options.title\r\n    });\r\n    console.log(this.data.title);\r\n  }\r\n})跳转页面之后请在调试模式下中的console下查看数据。"}
{"title": "微信小程序基础之表单Form的使用（附demo源码） ", "author": "天下雪", "pub_time": "2016-12-22 00:08", "content": "本文作者：hbblzjy，来自原文地址表单Form的应用很广泛，我们可以利用form设计登录注册，也可以设计一种答题问卷的形式，今天主要讲一下form的使用form表单，将组件内输入的\"switch\",\"input\",\"checkbox\",\"slider\",\"radio\",\"picker\"的值进行提交,数据的格式为：name:value，所以表单中控件都需要添加name属性，否则找不到对应控件的值。其主要属性：主要代码，创建一个form表单：<!--pages/index/Component/FormM/FormM.wxml--><view class=\"viewTitle\">    <text class=\"view-Name\">form表单</text>    <view class=\"lineView\"></view></view><!--这里用form，name=“nameName1”可以作为form的属性进行 （e.detail.value.nameName1）调用,form自带有提交和重置按钮，会自动获取表单中所有控件值的改变--><form class=\"page__bd\" bindsubmit=\"formSubmit\" bindreset=\"formReset\">    <view class=\"section section_gap\">      <view class=\"section__title\">switch开关</view>      <switch name=\"switch\"/>    </view>    <view class=\"section section_gap\">      <view class=\"section__title\">slider滑块</view>      <slider value=\"50\" name=\"slider\" show-value ></slider>赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              官方问答精选《二》Linux版，UnionId，苹果手机组件参数问题 \n              微信小程序-双击长按触发longtap事件时同时触发tap事件解决办法 ... ... ... \n            \n             \n            \n                  原作者: hbblzjy \n                  来自: 授权地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序基础之视图控件View、ScrollView、Swiper\n                                    \n                  • 微信小程序基础之常用控件text、icon、progress、button、navigator\n                                    \n                  • 微信小程序基础之input输入框控件\n                                    \n                  • 微信小程序源码解析：数字累加，动态效果（附demo）\n                                    \n                  • 微信小程序探究：运行环境，目录结构，模版语言及事件系统 ...\n                                    \n                  • 微信小程序组件系列：form表单讲解\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSS9ZO31', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n微信小程序开发早知道2019-04-04\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880734|8af63302a7e8e2d23b2c47d00d7cb29f|2';"}
{"title": "微信小程序开发－form 表单提交和取值 ", "author": "天下雪", "pub_time": "2017-4-20 00:11", "content": "我们知道，如果我们直接给 input 添加 bindinput，比如：<input bindinput=\"onUsernameInput\" />，那么可以在 onUsernameInput 中直接使用 e.detail.value，即：onUsernameInput : function(e) {\r\n    e.detail.value;\r\n}但是，如果有多个输入控件，我们不可能为每个控件添加 bindinput、bindchange 这类方法来获取值。我们得这样做：第一步、添加 from 控件，并为其指定 bindsubmit 属性值。第二步、添加输入控件到 form 中，并为其指定 name 属性值。第三步、添加 button 控件，并为其指定 form-type=\"submit\"。第四步、在 js 中取值时，用 e.detail.value.xxx 或 e.detail.value[\"xxx\"]，其中 xxx 为 name 属性值。.wxml 代码<form bindsubmit=\"reg\">\r\n\r\n    <view>用户：<input type=\"text\" name=\"username\" /></view>\r\n\r\n    <view>密码：<input password name=\"password\" /></view>\r\n\r\n    <view>兴趣：<checkbox-group name=\"cb\">\r\n        <label><checkbox value=\"A\" />乒乓球</label>\r\n        <label><checkbox value=\"B\" checked=\"false\" />羽毛球</label>\r\n        <label><checkbox value=\"C\" checked=\"{{checked}}\" />排球</label>\r\n    </checkbox-group></view>\r\n\r\n    <view>级别：<radio-group name=\"r\">\r\n        <label><radio value=\"a\" />初级</label>\r\n        <label><radio value=\"b\" />中级</label>\r\n        <label><radio value=\"c\" />高级</label>\r\n    </radio-group></view>\r\n\r\n    <view><button type=\"primary\" form-type=\"submit\">注册</button></view>\r\n\r\n</form>.js 代码reg: function(e) {\r\n\tconsole.log(e.detail.value);\r\n\t\r\n\twx.showToast({\r\n\t\ttitle: e.detail.value[\"cb\"].join(\",\"),\r\n\t\ticon: \"success\",\r\n\t\tduration: 2000\r\n\t});\r\n}重要说明<input type=\"text\" 中的 type 和 HTML 中的不同，具体为：text：不必解释number：数字键盘（无小数点）idcard：数字键盘（无小数点、有个 X 键）digit：数字键盘（有小数点） 注意：number 是无小数点的，digit 是有小数点的。<input password /> 表示密码框（个人认为太怪异，不如直接叫 password 标签的好）。“羽毛球”那一项，我们是故意写作 checked=\"false\" 的，我们试图使之初始不选中，但是不如我们愿，它却选中了，这和 HTML 一样，并不认 checked 属性值，只认有没有这个标记。不过如果我们使用 {{}} 则不一样，比如“排球”一项，选中与否就受 data.checked 的影响。input 的取值如前面所述，用 e.detail.value.xxx 或 e.detail.value[\"xxx\"]，其中 xxx 为 name 属性。checkbox 的取值也是类似 input，不过 xxx 为 checkbox-group 的 name，取出来的值是数组，由选中项的 value 组成，比如选中了“乒乓球”、“排球”，结果就是：[\"1\", \"3\"]。特别说明，这个顺序与我们选择的先后有关，比如我们先选择“排球”，再选择“乒乓球”，结果就是[\"3\", \"1\"]。radio 的取值和 input 一样，返回的是选中的那一项的 value，没有选中项就是 \"\"。如果不知道值类型，也可用 console.log(e.detail.value); 将所有值输出来，然后在调试 Console 中观察值，再来取。"}
{"title": "微信小程序简易首页制作 ", "author": "天下雪", "pub_time": "2017-4-7 00:00", "content": "作者：wuhuiheshang，来自原文地址效果图如下  首先从大的方面来讲，就是设置了window的属性\"navigationBarBackgroundColor\": \"#AFE2E6\",//bar背景颜色\"navigationBarTextStyle\": \"white\",//bar字体颜色\"backgroundColor\": \"white\",//背景颜色赞赏 \n                             \n                 \n                邀请 \n              \n              \n               \n               \n              \n              \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\nNicole\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n            \n            \n             \n                         \n              微信小程序组件系列：form表单讲解 \n              微信小程序 选项卡demo \n            \n             \n            \n                  原作者: wuhuiheshang \n                  来自: 原文地址 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n             \n            \n          \n          \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSUAbwp9', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n      \n      \n       \n    \n  \n  \n    \n    \n    \n     \n      \n      \n       \n    \n  \n\n\n\n \n  \n  \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880734|8af63302a7e8e2d23b2c47d00d7cb29f|2';"}
{"title": "微信小程序问题汇总及详解《六》获取form表单初始值提交数据 ... ", "author": "天下雪", "pub_time": "2017-4-14 00:00", "content": "分享者：JoyJin，来自原文地址<form bindsubmit=\"formSubmit\">    <view class=\"txt\">      <view class=\"ima\"></view>      <view class=\"txt2\">姓名</view>      <input placeholder=\"请输入姓名\" maxlength=\"10\" class=\"txt3\" value=\"{{mem_name}}\" bindchange=\"name\" name=\"name2\"/>    </view>    <view class=\"txt\">      <view class=\"ima\"></view>      <view class=\"txt2\">身份证号</view>      <input type=\"idcard\" placeholder=\"请输入身份证号码\" class=\"txt3\"   value=\"{{mem_IDnum}}\" bindchange=\"ID_num\" maxlength=\"18\" name=\"ID_num2\"/>    </view>    <view style=\"clear:both\"></view>    <button class=\"btn\" form-type=\"submit\" hover-class=\"none\">完成</button>  </form>page({name: function (e) {   //获取input输入的值    var that = this;    that.setData({      name: e.detail.value    })  },  ID_num: function (e) {    //获取input输入的值    var that = this;    that.setData({      ID_num: e.detail.value    })    var id_num = that.data.ID_num    if (!(id_num.length === 15 || id_num.length === 18)) {      wx.showToast({        title: '请输入15或18位数身份证号码',        image: '../Image/error.png',        duration: 2000      })    }  },formSubmit: function (e) {    var that = this;    var tokend = wx.getStorageSync('tokend')    var name2 = e.detail.value.name2;         //获取input初始值    var ID_num2 = e.detail.value.ID_num2;    //获取input初始值    var name = that.data.name ? that.data.name : name2    //三元运算，如果用户没修改信息，直接提交原来的信息，如果用户修改了信息，就将修改了的信息和未修改过的信息一起提交    var ID_num = that.data.ID_num ? that.data.ID_num : ID_num2    wx.request({      method: 'POST',      url: 'https://....?token=' + tokend, //接口地址      data: {        'name': name,        'ID_num': ID_num      },      header: { 'content-type': 'application/json' },      success: function (res) {        wx.showToast({          title: '资料修改成功',          image: '../Image/suess.png',          duration: 2000        })        setTimeout(function () {          wx.switchTab({            url: '../index/index',          })        }, 2000)      },      fail: function (res) {        console.log('cuowu' + ':' + res)      }    })  },})"}
{"title": "微信小程序---提交表单后清空输入框 ", "author": "Rolan", "pub_time": "2017-5-26 10:15", "content": "最近有人问我提交表单后怎么把输入框的内容清空了。 这种方法不止一种，1、可以用表单的重置功能。按钮设置： formType=\"reset\">提交form设置： bindreset=\"formReset\">表单重置时会触发reset事件，在formreset事件中提交数据就行了，不过这样不能使用event.detail获取输入值了，要用input的bindinput事件或bindblur事件获取。然后用this.setData({})把值存起立提交表单时拿出来就行了。2、可以用一个最简单的方法。不需要设置重置属性，只需要在input中设置属性value type=\"text\" name='name' value=\"{{name}}\"/>然后表单提交，在成功返回函数success中设置this.setData({              name:''            })这样就每次提交后都会把输入框的内容清空了。"}
{"title": "微信小程序三级联动地址选择器 ", "author": "Rolan", "pub_time": "2017-7-12 00:59", "content": "在一些电商类的小程序中，地址选择这个功能一般是必备的，一般的收货信息都需要有一个能选择省市县的控件，当然也有些人为了省事就直接写了一个供输入的input，那么这样做的缺点不言而喻，而且用户体验也不是那么的好，今天的这篇文章就分享一下微信小程序地址选择的实现。省市县的数据以及区域码可以从国家统计局查询到，具体可以自己搜一下。照例先上源码和效果图源码传送门picker和picker-view组件在正式介绍实现之前，我们需要先来介绍下这两个组件，picker这个组件在前面的文章有简单介绍过，它是从底部弹起的滚动选择器，可以通过设置type的值来实现日期选择，时间选择以及普通的选择器，如果我们想实现上图三级联动地址选择效果，发现实现起来很困难，应该说是不能实现，因为picker普通选择器是只能有一列，如果想这实现三列的效果就需要另辟蹊径了。既然是另辟蹊径，自然就会想到picker-view，该组件是一个嵌入页面的滚动选择器，该组件中可以放置多个picker-view-column，并且只能放置picker-view-column，其它组件是不会显示的，每一个picker-view-column就是一列。picker-view有几个重要的属性，value是一个数组类型，数组中的数字依次表示 picker-view 内的 picker-view-colume 选择的第几项（下标从 0 开始），数字大于 picker-view-column 可选项长度时，选择最后一项。indicator-style和indicator-class可以设置选择器中间选中框的样式，他有一个事件bindchange，当我们滚动item时选择的item数据发生变化就会触发这个函数，并且可以通过event.detai.vaule（和上面介绍vaule含义相同）获取当前选择的是第几项（下标从 0 开始）。而对于picker-view-column高度会自动设置成与picker-view的选中框的高度一致。省市县数据文件 存储了地址选择所需要用到的数据，主要是区域码和名字，然后通过下面代码将数据暴露出去，以供使用module.exports = {\r\n  citys,\r\n  provinces,\r\n  areas\r\n}wxml文件实现<view class=\"picker-view\" animation=\"{{animationAddressMenu}}\" style=\"visibility:{{addressMenuIsShow ? 'visible':'hidden'}}\">\r\n  <view style=\"height:10% ;width:95%;margin-top:10rpx\">\r\n    <text catchtap=\"cityCancel\">取消text>\r\n    <text style=\"float: right\" catchtap=\"citySure\">确定text>\r\n  view>\r\n  <picker-view style=\"width: 100%; height: 300px;\" bindchange=\"cityChange\" value=\"{{value}}\" wx:key=\"\">\r\n    <picker-view-column>\r\n      <view wx:for=\"{{provinces}}\" class=\"picker-item\">\r\n        {{item.name}}view>\r\n    picker-view-column>\r\n    <picker-view-column>\r\n      <view wx:for=\"{{citys}}\" class=\"picker-item\" wx:key=\"\">\r\n        {{item.name}}view>\r\n    picker-view-column>\r\n    <picker-view-column>\r\n      <view wx:for=\"{{areas}}\" class=\"picker-item\" wx:key=\"\">\r\n        {{item.name}}view>\r\n    picker-view-column>\r\n  picker-view>\r\nview>主要就是上面有一个取消和确定供用户点击确认选择，以及picker-view 中包含三个picker-view-column组件，分别对应显示省市区，provinces，citys，areas是对应的数据，animation是选择控件可见或者不可见时的过渡动画。样式wxss文件.picker-view {\r\n  width: 100%;\r\n  display: flex;\r\n  z-index:12;\r\n  background-color: #fff;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  position: fixed;\r\n  bottom: 0rpx;\r\n  left: 0rpx;\r\n  height: 40vh;\r\n}\r\n\r\n.picker-item {\r\n  line-height: 70rpx;\r\n  margin-left: 5rpx;\r\n  margin-right: 5rpx;\r\n  text-align: center;\r\n}在js中我们在data中加入数据/**\r\n   * 控件当前显示的数据\r\n   * provinces:所有省份\r\n   * citys 选择省对应的所有市,\r\n   * areas选择市对应的所有区\r\n   * areaInfo：点击确定时选择的省市县字符拼接\r\n   * animationAddressMenu：动画\r\n   * addressMenuIsShow：是否可见\r\n   */\r\n  data: {\r\n    animationAddressMenu: {},\r\n    addressMenuIsShow: false,\r\n    value: [0, 0, 0],\r\n    provinces: [],\r\n    citys: [],\r\n    areas: [],\r\n    areaInfo:''\r\n  },最重要的是在js文件开始处引入数据文件var address = require('../../utils/city.js')onLoad中初始化数据,默认显示北京// 默认联动显示北京\r\n    var id = address.provinces[0].id\r\n    this.setData({\r\n      provinces: address.provinces,\r\n      citys: address.citys[id],\r\n      areas: address.areas[address.citys[id][0].id],\r\n    })事件的处理逻辑：// 点击所在地区弹出选择框\r\n  selectDistrict: function (e) {\r\n    var that = this\r\n    // 如果已经显示，不在执行显示动画\r\n    if (that.data.addressMenuIsShow) {\r\n      return\r\n    }\r\n    // 执行显示动画\r\n    that.startAddressAnimation(true)\r\n  },\r\n  // 执行动画\r\n  startAddressAnimation: function (isShow) {\r\n    console.log(isShow)\r\n    var that = this\r\n    if (isShow) {\r\n      // vh是用来表示尺寸的单位，高度全屏是100vh\r\n      that.animation.translateY(0 + 'vh').step()\r\n    } else {\r\n      that.animation.translateY(40 + 'vh').step()\r\n    }\r\n    that.setData({\r\n      animationAddressMenu: that.animation.export(),\r\n      addressMenuIsShow: isShow,\r\n    })\r\n  },\r\n  // 点击地区选择取消按钮\r\n  cityCancel: function (e) {\r\n    this.startAddressAnimation(false)\r\n  },\r\n  // 点击地区选择确定按钮\r\n  citySure: function (e) {\r\n    var that = this\r\n    var city = that.data.city\r\n    var value = that.data.value\r\n    that.startAddressAnimation(false)\r\n    // 将选择的城市信息显示到输入框\r\n    var areaInfo = that.data.provinces[value[0]].name + ',' + that.data.citys[value[1]].name + ',' + that.data.areas[value[2]].name\r\n    that.setData({\r\n      areaInfo: areaInfo,\r\n    })\r\n  },\r\n  // 点击蒙版时取消组件的显示\r\n  hideCitySelected: function (e) {\r\n    console.log(e)\r\n    this.startAddressAnimation(false)\r\n  },\r\n  // 处理省市县联动逻辑\r\n  cityChange: function (e) {\r\n    console.log(e)\r\n    var value = e.detail.value\r\n    var provinces = this.data.provinces\r\n    var citys = this.data.citys\r\n    var areas = this.data.areas\r\n    var provinceNum = value[0]\r\n    var cityNum = value[1]\r\n    var countyNum = value[2]\r\n    // 如果省份选择项和之前不一样，表示滑动了省份，此时市默认是省的第一组数据，\r\n    if (this.data.value[0] != provinceNum) {\r\n      var id = provinces[provinceNum].id\r\n      this.setData({\r\n        value: [provinceNum, 0, 0],\r\n        citys: address.citys[id],\r\n        areas: address.areas[address.citys[id][0].id],\r\n      })\r\n    } else if (this.data.value[1] != cityNum) {\r\n      // 滑动选择了第二项数据，即市，此时区显示省市对应的第一组数据\r\n      var id = citys[cityNum].id\r\n      this.setData({\r\n        value: [provinceNum, cityNum, 0],\r\n        areas: address.areas[citys[cityNum].id],\r\n      })\r\n    } else {\r\n      // 滑动选择了区\r\n      this.setData({\r\n        value: [provinceNum, cityNum, countyNum]\r\n      })\r\n    }\r\n    console.log(this.data)\r\n  },对于事件处理，联动的处理逻辑，需要解释的我已在代码实现中做了解释，也没有什么比较难以理解的内容，就不在过多介绍，到这里微信小程序省市县三级联动效果已经实现了。如果阅读本文的你发现文中有不妥或者错误的地方，欢迎指正，在此谢过。Hava a wonderful day。"}
{"title": null, "author": null, "pub_time": null, "content": ""}
{"title": "小程序tabBar跳转页面并隐藏tabBar ", "author": "Rolan", "pub_time": "2017-12-12 00:31", "content": "在开发小程序过程中，相信有一部分人，遇到过一个问题：当使用tabBar跳转页面时，所跳转的页面下方必定有 tabBar显示，而当你需要把它隐藏时，却束手无策。话不多说，在这里给大家分享如何隐藏tabBar的方法。方法一:自定义tabBar使用自定义tabBar，新建一个tarBar.wxml模板页，然后引用模板的页面传入数据即可，代码如下：<template name=\"tabBar\">  \r\n  <view class=\"flex-h\" style=\"color: {{tabBar.color}}; background: {{tabBar.backgroundColor}}; {{tabBar.position=='top'? 'top: 0' : 'bottom: 0'}}; {{tabBar.borderStyle? (tabBar.position=='top'? 'border-bottom: solid 1px '+tabBar.borderStyle + ';' : 'border-top: solid 1px '+tabBar.borderStyle + ';') : ''}}\">  \r\n  <block wx:for=\"{{tabBar.list}}\" wx:key=\"pagePath\">  \r\n    <navigator url=\"{{item.pagePath}}\" open-type=\"{{item.pageTum}}\" class=\"menu-item\" style=\"{{item.active? 'color: '+(item.selectedColor? item.selectedColor : tabBar.selectedColor) : ''}}\">  \r\n      <image src=\"{{item.selectedIconPath}}\" wx:if=\"{{item.active}}\"></image>  \r\n      <image src=\"{{item.iconPath}}\" wx:if=\"{{!item.active}}\"></image>  \r\n      <text>{{item.text}}</text>  \r\n    </navigator>  \r\n    </block>  \r\n  </view>  \r\n</template>接下来是在index.js的配置对象：tabBar:{\r\n    \"color\": \"#9E9E9E\",\r\n    \"selectedColor\": \"#f00\",\r\n    \"backgroundColor\": \"#fff\",\r\n    \"borderStyle\": \"#ccc\",\r\n    \"list\":[{\r\n            \"pagePath\": \"/pages/index/index\",\r\n            \"text\": \"主页\",\r\n            \"iconPath\": \"../../images/index.png\",\r\n            \"selectedIconPath\": \"../../images/index_active.png\",\r\n            \"pageTum\": \"redirect\",\r\n            \"selectedColor\": \"#4EDF80\",\r\n            active: true\r\n            },\r\n            {\r\n            \"pagePath\": \"/pages/tum/tum\",\r\n            \"text\": \"其他\",\r\n            \"iconPath\": \"../../images/pageTum.png\",\r\n            \"pageTum\": \"navigate\",\r\n            \"selectedColor\": \"#4EDF80\",\r\n            active: false\r\n            },\r\n            {\r\n            \"pagePath\": \"/pages/mine/mine\",\r\n            \"text\": \"我的\",\r\n            \"iconPath\": \"../../images/mine.png\",\r\n            \"selectedIconPath\": \"../../images/mine_active.png\",\r\n            \"pageTum\": \"redirect\",\r\n            \"selectedColor\": \"#4EDF80\",\r\n            active: false\r\n            }],\r\n            \"position\": \"bottom\"\r\n    }\r\n}在这里要注意的是，active表示该页面是否被选中，pageTum表示点击该页面跳转方式，‘其他’这个页面不用设置tabBar，并且它的pageTum的值是navigate，表示点击‘其他’跳转的页面就不会显示tabBar。index.wxml引入模板：<import src=\"../template/tabBar.wxml\" />  \r\n<template is=\"tabBar\" data=\"{{tabBar: tabBar}}\" /> \r\n<text>主页面</text>    //显示内容然后在mine页面也一样配置数据把active的值改为true，引入模板。效果如下：方法二：使用中间页面跳转使用原生tabBar跳转至一级页面，再利用周期函数onShow的特性直接跳转到我们需要看到的页面，并且在返回时使用wx.swicthTab跳转至程序设计所需的一级页面。下面来看一看实现方法：首先在app.json中设置tabBar\"tabBar\": {\r\n        \"color\": \"#9E9E9E\",\r\n        \"selectedColor\": \"#f00\",\r\n        \"backgroundColor\": \"#fff\",\r\n        \"borderStyle\": \"#ccc\",\r\n        \"list\": [{\r\n                \"pagePath\": \"pages/index/index\",\r\n                \"text\": \"主页\",\r\n                \"iconPath\": \"images/index.png\",\r\n                \"selectedIconPath\": \"images/index_active.png\"\r\n            },\r\n            {\r\n                \"pagePath\": \"pages/tum/pageTum\",\r\n                \"text\": \"其他\",\r\n                \"iconPath\": \"images/pageTum.png\"\r\n            },\r\n            {\r\n                \"pagePath\": \"pages/mine/mine\",\r\n                \"text\": \"我的\",\r\n                \"iconPath\": \"images/mine.png\",\r\n                \"selectedIconPath\": \"images/mine_active.png\"\r\n            }\r\n        ]\r\n    }在‘其他’这个页面中设置跳转页面为一个中间过渡页面pageTum，然后利用pageTum的周期函数onShow跳转至无tabBar的二级页面tum，返回时就能直接返回至主页面，代码如下：data: {\r\n        num: 0,\r\n    },\r\n    onLoad: function() {},\r\n    onShow: function() {\r\n        this.data.num++;\r\n        if (this.data.num % 2 == 0) {\r\n            wx.switchTab({\r\n                url: '../index/index'\r\n            });\r\n        } else {\r\n            wx.navigateTo({\r\n                url: './tum'\r\n            })\r\n        }\r\n    }实现效果如果有错误或者其他的方法，希望可以指出和交流，谢谢！"}
{"title": "微信小程序：完成一个tabbar+下拉刷新组件，需要经历什么坑 ", "author": "Rolan", "pub_time": "2017-11-15 00:37", "content": "tabbar+下拉刷新在最近的微信小程序开发中，遇到一个比较坑的界面开发，说坑并不是因为它难，而是这其中包括了太多的开发时所要填的坑了，今天准备将这些填完的小坑一个个刨出来仔细啃啃，做一个demo分享一下。\r\n需求分析简单梳理一下需求：1.tabbar 需要用 fixed来跟随 2.需要有上拉刷新，下拉加载的功能\r\n需求很简单，看起来一个个都不是很困难，但其中隐约的藏着许多个小坑洼，需要一个个仔细的来填上。首先第一个需求，position:fixed; 直接实现，不存在任何困难。\r\n实现方法紧接着面对上拉刷新、下拉加载这个功能，老生常谈，主要有两个实现的方式：1.scroll-view的上下监听函数，在触顶和触底时分别执行上拉刷新和下拉刷新机制。2.微信api自带的onReachBottom 和 onPullDownFresh 两个函数，分别为触底执行和下拉刷新。\r\n先来介绍一下两种方法：1.利用scroll-view 来放置列表展示页，将产品列表贴在scroll-view上，利用下滑属性可以将产品展示在其中。在scroll-view触底时， 绑定bindtaplower 这个函数将会被触发，达到“下拉刷新”的效果。2.利用page标签自带的onReachBottom 来达到下拉加载，上拉刷新。两个api属于自带的api，而这个的上拉刷新也自带了一个刷新动画。\r\n两种方法均有其特点和优异之处。从个人的开发喜好来说，在单列表中，第二种方式，即OnReachBottom 和 onPullDownFresh 的方式是优于第一种方式的。为什么呢？因为它自带了一个下拉刷新的动画。而用scroll-view 的上拉刷新是不带这个动画的。所以谁更加优秀不言而喻啦。\r\n那么，我们应该如何合适的使用这两种方案？\r\n微信小程序是一种很简单的前端程序，但是它其中蕴含了许多的大大小小的坑。比如：在scroll-view 的碰边函数上，会出现碰触执行多次的问题，即触底执行的判定过于多次，导致其疯狂触发函数。\r\n面临这样的bug，我的第一想法是给他们上个锁。每当函数执行时将锁关上，在函数之行结束之时再将锁打开。这样就可以将函数重复执行的问题解决了。\r\n·上拉加载的函数·\r\nupper: function() {\r\n    var that = this\r\n    var timestamp = Date.parse(new Date()) / 1000;\r\n    var lastTime = this.data.lastLoadTime\r\n    if (timestamp - lastTime < 5) {\r\n        console.log('太快了')\r\n    } else {\r\n        that.setData({ lastLoadTime: timestamp })\r\n        if (this.data.pullUpAllow) {\r\n            console.log('刷新啦')\r\n            that.setData({\r\n                pullUpAllow: false\r\n            })\r\n            wx.showNavigationBarLoading() //在标题栏中显示加载\r\n            console.log(that.data.classidnow)\r\n            wx.request({\r\n                url: '…',//这里放置的是接口的地址\r\n                method: 'POST',\r\n                data: {\r\n                    shopid: getApp().globalData.shopid,\r\n                    classid: that.data.classidnow,\r\n                    userid: getApp().globalData.userid\r\n                },\r\n                header: {\r\n                    'content-type': 'application/json' // 默认值\r\n                },\r\n                success: function(res) {\r\n                    console.log(res)\r\n                    if (res.data.data.length != 0) {\r\n                        let shoppingDetail = res.data.data\r\n                        that.setData({\r\n                            shopping: shoppingDetail,\r\n                            showNowData: false\r\n                        })\r\n                        console.log(that.data.shopping)\r\n                    } else {\r\n                        that.setData({\r\n                            shopping: shoppingDetail,\r\n                            showNowData: true\r\n                        })\r\n                    }\r\n                },\r\n                complete: function() {\r\n                    wx.hideNavigationBarLoading() //完成停止加载\r\n                    wx.stopPullDownRefresh() //停止下拉刷新\r\n                    setInterval(() => {\r\n                        that.setData({\r\n                            pullUpAllow: true\r\n                        })\r\n                    }, 1000)\r\n                }\r\n            })\r\n        }\r\n    }\r\n}虽然可以解决下拉刷新触发过多的问题，但因为上拉刷新的硬伤，所以我认为，在能使用onReachBottom的情况下，不要去使用scroll-view来写。因为上拉加载时，用Scroll-viewl动画提示用户在下拉刷新时，用的是showNavigationBarLoading()这个api，他做到的是在标题上加入一个旋转的小动画。但是使用这个api时，会产生的一个问题就是，如果在上拉加载时不放手时，还是会疯狂触发上拉刷新的bug，这是后标题会疯狂鬼畜的抖动。这时候，我想到的解决方案是给上拉再次加入一个时间锁。在三秒之内，再次触发刷新时，禁止它的触发。而自带的onReachBottom 将不会再触发这类问题，因为它要真真实实的上拉，所以综上所述，如果能用onReachBottom ，辣就不要用scroll-view来写上拉刷新啦，因为真的没那么好用的。\r\n如果你以为这就结束了？\r\n上一段说了，如果如果能用onReachBottom ，就用这个，那么什么情况下不能用呢？这就关系到一开始说的需求了，需求上是关系到一个需要position:fixed的属性的。那么，我们就要面临一个问题了。如果用的是view 标签，在拉到1/2 时，做tab切换，时候就面临一个问题：它的切换并不会切到顶部，而出现的也是在刷新之后的1/2处，这个体验非常不人性化。那么，在面对需要置顶的情况下，view的使用就会面临一个瓶颈了。如何让view置顶？这是个问题。\r\n我的解决方案是：scroll-view 在每次切换时，让scrollTop行内标签归零，这样就可以让每次切换置顶了。而因为scrolltop一开始就为0，第一次的上拉刷新是不会触发的。在这样的场景下，目前还是用scroll-view 来的更为简便。\r\n最终样式\r\n最后：这是最近开发的一个tabbar + 下拉刷新的demo，如果有需要，就到github里来取吧，如果可以的话记得给个小星星哟~\r\ngithub地址：github.com/yanlvji54/O…"}
{"title": "如何跳出小程序五级页面的限制 ", "author": "Rolan", "pub_time": "2017-11-9 00:18", "content": "前言：做小程序开发，就要在微信的规则内玩耍。最近做的小程序经常会有个报错：RangeError: Maximum call stack size exceeded。这意思是说小程序页面超过5级跳转了，应该怎么解决呢？微信小程序官方文档中，关于页面的跳转，有三个API，两个跳转新页面的 API 分别为wx.navigateTo和wx.redirectTo，还有一个 API 名为wx.navigateBack，它用于返回上级页面。wx.navigateBack在小程序的初始版本中只能回到上一个页面，在最新版本（0.10.102800）的更新中给navigateBack添加了一个参数delta，用于决定需要返回几层页面。navigator组件的默认跳转方式与wx.navigateTo相同，而如果添加redirect属性，则与wx.redirectTo的跳转方式相同。wx.navigateTo在官方文档中描述如下：保留当前页面，跳转到应用内的某个页面，使用wx.navigateBack可以返回到原页面。通过navigateTo跳转后，可点击左上角的按钮返回上一个页面。而如果多次调用navigateTo之后，就需要返回多次才能回到初始页面，这种交互更像是客户端打开一个新的view。因此，官方在此处有一个限制（最多五级）。注意：为了不让用户在使用小程序时造成困扰，我们规定页面路径只能是五层，请尽量避免多层级的交互方式。不过上述五层的限制只是针对navigateTo，redirectTo则无此限制。因为redirectTo的行为是：关闭当前页面，跳转到应用内的某个页面。因此，当页面个数超过五层时，应该用redirectTo来替换navigateTo，就可以避免Maximum call stack size exceeded的异常，但是redirectTo关闭当前页面的做法，有些场景并不适用，比如，从列表页进详情页面，如果进入详情页面时，关闭列表页面，再次back时，就没办法回到列表页面。通过redirectTo跳转后，只是无法返回跳转前的页面，但并不是无法调用navigateBack，而是调用之后，会回到使用redirectTo跳转前的上一个页面。页面栈可以通过getCurrentPages方法获取：getCurrentPages()函数用于获取当前页面栈的实例，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。这个方法也比较适用，在多层页面跳转中，你可能会用的到。"}
{"title": "VIDE支持微信和支付宝小程序开发 ", "author": "Rolan", "pub_time": "2017-10-21 00:18", "content": "VIDE介绍vide是基于vuejs框架开发的一款IDE，vide插件系统也是基于vuejs来开发，插件系统的数据和IDE的数据都是有vuex来管理，导致使整个IDE的设计非常简单和轻巧，同时开发插件也变得非常快速，插件开发效率上，完全是vscode和atom好几倍。下面是整个IDE的设计 小程序开发1.安装vide链接地址：https://www.debuggap.com/zh-cn/installation.html目前可以通过官网和百度网盘进行下载安装2.安装插件打开vide后，在插件安装区域，你可以看到相应的全家桶插件配套，点击安装Common，alipay,weixin全家桶后，就可以支持微信小程序和通用模块开发了。 3.开发使用（以微信为例）a.接口提示 b.鼠标移到接口上，查看接口说明c.在wxml页面，查看元素及其属性含义未来规划目前已经支持vue，weex，小程序和常规js等开发，接下来会优先支持更多的框架，希望更多的开发者一起加入进来，强大的插件系统，为更多开发者提供方便。github：https://github.com/debuggap"}
{"title": "微信小程序中获取access_token ", "author": "Rolan", "pub_time": "2017-11-1 10:07", "content": "起因是想在微信小程序中获取access_token。     之前资源只有一个阿里云虚拟主机和一个域名，于是用C#后端写了GET请求的接口，准备调用自己域名下的接口获取access_token  使用微信的wx.request接口123456wx.request({  url: \"www.xxxxxx.com/home/gettoken\",  success:function(res){    console.log(res)  }})　　发现报错，提示该域名不在服务器合法域名中  于是去微信小程序的开发设置中的服务器域名配置  添加了request合法域名为 xxxxx.com；  仍然提示不在合法域名中，仔细一看，原来小程序要求配置的服务器域名必须是https的   行，那就去阿里云搞一个证书，登录阿里云管理控制台，列表选择安全（云盾）-》CA证书服务，购买证书   等几分钟证书就申请好了，点【下载】 本人的是云虚拟主机啊，只是服务器上的一个文件夹而已，根本没办法去配置证书，怎么办，然后去查资料，发现可以通过CDN加速或者上负载均衡来实现 如果你觉得上面两种方式能满足你的需求，请另行百度，总之我是放弃了。 之后本人就去买了个ECS服务器最低配的那种，选择windows server 2008 R2准备拿着公网ip在自己的电脑上远程连接桌面，结果提示： 然后就去查安全组配置，发现该有的都有了后面升级https需要加一条规则 用网页版的远程连接到服务器上查看是否开启了允许远程连接，是可以的查看防火墙，关了的，讲道理应该能远程上才对。 最后发现cmd-》ipconfig发现没有分配Ip地址，于是修改成静态内网Ip,终于远程上了。远程连接不上会有很多种原因，如果按照查询的方法仍然不行的话，建议提交阿里云工单，还是很靠谱的。 安装IIS，这一步没有任何坑 安装证书 发布代码，添加网站绑定 添加HTTPS绑定，选择ssl证书iis上浏览网站（https）的，发现地址栏是本地，并没有指到我的域名，上面的框里也没有办法修改添加主机名iis7下面默认HTTPS绑定是无法指定主机头的，但我们可以通过手工修改IIS配置来实现主机头绑定 打开C:\\Windows\\system32\\inetsrv\\config\\applicationHost.config 搜索https         <bindings>                    <binding protocol=\"https\" bindingInformation=\"*:443\" />　　　　　　xxxxxxx　　　　　　xxxxxx        </bindings>修改成： <binding protocol=\"https\" bindingInformation=\"*:443:你的域名\" />域名解析中添加服务器ip的解析   一切完毕之后，准备开始调用access_token大展身手，结果又提示TLS版本为1.0，至少需要1.2及以上版本 经查询发现，在IIS7中TLS1.2协议是默认关闭的。所以我们需要对IIS做下设置，来开启TLS1.2协议。可使用ssltools工具 该升级的也升级了终于，接口通了"}
{"title": "小程序实现长按录音，上划取消发送 ", "author": "Rolan", "pub_time": "2018-8-20 00:27", "content": "最近在使用mpvue开发小程序，需要用到录音功能，于是打算参照微信的录音方案：\"长按录音松开发送，上划取消发送\"。在网上找了一圈都没发现相似的案例，没办法只能自己实现。下面讲解只贴上关键代码1. html部分。微信小程序事件接口：//html部分 class部分只是控制样式 与功能无关分析:长按录音需要longpress事件，松开发送需要touchend事件，上滑取消发送需要touchmove事件。由此可有以下html代码<div class=\"input weui-grid\" hover-class=\"weui-grid_active\" :class=\"record.type\" @longpress=\"handleRecordStart\" @touchmove=\"handleTouchMove\" @touchend=\"handleRecordStop\">\r\n        <image class=\"weui-grid__icon\"  :src=\"record.iconPath\"/>\r\n        <div class=\"weui-grid__label\">{{record.text}}</div>\r\n</div>\r\n2. JS部分2.1. 首先定义录音的数据结构：旧版的小程序录音接口wx.startRecord和wx.stopRecord在1.6.0版本后不再维护了，所以使用其建议的wx.getRecordManager接口。注意:使用wx.getRecordManager接口的话,应调用相应的音频控制接口wx.createInnerAudioContext()来播放和控制录音.data(){\r\n          record: {\r\n          text: \"长按录音\",\r\n          type: \"record\",\r\n          iconPath: require(\"@/../static/icons/record.png\"),\r\n          handler: this.handleRecordStart\r\n          }, //与录音相关的数据结构\r\n    recorderManager: wx.getRecorderManager(), //录音管理上下文    \r\n    startPoint: {}, //记录长按录音开始点信息,用于后面计算滑动距离。\r\n          sendLock: true, //发送锁，当为true时上锁，false时解锁发送\r\n\r\n  },\r\n2.2. 监听录音stoponLoad(){\r\n  this.recorderManager.onStop(res => {\r\n            if (this.sendLock) {\r\n              //上锁不发送\r\n            } else {//解锁发送，发送网络请求\r\n              if (res.duration < 1000)\r\n                    wx.showToast({\r\n                          title: \"录音时间太短\",\r\n                          icon: \"none\",\r\n                          duration: 1000\r\n                    });\r\n               else this.contents = [...this.contents,{ type: \"record\", content: res }];//contents是存储录音结束后的数据结构,用于渲染.\r\n            }\r\n          });\r\n}2.3. 长按录音方法在这个方法中需要做的事:记录长按的点信息,用于后面计算手指滑动的距离,实现上滑取消发送.做一些界面样式的控制.开始录音    handleRecordStart(e) {\r\n          //longpress时触发\r\n           this.startPoint = e.touches[0];//记录长按时开始点信息，后面用于计算上划取消时手指滑动的距离。\r\n           this.record = {//修改录音数据结构，此时录音按钮样式会发生变化。\r\n                text: \"松开发送\",\r\n               type: \"recording\",\r\n                 iconPath: require(\"@/../static/icons/recording.png\"),\r\n                   handler: this.handleRecordStart\r\n              };\r\n              this.recorderManager.start();//开始录音\r\n              wx.showToast({\r\n                title: \"正在录音，上划取消发送\",\r\n                icon: \"none\",\r\n                duration: 60000//先定义个60秒，后面可以手动调用wx.hideToast()隐藏\r\n              });\r\n              this.sendLock = false;//长按时是不上锁的。\r\n\r\n      },\r\n2.4. 松开发送在这个方法中需要做的事:做一些样式的控制.结束录音.      handleRecordStop() {\r\n          // touchend(手指松开)时触发\r\n          this.record = {//复原在start方法中修改的录音的数据结构\r\n            text: \"长按录音\",\r\n            type: \"record\",\r\n            iconPath: require(\"@/../static/icons/record.png\"),\r\n            handler: this.handleRecordStart\r\n          };\r\n          wx.hideToast();//结束录音、隐藏Toast提示框\r\n          this.recorderManager.stop();//结束录音\r\n      }2.5. 上划取消发送在这个方法中需要做的事:计算手指上滑的距离根据距离判断是否需要取消发送如果取消发送,最重要的是this.sendLock = true,上锁不发送      handleTouchMove(e) {\r\n          //touchmove时触发\r\n          var moveLenght = e.touches[e.touches.length - 1].clientY - this.startPoint.clientY; //移动距离\r\n          if (Math.abs(moveLenght) > 50) {\r\n            wx.showToast({\r\n                  title: \"松开手指,取消发送\",\r\n                  icon: \"none\",\r\n                  duration: 60000\r\n            });\r\n            this.sendLock = true;//触发了上滑取消发送，上锁\r\n          } else {\r\n            wx.showToast({\r\n                  title: \"正在录音，上划取消发送\",\r\n                  icon: \"none\",\r\n                  duration: 60000\r\n            });\r\n            this.sendLock = false;//上划距离不足，依然可以发送，不上锁\r\n          }\r\n    },\r\n  }2.6. 演示GIF文章来源：Rychou个人博客"}
{"title": "微信小程序的Web API接口设计及常见接口实现 ", "author": "Rolan", "pub_time": "2017-9-9 00:43", "content": "微信小程序给我们提供了一个很好的开发平台，可以用于展现各种数据和实现丰富的功能，通过小程序的请求Web API 平台获取JSON数据后，可以在小程序界面上进行数据的动态展示。在数据的关键 一环中，我们设计和编写Web API平台是非常重要的，通过这个我们可以实现数据的集中控制和管理，本篇随笔介绍基于Asp.NET MVC的Web API接口层的设计和常见接口代码的展示，以便展示我们常规Web API接口层的接口代码设计、参数的处理等内容。1、Web API整体性的架构设计我们整体性的架构设计，包含一个Web管理后台、一个Web API统一接口层、当然还有数据库什么，另外还有一个小程序客户端。整个架构体系还是以我之前随笔介绍的《 整合微信小程序的Web API接口层的架构设计 》内容为蓝本整个体系以Web API为主提供服务，同时后台管理系统通过各种界面维护着数据的增删改等基础管理工作。Web API的分层，我们可以通过下图来了解具体的分层结构。随着基于JSON格式的Web API的广泛应用，越来越多的企业采用Web API接口服务层，作为统一接口的核心所在，也成为Web API核心层。基于JSON格式的接口，可以广泛地、跨平台的应用于IOS、安卓等移动端，也可以应用在常规的Web业务系统，Winform业务系统、微信应用、微信小程序等方方面面，因此企业内部形成自己是的一套Web API标准和详细的文档非常重要。我们可以细化为下面的架构设计图，所有模块均围绕着Web API 接口层进行扩展，底层的数据存储对上层的应用是完全透明，我们可以根据需要拆分各种业务数据库，以及使用我们认为合适的数据库。其中我们在Web API接口层上还看到一个微信消息交互的模块，这个模块我们为了方便域名端口的处理，和Web API 是统一放在一起的，它负责和腾讯微信服务器进行消息的交互处理，从而实现各种消息推送处理。2、基于Asp.NET MVC的Web API接口的实现1）GET方式GET方式，接口参数包括有零或一个参数，以及多个参数的方式，返回的值可以是简单的字符串等基础类型，也可以是复杂的自定义对象类型等，如下面几种接口代码所示。        /// <summary>\r\n        /// 简单的GET方式获取数据\r\n        /// </summary>\r\n        /// <param name=\"id\">字符串ID</param>\r\n        /// <param name=\"token\">接口访问令牌</param>\r\n        /// <returns>返回字符串值</returns>\r\n        [HttpGet]\r\n        public string Test(string id, string token)\r\n        {\r\n            return string.Format(\"返回结果, id:{0}\", id);\r\n        }\r\n\r\n        /// <summary>\r\n        /// 多个参数的GET方式获取数据\r\n        /// </summary>\r\n        /// <param name=\"id\">字符串ID</param>\r\n        /// <param name=\"name\">名称</param>\r\n        /// <param name=\"token\">接口访问令牌</param>\r\n        /// <returns>返回字符串值</returns>\r\n        [HttpGet]\r\n        public string TestMulti(string id, string name, string token)\r\n        {\r\n            return string.Format(\"返回结果, id:{0} name:{1}\", id, name);\r\n        }\r\n\r\n        /// <summary>\r\n        /// 参数测试GET返回自定义实体类对象\r\n        /// </summary>\r\n        /// <param name=\"id\">字符串ID</param>\r\n        /// <param name=\"token\">接口访问令牌</param>\r\n        /// <returns>返回自定义实体类对象</returns>\r\n        [HttpGet]\r\n        public virtual CommonResult TestObject(string id, string token)\r\n        {\r\n            return new CommonResult() { Data1 = id, Success = true };\r\n        }\r\n\r\n        /// <summary>\r\n        /// 测试GET返回列表对象\r\n        /// </summary>\r\n        /// <param name=\"token\">接口访问令牌</param>\r\n        /// <returns>返回列表对象</returns>\r\n        [HttpGet]\r\n        public List<string> TestAction(string token)\r\n        {\r\n            List<string> list = new List<string>() { \"123\", \"234\", \"345\" };\r\n            return list;\r\n        }\r\n2）POST方式POST方式，同样也和GET方式的一样，接口参数包括有零或一个参数，以及多个参数的方式，返回的值可以是简单的字符串等基础类型，也可以是复杂的自定义对象类型等，这就是几种常规的接口处理。但是，对于多个参数的接口定义，我们需要对它们进行转换处理，需要使用JObject param的方式进行定义，这样可以很好对多个参数或者自定义的实体类参数进行解析。下面是几种常规的POST接口定义方式。        /// <summary>\r\n        /// 测试使用POST方式提交数据，参数输入为多个，使用JObject处理\r\n        /// </summary>\r\n        /// <returns>返回字符串</returns>\r\n        [HttpPost]\r\n        public string TestPost(JObject param, string token)\r\n        {\r\n            dynamic obj = param;\r\n            string id = obj.id;\r\n            if (obj != null)\r\n            {\r\n                return string.Format(\"返回结果, id:{0}\", id);\r\n            }\r\n            else\r\n            {\r\n                throw new MyApiException(\"传递参数出现错误\");\r\n            }\r\n        }\r\n\r\n        /// <summary>\r\n        /// 测试使用POST方式提交数据，参数输入为多个，使用JObject处理\r\n        /// </summary>\r\n        /// <returns>返回参数计算数值</returns>\r\n        [HttpPost]\r\n        public int TestPostSimple(JObject param)\r\n        {\r\n            dynamic obj = param;\r\n            if (obj != null)\r\n            {\r\n                return obj.x * obj.y * 10;\r\n            }\r\n            else\r\n            {\r\n                throw new MyApiException(\"传递参数出现错误\");\r\n            }\r\n        }    \r\n        \r\n        /// <summary>\r\n        /// 测试POST的方法，方法统一采用JObject param 方式定义，包含一个msg字符串对象，以及一个CListItem对象\r\n        /// </summary>\r\n        /// <returns>返回一个通用的CommonResult对象，包括Data1,Data2,Data3的信息</returns>\r\n        [HttpPost]\r\n        public CommonResult TestPostObject(JObject param)\r\n        {\r\n            dynamic obj = param;\r\n            if (obj != null)\r\n            {\r\n                string msg = obj.msg; //消息对象\r\n                //如果obj.item为类对象，那么需要转换为JObject然后使用ToObject转换为对应类型\r\n                CListItem item = ((JObject)obj.item).ToObject<CListItem>();\r\n\r\n                var result = new CommonResult(true, msg);\r\n                result.Data1 = msg;\r\n                result.Data2 = item.Text;\r\n                result.Data3 = item.Value;\r\n                return result;\r\n            }\r\n            else\r\n            {\r\n                throw new MyApiException(\"传递参数出现错误\");\r\n            }\r\n        }\r\n        /// <summary>\r\n        /// 修改分组，方法统一采用JObject param 方式定义，包括一个字符串对象contactId，一个字符串列表对象groupIdList\r\n        /// </summary>\r\n        /// <returns>返回一个通用的对象</returns>\r\n        [HttpPost]\r\n        public CommonResult TestPostList(JObject param)\r\n        {\r\n            dynamic obj = param;\r\n            if (obj != null)\r\n            {\r\n                string contactId = obj.contactId; //联系人ID\r\n                //如果是List<string>的类似列表，不能直接转换，先转换为JArray后使用ToObject转换为对应列表\r\n                List<string> groupIdList = ((JArray)obj.groupIdList).ToObject<List<string>>();\r\n\r\n                var result = true; //BLLFactory<Address>.Instance.ModifyAddressGroup(contactId, groupIdList);\r\n                return new CommonResult(result);\r\n            }\r\n            else\r\n            {\r\n                throw new MyApiException(\"传递参数出现错误，请检查是否包含了contactId和groupIdList\");\r\n            }\r\n        }\r\n接口类，我们一般把类继承自自己的API接口基类，并对它的异常处理进行处理，以便对错误统一格式回应，如下接口类的代码定义所示。    /// <summary>\r\n    /// 此控制器用来详细介绍各种GET/POST的接口设计\r\n    /// 对于GET方式，方法可以接受多个参数\r\n    /// 对于POST方式，方法如果有参数使用POST方式，统一采用JObject param对象参数。\r\n    /// 如果POST方式有多个参数，如Web API接口加token，则需要客户端把该参数追加在URL上，如url?token=123，然后在使用POST操作\r\n    /// </summary>\r\n    [ExceptionHandling]\r\n    public class TestController : BaseApiController\r\n其中ExceptionHandling是我们的统一异常过滤处理定义，代码如下所示。    /// <summary>\r\n    /// API自定义错误过滤器属性\r\n    /// </summary>\r\n    public class ExceptionHandlingAttribute : ExceptionFilterAttribute\r\n    {\r\n        /// <summary>\r\n        /// 统一对调用异常信息进行处理，返回自定义的异常信息\r\n        /// </summary>\r\n        /// <param name=\"context\">HTTP上下文对象</param>\r\n        public override void OnException(HttpActionExecutedContext context)\r\n        {\r\n            //自定义异常的处理\r\n            MyApiException ex = context.Exception as MyApiException;\r\n            if (ex != null)\r\n            {\r\n                //记录关键的异常信息\r\n                LogHelper.Error(context.Exception);\r\n\r\n                throw new HttpResponseException(new HttpResponseMessage(HttpStatusCode.InternalServerError)\r\n                {\r\n                    //封装处理异常信息，返回指定JSON对象\r\n                    Content = new StringContent(new BaseResultJson(ex.Message, false, ex.errcode).ToJson()),\r\n                    ReasonPhrase = \"Exception\"\r\n                });\r\n            }            \r\n            \r\n            //常规异常的处理\r\n            string msg = string.IsNullOrEmpty(context.Exception.Message) ? \"接口出现了错误，请重试或者联系管理员\" : context.Exception.Message;\r\n            throw new HttpResponseException(new HttpResponseMessage(HttpStatusCode.InternalServerError)\r\n            {\r\n                Content = new StringContent(msg),\r\n                ReasonPhrase = \"Critical Exception\"\r\n            });\r\n        }\r\n    }\r\n3）小程序端代码处理小程序端主要是通过JS代码进行处理，实现数据的获取及提交处理等。如我们列举一个代表性的POST处理代码，如下所示。  //测试POst方法\r\n  wx.request({\r\n    url: 'http://localhost:27206/api/SmallApp/Test/TestPostObject',\r\n    data: { \r\n      msg : '测试内容', \r\n      item: {Text :'Text', Value:'testValue'}\r\n    },\r\n    header: {'Content-Type': 'application/json' },\r\n    method: 'POST',\r\n    success: function (res) {\r\n      console.log(res.data);\r\n    }\r\n  });\r\n而对于GET方式，我们的小程序调用方式如下所示。  getFilms: function(start) {\r\n    console.log('start:' + start);\r\n    var that = this\r\n\r\n    wx.request({\r\n      url: 'http://www.iqidi.com/api/h5/test/movies',\r\n      data: {\r\n        offset: start,\r\n        type: 'hot',\r\n        limit: that.data.limit\r\n      },\r\n      header: {\r\n          'Content-Type': 'application/json'\r\n      },\r\n      success: function (res) {\r\n        console.log(res.data)\r\n\r\n        var data = res.data.data;\r\n        console.log(data);\r\n        if (data.movies.length === 0) {\r\n          that.setData({\r\n            hasMore: false,\r\n            hideLoading :true,\r\n          })\r\n        } \r\n        else {\r\n          that.setData({\r\n            films: that.data.films.concat(data.movies),\r\n            start: that.data.start + data.movies.length,\r\n            hasMore: true,\r\n            hideLoading :true,\r\n          });\r\n        }\r\n      }\r\n    })\r\n以上就是我们常规接口（单个参数或者多个参数，简单对象和复杂对象的处理）的定义代码，希望读者在开发Web API接口的时候，可以有所帮助。"}
{"title": "微信小程序 - 如何通过button按钮实现分享（转发）功能 ", "author": "Rolan", "pub_time": "2018-8-14 00:34", "content": "小程序官方APIhttps://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html#%E9%A1%B5%E9%9D%A2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0 有两种方式，一种是页面内按钮分享，一种是菜单转发. 1.页面内按钮分享 可以自定义以下内容  wxml js  2.菜单分享"}
{"title": "javascript/微信小程序中将String进行Base64编码并UTF-8格式输出 ", "author": "Rolan", "pub_time": "2017-7-10 00:55", "content": "提供一种Base64编码,并输出UTF-8格式的BASE64编码方式。本程序在微信小程序开发工具中已经测试通过。Base64代码：[javascript] view plain copy print?(function(){      var BASE64_MAPPING = [          'A','B','C','D','E','F','G','H"}
{"title": "微信小程序 - 多地点标识(map) ", "author": "Rolan", "pub_time": "2018-9-3 00:21", "content": "演示如下：wxml1 <map id=\"map\"  scale=\"{{scale}}\" controls=\"{{controls}}\" bindcontroltap=\"controltap\" markers=\"{{markers}}\" bindmarkertap=\"markertap\" bindregionchange=\"regionchange\" show-location style=\"width: 100%; height: 580px;\"></map>js  1 let hospitalData = require('hospitalData')  2 Page({  3   data: {  4     centerX: 0.0,  5     centerY: 0.0,  6     //可能我标识的地点和你所在区域比较远，缩放比例建议5;  7     scale:15,  8     markers: [],  9     controls: [{ 10       id: 1, 11       iconPath: '/image/location-control.png', 12       position: { 13         left: 0, 14         top: 10, 15         width: 40, 16         height: 40 17       }, 18       clickable: true 19     }] 20   }, 21   onReady: function(e) { 22     // 使用 wx.createMapContext 获取 map 上下文  23     this.mapCtx = wx.createMapContext('myMap') 24   }, 25  26   onLoad: function() { 27     console.log('地图定位！') 28     let that = this 29     wx.getLocation({ 30       type: 'gcj02', //返回可以用于wx.openLocation的经纬度 31       success: (res) => { 32         let latitude = res.latitude; 33         let longitude = res.longitude; 34         let marker = this.createMarker(res); 35         this.setData({ 36           centerX: longitude, 37           centerY: latitude, 38           markers: this.getHospitalMarkers() 39         }) 40       } 41     }); 42   }, 43  44   /** 45    * 标示点移动触发 46    */ 47   regionchange(e) { 48     console.log(e.type) 49   }, 50  51   /** 52    * 点击标识点触发 53    */ 54   markertap(e) { 55     console.log(e) 56   }, 57  58   /** 59    * control控件点击时间 60    */ 61   controltap(e) { 62     console.log(e.controlId) 63     this.moveToLocation() 64   }, 65  66  67   /** 68    * 获取医院标识 69    */ 70   getHospitalMarkers() { 71     let markers = []; 72     for (let item of hospitalData) { 73       let marker = this.createMarker(item); 74       markers.push(marker) 75     } 76     return markers; 77   }, 78  79   /** 80    * 移动到自己位置 81    */ 82   moveToLocation: function() { 83     let mpCtx = wx.createMapContext(\"map\"); 84     mpCtx.moveToLocation(); 85   }, 86  87  88   /** 89    * 还有地图标识，可以在name上面动手 90    */ 91   createMarker(point) { 92     let latitude = point.latitude; 93     let longitude = point.longitude; 94     let marker = { 95       iconPath: \"/image/location.png\", 96       id: point.id || 0, 97       name: point.name || '', 98       latitude: latitude, 99       longitude: longitude,100       width: 25,101       height: 48102     };103     return marker;104   }105 })hospitalData.js （模拟数据） 1 module.exports = [{ 2     \"id\": 1, 3     \"name\": \"永州市中心医院\", 4     \"longitude\": \"111.62852107566833\", 5     \"latitude\": \"26.42142999357519\" 6   }, 7   { 8     \"id\": 2, 9     \"name\": \"永州市中医院\",10     \"longitude\": \"111.5972679762268\",11     \"latitude\": \"26.44470581245983\"12   }13 ]运行示例时，建议放在同一目录下."}
{"title": "微信小程序简单收集formid无限次发送模板消息 ", "author": "Rolan", "pub_time": "2017-12-4 00:18", "content": "消息通知对于某些应用是非常有用的，APP发送消息通知基本是没有限制的，而微信小程序是通过微信的模板消息通知实现的，微信模板消息目前来看还是通知非常有效，不存在垃圾信息过多的问题，还可以通过点击消息直接进入应用详细。如下图所示但是，为了防止应用乱发通知，小程序做了一些限制，只有两种方法可以给用户发送模板消息，一是用户支付后可发送3条模板消息；二是页面发生一次提交表单行为可发送1条模板消息，而且有个期限是7天内。如果某些应用需要多次发送模板消息怎么办呢？比如最近我们做的一个项目，涉及到多人物物交换，如果一个人发布了一个物品，可能收到多个人的交换请求，而如果交换请求不通过模板消息推送给用户的话，那么这个应用就是缺失的。7天内无限次发送模板消息的做法很简单，就是根据“提交1次表单可推送1条模板消息，多次提交表单之间是相互独立的”这个规则，只要在小程序前端，收集足够多的formid就行了。比如把用户所有的点击都做成form表单提交，把想要的链接做成表单提交。但在实际操作中会遇到以下问题，因为只有button组件才能提交表单，如果要把文字链接和图片按钮做成表单提交，需要在上面套一个form和button组件，如下代码而button组件在小程序里是有默认样式的，你会发觉样式变得非常难看，如下图。本来样式是这样的加了form和button组件后变成了这样如何解决呢？最好的方式就是通过CSS定义覆盖原有button的样式。于是，我们程序员写出了通用的代码，适用于整个小程序。button.form_button{background-color:transparent;padding:0;margin:0;display:inline;position:static;border:0;padding-left:0;padding-right:0;border-radius:0;font-size:0rpx;color:transparent;}button.form_button::after{content:'';width:0;height:0;-webkit-transform:scale(1);transform:scale(1);display:none;background-color:transparent;}有个小问题需要注意一下，就是原来传递的data数据需要加在form上面。然后剩下的问题就是后台把收集到的formid都上传到后台服务器保存，同时记录过期时间。服务器最好有个定时删除过期formid的功能，增加查找可用formid的速度。后台发送模板消息的功能实现这里就不多说了，可以参考官方文档。"}
{"title": "微信小程序隐藏客服按钮，用图片替代&增加提示卡片可随时关闭。 ... ", "author": "Rolan", "pub_time": "2018-7-9 00:30", "content": "如图，本次案例要做的是右下角的客服按钮和蓝色渐变的提示卡片，可随时关闭的。微信官方给了客服按钮标签<contact-button type=\"default-dark\" size=\"100\"></contact-button>这个标签的样式不可修改，如果我们要换自己想改的图片，需要怎么做呢？就像我图片上的样式。我这个客服控件是放在一个正圆的view里的居中位置，所以，我这里先通过position定位到居中位置，把size放到最大。然后把透明度设置为0即可，然后给正圆这个view设置一图片背景，图片就是你想要显示的icon提示卡片提示卡片是一个view，view里面有一个×用来绑定隐藏事件的，bindtap=\"onChangeShowState\"就是用来隐藏这个view的index.wxml<!-- 提示卡片 -->\r\n<view class=\"bright789_view_hide{{showView?'bright789_view_show':''}}\">\r\n  <view class=\"bright789-text\">\r\n      <view bindtap=\"onChangeShowState\" class=\"close\">×</view>\r\n      <view class=\"text\">有疑问可以点这里咨询哦</view>\r\n  </view>\r\n</view>\r\n<!-- 悬浮按钮 -->\r\n<view class=\"zixun\"><contact-button type=\"default-dark\" size=\"100\" class=\"kf\"></contact-button></view>index.wxss.zixun{\r\n  width: 55px;\r\n  height: 55px;\r\n  background: url(http://wxpad.cn/yunpan/cdn/imgsrc/1530949769.png)no-repeat;\r\n  position: fixed;\r\n  bottom: 35px;\r\n  right: 35px;\r\n  border-radius: 50%;\r\n  box-shadow: 0 0 5px #ddd;\r\n  text-align: center;\r\n  font-size: 14px;\r\n  color: #333;\r\n}\r\n\r\n.zixun .kf{\r\n  position: relative;\r\n  top: 0px;\r\n  left: 0px;\r\n  margin:15px auto;\r\n  opacity: 0;\r\n}\r\n\r\n.bright789-text{\r\n  position: fixed;\r\n  bottom: 100px;\r\n  right: 65px;\r\n  width: 200px;\r\n  height: 45px;\r\n  background-image: linear-gradient(to left, #4481eb 0%, #04befe 100%);\r\n  border-bottom-left-radius: 50px;\r\n  border-top-left-radius: 50px;\r\n  border-top-right-radius: 50px;\r\n  z-index: 99999999;\r\n  box-shadow: 0 0 10px #eee;\r\n  line-height: 40px;\r\n  text-indent: 15px;\r\n}\r\n\r\n.bright789-text .close{\r\n  font-size: 1.5em;\r\n  color: #fff;\r\n}\r\n\r\n\r\n.bright789-text .text{\r\n  font-size: 13px;\r\n  color: #fff;\r\n  margin-top: -38px;\r\n  margin-left: 20px;\r\n}\r\n\r\n.bright789_view_hide{\r\n    display: none;\r\n}index.js//index.js\r\n//获取应用实例\r\nconst app = getApp()\r\nPage({\r\n  data: {\r\n    showView: true\r\n  },\r\n\r\nonLoad: function (options) {\r\n  // 生命周期函数--监听页面加载\r\n  showView: (options.showView == \"true\" ? true : false)\r\n},\r\nonChangeShowState: function () {\r\n  var that = this;\r\n  that.setData({\r\n    showView: (!that.data.showView)\r\n  })\r\n }\r\n})OK，制作完成！作者：TANKING"}
{"title": "微信小程序之表单校验 ", "author": "Rolan", "pub_time": "2017-8-23 00:33", "content": "小程序SDK版本 1.4表单校验之难如果要问微信小程序最难实现的公共业务是什么？应该是表单校验，没有之一。原因如下：表单组件在数量上达到11个，居各类组件之首。当然幸运的是，并不是所有的都需要校验。而这些组件操作方式多样，可分为滑动、（多行）输入、点击、点击+滑动。即使是同一个组件，因为业务场景不同就会有不同的校验规则。更麻烦的是，这些组件之间经常还会联动或者关联校验。…但是，作为一个非简单静态页面，有着较多用户交互的小程序，表单校验又是一个非常常用的功能：登录、注册、新增、编辑…总而言之：表单组件的多样性 X 校验规则的多样性 = 复杂的公共业务这么棘手的问题我们怎么来解决它呢？尝试组件化如果你关注近年前端发展趋势，一定会想到“组件化”来实现：把每个表单组件的视图、样式、校验逻辑封装成单独的业务组件，然后直接调用。可事情似乎没这么简单。如果考虑把n个原生组件抽象出来，配上n个校验规则，再乘以组件之间的关系n（的全排列），复杂度至少达到n³。而且每个组件的校验失败或成功都要通知父组件，以便显示错误信息或者进行下一步操作。这样不但没有解决问题，反而使得这些公用的表单组件过于复杂，耦合混乱。尝试非组件化既然原先的思路行不通，再来回到出发点，看看我们最核心的需要被抽象出来的是什么。无非是两样东西：视图层的元素样式和逻辑层的校验规则。上面说到封装原生表单组件会极大的增加复杂度，索性放弃它，复杂度瞬间可以下降到n²。但同时我们又要保持样式统一，也就是我们常说的风格一致。比如输入框该多高，错误提示怎么显示，字体大小颜色…之类的。这个好办，我们把样式类写入一个公共样式文件form.wxss，然后需要的时候引入，甚至可以全局引入。这个好办，我们把样式类写入一个公共样式文件form.wxss，然后需要的时候引入，甚至可以全局引入。// form.wxss.form {  display: block;  font-size: 28rpx;  position: relative;}.form-line {  background-color: #fff;赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\nsuperinfo\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              【微信小程序】自定义模态对话框实例 \n              小程序实战--天气预报 \n            \n             \n            \n                  原作者: 联盟博主--亚里士朱德  \n                  来自: github \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 跟着小猪来做小程序开发：表单\n                                    \n                  • 微信小程序开发－form 表单提交和取值\n                                    \n                  • 微信小程序开发—表单组件\n                                    \n                  • 微信小程序开发—表单验证\n                                    \n                  • 微信小程序表单验证错误提示\n                                    \n                  • 微信小程序开发常用方法\n                                    \n                  • 小程序页面之用户身份校验\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSVU64Fr', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n推荐阅读\r\n\r\n\r\n微信小程序开发早知道2019-04-04微信小程序上线“页面收录”功能，真正的SE2019-04-04小程序侵权“生死局”2019-04-04微信小程序搭建mpvue+vant+flyio2019-04-04微信小程序自定义导航栏2019-04-08使用weixin-java-miniapp配置进行单个小程2019-04-04全国首例微信小程序侵权案已判决，腾讯要承2019-04-08微信小程序ad自适应布局2019-04-08从产品角度，看小程序的设计2019-04-09我的前端规范系列-高清屏适配[按标准来就行2019-04-09\r\n\r\n\r\n最新Demo\r\n\r\n\r\n“坦白言”社交类型分享裂变小程序开源2019-04-08AI驾驶行为检测DEMO2019-04-05弹幕微信小程序Demo2019-04-050.02019-04-02小程序组件常用组件分享2019-04-02性格测试小程序2019-04-01小程序登录Demo2019-03-26想做一个微信论坛项目2019-03-25新版答题小程序2019-03-21需要一个搬家下单的小程序2019-03-20\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880735|4758e99b13b849d783b1163f7706ba01|2';"}
{"title": "微信小程序 选项卡demo ", "author": "天下雪", "pub_time": "2017-4-14 00:00", "content": "———-demo.wxss————.swiper-tab{      width: 100%;      border-bottom: 2rpx solid #777777;      text-align: center;      line-height: 80rpx;}  .swiper-tab-list{  font-size: 30rpx;      display: inline-block;      width: 33.33%;      color: #777777;  }  .on{ color: #da7c0c;      border-bottom: 5rpx solid #da7c0c;}  .swiper-box{ display: block; height: 100%; width: 100%; overflow: hidden; }  .swiper-box view{      text-align: center;  }  ———-demo.wxml————<view class=\"swiper-tab\">      <view class=\"swiper-tab-list {{currentTab==0 ? 'on' : ''}}\" data-current=\"0\" bindtap=\"swichNav\">哈哈</view>      <view class=\"swiper-tab-list {{currentTab==1 ? 'on' : ''}}\" data-current=\"1\" bindtap=\"swichNav\">呵呵</view>      <view class=\"swiper-tab-list {{currentTab==2 ? 'on' : ''}}\" data-current=\"2\" bindtap=\"swichNav\">嘿嘿</view>  </view>  <swiper current=\"{{currentTab}}\" class=\"swiper-box\" duration=\"300\" style=\"height:{{winHeight - 31}}px\" bindchange=\"bindChange\">      <!-- 我是哈哈 -->      <swiper-item>        <view>我是哈哈</view>      </swiper-item>      <!-- 我是呵呵 -->      <swiper-item>        <view>我是呵呵</view>      </swiper-item>      <!-- 我是嘿嘿 -->      <swiper-item>        <view>我是嘿嘿</view>      </swiper-item>  </swiper>  ———-demo.js————Page( {    data: {      /**         * 页面配置         */      winWidth: 0,      winHeight: 0,      // tab切换      currentTab: 0,    },    onLoad: function() {      var that = this;      /**      * 获取系统信息      */      wx.getSystemInfo( {        success: function( res ) {          that.setData( {            winWidth: res.windowWidth,            winHeight: res.windowHeight          });        }      });    },    /**      * 滑动切换tab      */    bindChange: function( e ) {      var that = this;      that.setData( { currentTab: e.detail.current });    },    /**    * 点击tab切换    */    swichNav: function( e ) {      var that = this;      if( this.data.currentTab === e.target.dataset.current ) {        return false;      } else {        that.setData( {          currentTab: e.target.dataset.current        })      }    }  })"}
{"title": "微信小程序入门实例：navbar、swiper 应用 ", "author": "天下雪", "pub_time": "2017-4-21 00:27", "content": "作者：xiaochun365，来自原文地址一：swiper 应用//jsvar imgUrls = [    { image: \"http://img02.tooopen.com/images/20150928/tooopen_sy_143912755726.jpg\" },    { image: \"http://img06.tooopen.com/images/20160818/tooopen_sy_175866434296.jpg\" },    { image:赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\nsunjiaru\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序开发－form 表单提交和取值 \n              小程序第三方平台初体验（下） \n            \n             \n            \n                   \n                   \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序快速开发-食堂菜单案例\n                                    \n                  • 微信小程序实例--洗衣小程序开发经验分享\n                                    \n                  • 微信小程序实例--知乎日报小程序\n                                    \n                  • 微信小程序实例-- 电影影评小程序\n                                    \n                  • 微信小程序-自定义NavBar组件（1）\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSB5LJle', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n微信小程序开发早知道2019-04-04\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880735|4758e99b13b849d783b1163f7706ba01|2';"}
{"title": "微信小程序带搜索记录的输入框 -- setStorageSync ", "author": "Rolan", "pub_time": "2018-3-8 00:23", "content": "在最近的项目里有一个需求，就是需要一个带搜索记录的输入框，但是不需要用到后台，就想到了使用本地缓存setStorageSync。总结一下需要注意的点：1、按搜索时间倒序。unshift：在数组前面插入数据，并改变数组。2、搜索内容前后添加了空格的时候。string.trim();//去掉前后空格3、最多缓存多少条搜索记录。// 如果超过8条搜索记录的话，删掉最旧的一条if (searchData.length >= 8)searchData.pop();//pop：删除数组最后一个元素。4、输入了搜索记录已经有了的内容。//先删除搜索记录里面的，再添加元素到第一位// 如果搜索记录里面有重复的，要做删除操作for (let i = 0; i < searchData.length; i++) {  if (searchData[i] == this.data.inputValue.trim()){    searchData.splice(i,1);    break;  }} // 添加搜索记录 searchData.unshift(inputValue.trim());github地址：https://github.com/chenweihuan/searchHaveHistory只上传了关键代码，如有bug请查看修改一下，问题应该不大。"}
{"title": "微信小程序历险记：表单取值为字符串，生命周期，bindtap事件遇上bindtouchend事件，b ... ", "author": "天下雪", "pub_time": "2017-4-14 00:12", "content": "分享者：meahu，来自原文地址一：表单取值为字符串input 有这样的事件：bindinput、bindfocus、bindblur、bindconfirm，通过这些事件能拿到表单的相关信息。 如function bindinput(e){    var number = e.detail.value;    console.log(number>80);},通过 e.detail.value 拿到的值是字符串类型，当拿它来直接进行数值大小比较时，奇迹就发现了。 当在表单输入，1、10、50。诶，你会发现正常。控制台打印false 然而当在表单输入9，奇迹就出现了！控制台打印 true 原因呢？表单输入虽然是数字，但 number 取到的值是字符串导致。比较也就是进行字符串比较了，’9’自然比’80’大。 所以，对于数值比较，需先使用 parseInt 进行处理再比较。二：生命周期小程序退出后，没有直接销毁，而是进入了后台；只有当小程序进入后台一定时间（大于15分钟），或者系统资源占用过高，才会被真正的销毁。在小程序没被销毁前，再次打开小程序时，打开的是退出的页面。 红米3退出小程序15分钟后进入时还没被销毁，进入的是退出的页面。 如果有每次进入小程序都是首页的需求，可以在小程序进入后台时跳转回首页。三：bindtap事件遇上bindtouchend事件，bindtouchend事件先触发现有某元素同时绑定了两个事件：bindtap、bindtouchendwxml：<view bindtouchend=\"touchend\" bindtap=\"tap\">事件之旅1</view><view bindtouchend=\"touchend\">    <view bindtap=\"tap\">事件之旅2</view></view><view bindtap=\"tap\">    <view bindtouchend=\"touchend\">事件之旅3</view></view>js：touchend: function(e){    console.log('touchend事件');}tap: function(e){    console.log('tap事件');}接下来，我们来点击这些文字，不管是事件之旅1、事件之旅2、事件之旅3，都会是 touchend 事件先触发，先打印“touchend 事件”，后打印“tap事件”。为什么呢？我的理解是这样：我们对该元素的动作是手指触摸，手指离开。而手指离开就是手指触摸动作结束（触发了 touchend 事件），然后计算该动作是否为长按，不是长按触发了 tap 事件。"}
{"title": "半天就能上手的小程序——选择器多级联动 ", "author": "Rolan", "pub_time": "2017-5-19 08:21", "content": "近段时间由于一直沉迷王者农药无法自拔，在这先自我检讨...首先说下今天要做的需求：如下图，是前段时间给APP中添加的客诉功能。iOS.gif能看到，里面涉及到了选择器多级联动（这里就两级）。然而，上星期三的时候接手了公司的小程序，说是小程序，其实也就两三个页面，要我把APP上的功能加上去，其中包括这个“我要投诉”的页面，综合了下安卓的选择器效果，下面看小程序上做出后的效果如下图：小程序.gi先大致说下这个页面的所需文件，所需文件.png是的，小程序的每个页面都需要.js/.json/.wxml/.wxss文件，就像前端 \"三剑客\"一样，这里是四剑客，但.json其实也是可有可无的，本质上还是三剑客...关于小程序的话题不多说了，对小程序感兴趣的可以私信我讨论哈。下面开始装X。先从布局UI开始，也就是 .wxml 和 .wxss（只给出多级联动的部分）先从布局UI开始，也就是 .wxml 和 .wxss（只给出多级联动的部分）.wxml     class=\"section\" >           style=\"   display : flex;flex-direction : row;\">         class=\" text\">选择购买门店: bindtap=\"cascadePopup\" style= \" color: #393939;font-size: 32rpx;margin-top : 2px; margin-left:8px;\">{{areaSelectedStr}}>                 style= \" color: #393939;font-size: 32rpx;margin-top : 4px;margin-left:114px;\">{{detailAddress}}     //选择器     class=\"modal\">     class=\"modal-mask {{maskVisual}}\" bindtap=\"cascadeDismiss\">     animation=\"{{animationData}}\" class=\"modal-content\">         class=\"modal-header\">             class=\"modal-title\">请选择门店             class=\"modal-close\" bindtap=\"cascadeDismiss\">X                 class=\"modal-body\">             class=\"viewpager-title {{current == 0 ? 'area-selected' : ''}}\" bindtap=\"changeCurrent\" data-current=\"0\">{{areaName}}             class=\"viewpager-title {{current == 1 ? 'area-selected' : ''}}\" bindtap=\"changeCurrent\" data-current=\"1\">{{shopName}}             class=\"viewpager-title {{current == 2 ? 'area-selected' : ''}}\" bindtap=\"changeCurrent\" data-current=\"2\">{{detailAddress}}             class=\"viewpager-divider\">             class=\"swiper-area\" current=\"{{current}}\" bindchange=\"currentChanged\">                 wx:if=\"{{area_arr.length > 0}}\">                                             scroll-y=\"true\" class=\"viewpager-listview\">                             wx:for=\"{{area_arr}}\" wx:key=\"index\" data-index=\"{{index}}\" bindtap=\"areaTapped\">                                 wx:if=\"{{index == areaIndex}}\" class=\"area-selected\">{{item}}                                 wx:else>{{item}}                                                    赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序表单验证错误提示 \n              微信小程序 通过控制CSS实现view隐藏与显示 \n            \n             \n            \n                  原作者: APP叫我取个帅气的昵称 \n                   \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序三级联动地址选择器\n                                    \n                  • 微信小程序上手项目-星座配对\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSVlG4A6', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n微信小程序开发早知道2019-04-04\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880735|4758e99b13b849d783b1163f7706ba01|2';"}
{"title": "微信小程序删除处理 ", "author": "Rolan", "pub_time": "2017-7-18 00:10", "content": "没有 confrim 那怎么实现这个效果呢 可以使用小程序里的模态框 代码：wxml：<a class=\"reply\" wx:if=\"{{comment.uid==comment.login_uid}}\" bindtap=\"del\" data-cid=\"{{comment.c_id}}\">删除</a>js：    del:function(e){      var that = this;      wx.showModal({        title: '提示',        content: '确定要删除吗？',        success: function (sm) {          if (sm.confirm) {            // 用户点击了确定 可以调用删除方法了            wx.request({              url: 'https://m.*****.com/index.php/Home/Xiaoxxf/home_comment_del?c_id=' + e.currentTarget.dataset.cid,    //删除房间评论              data: '',              header: {                'Content-Type': 'application/json'              },              method: 'GET',              success: function (res) {                console.log(res);                wx.showToast({                  title: res.data,  //数据返回提示，查看后台PHP                  icon: 'success',                  duration: 2000                })                /* 获取房间评论信息  -xzz 0714*/                getList(that);              },              fail: function (res) { },              complete: function (res) { },            })          } else if (sm.cancel) {          }        }      })    }效果：这样就实现js的confirm效果了。"}
{"title": "微信小程序中下拉刷新和数据绑定的一些小坑 ", "author": "Rolan", "pub_time": "2017-12-12 00:20", "content": "前言最近10几天都在学习小程序的开发，遇到了一些问题和笔记有趣的东西，今天总结了一下，和大家分享1.小程序中的template模块使用在一个月黑风高的夜晚，我突然发现一个很有意思的东西，那就是template模块，它可以将你定义的一个HTML5模块包住，然后利用template，在你的小程序任意一个页面使用，这样极大的减少了程序中的复制-粘贴，复制-粘贴(一般用于需要循环使用的界面)。下面就用我自己的一个template模块来讲解下。第一步：创建页面在pages里面创建存储你template模块的页面，便于其他页面对其的引用\"pages/index/index\",\r\n\"pages/find/find\",\r\n\"pages/gift/gift\",\r\n\"pages/activity/activity\",\r\n\"pages/common/list\",//存储template模块的页面\r\n\"pages/white/white\"\r\n第二步：创建template模块template模块实例\r\n<template name=\"job_list\">\r\n <view class=\"br\"></view>\r\n <navigator url=\"../white/white\" class=\"page_appmsg\">  //点击跳转\r\n        <view class=\"page\">\r\n                <view class=\"page__hd \">\r\n                    <image class=\"page__thumb\" src=\"{{image}}\" mode=\"aspectFill\"/>\r\n                    <view class=\"page__hd_title\">\r\n                        <view class=\"page__hd_title title\">{{title}}</view>\r\n                        <view class=\"page__hd_title school\">{{school}}</view>\r\n                        <view class=\"page__hd_title request\">\r\n                            <text class=\"page__hd_title pink\">{{pink}}</text>\r\n                            <text class=\"page__hd_title time\">{{time}}</text>\r\n                            <view class=\"page__hd_title cool\"><i class=\"iconfont icon-zan1 active\"></i>{{cool}}</view>\r\n                        </view>\r\n                    </view>\r\n                </view>   \r\n                <view class='page__ft'>\r\n                 <i class=\"iconfont icon-jian-copy active\"></i>{{page__ft}}}\r\n                </view>\r\n        </view>\r\n</navigator>\r\n</template>在你需要重复使用的html用一个<template>标签包起来，并给它取个名字 。（当然了，还有WXSS的编写，这里因为不是很重要我就不放出来了）完成了这步，你就可以尽情的在你需要这个模板的页面引用这个模块了。第三步：在各个页面引用template模块①在你想要引用的界面的WXSS和WXML上引用template的wxml和wxss，@import '../common/list.wxss';\r\n<import src=\"../common/list.wxml\" />②在你需要的盒子里面添加template标签，你想要引用那个template模块，就在is里面填哪个模块的名字<template is=\"job_list\" data=\"{{jobs}}\"/>如果你是在一个循环里面引用的template就需要改为data=\"{{...item}}\"如：        <block wx:for=\"{{jobs}}\" wx:key=\"{{index}}\">\r\n            <template is=\"job_list\" data=\"{{...item}}\"/>\r\n        </block>代码：<import src=\"../common/list.wxml\" />\r\n<view class=\"swiper-tab\">\r\n    <view class=\"swiper-tab-item {{activeIndex==0?'active':''}}\" data-current=\"0\" bindtap=\"clickTab\">活动</view>\r\n    <view class=\"swiper-tab-item {{activeIndex==1?'active':''}}\" data-current=\"1\" bindtap=\"clickTab\">视频</view>\r\n    <view class=\"swiper-tab-item {{activeIndex==2?'active':''}}\" data-current=\"2\" bindtap=\"clickTab\">直播</view>\r\n</view>\r\n<swiper current='{{activeIndex}}' bindchange=\"swiperTab\">\r\n    <swiper-item>\r\n        <view class=\"swiper-item__content\">\r\n            <block wx:for=\"{{jobs}}\" wx:key=\"{{index}}\">\r\n                <template is=\"job_list\" data=\"{{...item}}\"/>\r\n            </block>\r\n        </view>\r\n    </swiper-item>\r\n    <swiper-item>\r\n            <view class=\"swiper-item__content\">\r\n                    <block wx:for=\"{{jobs}}\" wx:key=\"{{index}}\">\r\n                        <template is=\"job_list\" data=\"{{...item}}\"/>\r\n                    </block>\r\n                </view>\r\n    </swiper-item>\r\n    <swiper-item>\r\n            <view class=\"swiper-item__content\">\r\n                    <block wx:for=\"{{jobs}}\" wx:key=\"{{index}}\">\r\n                        <template is=\"job_list\" data=\"{{...item}}\"/>\r\n                    </block>\r\n                </view>\r\n    </swiper-item>\r\n</swiper>效果图： 2.数据绑定又是一个月黑风高的夜晚，我在实现点亮的功能的时候，发现我只点了一个地方的点赞，整个页面的点赞都亮了起来，这肯定是不行的，用户明明只对这一个感兴趣，你怎么能全部点亮呢？于是我开始了思考，发现我犯了一个十分愚蠢的问题，那就是没有给我的数据绑定一个值，这就好像没有给喊名字一样：到了饭点你出去大喊一声:儿子,回家吃饭了!结果肯定是家家的儿子都回去吃饭了，然而别人家的饭都还没开始煮呢，你怎么就喊人家回去了呢，你肯定得喊：二狗子，回家吃饭了！别人家的娃才不会也跟着回家。这和点击事件是一个道理的，你必须给你的每项数据绑定一个id，用if语句，将数组遍历一遍，将每个数据的ID拿出来看看，看下你点的这个数据的ID，与数组中哪个相符合。如何成功配对了 ，恭喜，你可以执行点亮操作了！功能实现如下：wxml<a wx:if=\"{{!item.isSelected}}\" id=\"dianzan1\" data-id = \"{{item.id}}\"bindtap=\"cool\">\r\n<i class=\"iconfont icon-dianzan1 active\"></i><a wx:if=\"{{item.isSelected}}\" id=\"dianzan1\" data-id = \"{{item.id}}\"bindtap=\"cool\">\r\n<i class=\"iconfont icon-dianzan1-copy active\"></i>在数据中，我不仅给了它一个ID，还给了它一个布尔值，并且全部定为false，这样便可以通过wx:if=\"{{!item.isSelected}}\" wx:if=\"{{item.isSelected}}\" 来判断展示的是点亮与否。js  cool:function(e) {\r\n     let jobs = this.data.jobs\r\n     for(let key in jobs){                       // 遍历一遍数据\r\n      // console.log(jobs[key].id);           \r\n                                         //将界面的数据与jobs的数据进行匹配\r\n       if (jobs[key].id === e.currentTarget.dataset.id){ \r\n         if (!jobs[key].isSelected){             //处于未点亮状态时的操作\r\n           jobs[key].isSelected = true;\r\n           wx.showToast({\r\n             title: '点赞成功',\r\n             icon: 'success',\r\n             duration: 1500,\r\n           })    \r\n         }else{                                 //处于点亮时的操作\r\n           jobs[key].isSelected = false;\r\n           wx.showToast({\r\n             title: '取消点赞',\r\n             icon: 'success',\r\n             duration: 1500,\r\n           })\r\n         }       \r\n       }\r\n     }\r\n     this.setData({                             // 将界面更新\r\n       jobs : jobs,\r\n     });\r\n  \r\n   }, \r\n\r\n效果图3.下拉刷新触发过多问题又是一个月黑风高的夜晚，我突然发现了一个bug！在小程序下拉刷新时，我明明只加了一组数据，然而却刷出来了2到3组数据，（这里我使用的是scroll-view组件的bindscrolltolower属性）吓得我赶紧回去看了一波代码，如下：赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (2)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (2 人)\r\n\r\n\r\n\r\n\r\n你行你BB\r\n\r\n\r\n\r\n忘幽\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序实现各种特效实例 \n              小程序tabBar跳转页面并隐藏tabBar \n            \n             \n            \n                  原作者:  高枫 \n                  来自: sf \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序-template模版\n                                    \n                  • 微信小程序 template添加绑定事件\n                                    \n                  • 微信小程序template模板使用\n                                    \n                  • 微信小程序-template模板使用详解\n                                    \n                  • 微信小程序template使用\n                                    \n                  • 扒一扒小程序的坑\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSQi7da3', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n给媳妇做一个记录心情的小程序2019-03-22微信小程序开发中的代码片段总结2019-03-22小程序自定义单页面、全局导航栏2019-03-15微信，支付宝小程序实现原理概述2019-03-25Natsuha - 用Taro写个天气微信小程序2019-03-12mpvue开发音频类小程序踩坑和建议2019-03-12微信单页应用的那些事2019-03-13微信小程序框架wepy踩坑记录（与vue对比）2019-03-12如何使用微信小程序云函数发送短信验证码2019-03-13\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n“坦白言”社交类型分享裂变小程序开源2019-04-08AI驾驶行为检测DEMO2019-04-05弹幕微信小程序Demo2019-04-05小程序组件常用组件分享2019-04-02性格测试小程序2019-04-01小程序登录Demo2019-03-26想做一个微信论坛项目2019-03-25新版答题小程序2019-03-21小程序组件常用组件分享2019-03-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880735|4758e99b13b849d783b1163f7706ba01|2';"}
{"title": "微信小程序url，token设置 ", "author": "catsForest", "pub_time": "2017-9-23 14:15", "content": "新浪云应用sae的代码里创建一个weixin.php文件，写入以下代码define(\"TOKEN\",\"myToken\");// 后台填写的token，在微信公众平台启用$wechatObj = new wechatAPI();$wechatObj->isValid();class wechatAPI{    public function isValid()//验证微信接口，验证函数以外的代码和微信公众号开发token设置相同    {         $echoStr = $_GET[\"echostr\"];         if ($this->checkSignature()) {             header('content-type:text');//add，一定要加入header           echo $echoStr;           exit;         }    }    private function checkSignature()   //官方的验证函数    {         $signature = $_GET[\"signature\"];         $timestamp = $_GET[\"timestamp\"];         $nonce = $_GET[\"nonce\"];         $token = TOKEN;         $tmpArr = array($token, $timestamp, $nonce);         sort($tmpArr, SORT_STRING);         $tmpStr = implode( $tmpArr );         $tmpStr = sha1( $tmpStr );         if( $tmpStr == $signature ){           return true;         }else{           return false;         }    }};保存后通过url访问，在地址栏复制url，写入微信公众平台中在微信公众平台的开发设置中，填入以上获得的url和设置的token，自动生成EncodingASEKey设置完成"}
{"title": "微信小程序填坑记录 ", "author": "Rolan", "pub_time": "2017-9-7 00:08", "content": "在wxml文件中使用text标签时内容不能与标题对齐的问题  <view class=\"mod t-sign-time\">\r\n          <text>商品条码</text>\r\n          <text class=\"value\">\r\n          67882932222222222</text>\r\n  </view>\r\n微信编译器识别到text中含有空行导致。修改如下:  <view class=\"mod t-sign-time\">\r\n          <text>商品条码</text>\r\n          <text class=\"value\">67882932222222222r33ddfdfdfdf</text>\r\n </view>\r\n文本无法居中当设置display为inline-block时，遇到文本内容设置text-align: center始终无法居中的问题。虽然设置display: flex可以解决文本居中的问题，但整体View上的多个控件布局会乱。最后设置，line-height: 31px;\r\n解决问题。(其中，31px为该视图控件的"}
{"title": "支付宝小程序框架浅析及如何在 mPaaS 内深度集成 ", "author": "Rolan", "pub_time": "2018-12-3 00:01", "content": "本文将结合阔悬在 iWeb 杭州站沙龙现场的分享《支付宝小程序在 mPaaS 中的深度集成实践》，介绍支付宝小程序框架的设计原理，以及如何在 mPaaS 体系中的深度集成支付宝小程序。分享内容将从以下两个方面展开：支付宝小程序框架的系统介绍 （支付宝小程序框架概述、应用层框架、Native SDK）mPaaS 技术架构与助力 （mPaaS 小程序、mPaaS 小程序 IDE、mPaaS MDS）2. 小程序简介：移动互联网新热点近来，小程序俨然成为了移动互联网的新热点。继 2017 年初微信正式推出微信小程序后，各个大厂陆续发布了各自的小程序 —— 支付宝小程序、百度小程序、头条小程序，小程序成为了各家移动互联网生态布局的重要一环。通过小程序生态可以引入大量的外部服务，不仅丰富了平台的能力，而且可以为平台带来大量的用户流量，从而使得平台具备无限的潜能。3. 支付宝小程序简介支付宝小程序是一种全新的开发模式，它运行在支付宝客户端，可以被便捷地获取和传播，为终端用户提供更优的用户体验。为方便小程序的开发者，支付宝小程序具有类似微信小程序的 DSL 和开发环境，降低小程序开发者的学习成本。4. 支付宝小程序框架浅析1. 基础需求小程序的本质需求是让第三方开发者可以接入，使得第三方开发的小程序可以在平台级应用中运行。对于这个需求，最简单的实现方案是：让外部开发者开发纯 H5 应用，在应用的H5 容器里打开，容器提供一些原生的接口供H5使用。比如在支付宝和微信上的“滴滴出行”以 H5 的形式运行在各自的平台中，这种模式看似还不错，但是实际上这种简单的方案不能满足这两个小程序的基础需求：体验： 作为一个“小程序”需要让体验接近原生，而上述像滴滴出行这些普通 H5 的体验不太行，包括启动速度、页面切换流畅度都有问题，跟原生体验没法比。管控： 作为一个平台必须对接入的应用有管控能力，必须能尽量精确控制应用的内容和类型，毕竟若出现非法应用平台是要承担责任的，H5 的方式太过自由，开发者可以随时改变整个应用的内容，平台难以检测到这些改变，无法管控。另外 H5 开发质量参差不齐，平台也无法管控。2. 框架概述为了实现小程序并满足上述的小程序的两个需求，小程序框架应运而生。我们先看下小程序框架大图，自上而下看。小程序代码： 这是小程序开发者使用小程序 DSL 及各种组件开发的小程序。小程序组件及 API： 这是小程序的组件及 API 层，提供了小程序所需的各种组件和小程序 API。小程序开发者只需要在基于这一层提供的组件及 API 进行小程序的开发。小程序应用层框架： 这是小程序运行的框架层，它基于 React 实现了小程序的运行框架。该层主要包含小程序的逻辑处理引擎及渲染层。Native SDK： 该层提供了小程序所需的 Native 能力，通过J avaScriptCore 为小程序的 JS 层框架提供大量的 Native API，此外该层还提供了小程序包管理、后台保活等基础能力。React 和 React Native： 这一层是小程序底层运行环境，分别对应于 Web 和 Native 环境，使得小程序可运行在 WebView 和 iOS/Android 上。系统层： 即 Web 内核、iOS 和 Android，是系统级的平台层。目前支付宝的小程序使用的是 React 版，蚂蚁内部的其他 App 有在使用 React Native 版的小程序。3. 应用层框架我们一起看下小程序应用层框架。每个小程序的代码分为两部分——逻辑处理和视图渲染，分别运行在 worker （js 引擎） 以及 render （渲染层）中。worker 运行小程序的逻辑处理代码 ，包括事件处理，api 调用以及框架的生命周期管理。 worker 只有一个，方便 App 数据在页面间的共享和交互。render 运行小程序的渲染代码 ，主要包括模版、样式和框架的跨终端的 js 组件或 native 组件，获取逻辑层的数据操作渲染引擎（React/ReactNative）进行渲染，render 在小程序中可以有多个。worker 和所有的 render 都建立连接 ，将需要渲染的数据传递给对应的 render 进行渲染，worker 也会将 api 调用转给 Native SDK 处理。render 则将组件的触发事件送到对应的 worker 处理 ，同时接受 worker 的调用进行重新渲染。 render 可以看作一个无状态的渲染终端，小程序的状态都保留在 worker 内。可见该框架可以做到，JS 逻辑代码与页面渲染分离并行执行，不会出现 JS 代码执行时卡住页面渲染的情况，进而提升渲染性能。多个页面可以共享一个 JS 运行环境，数据可以很方便地共享，整个小程序生命周期里共享同一个上下文，更接近 App 的开发体验。小程序的模板样式是自定义的格式，这样可以做到开发时使用固定的 DSL，不依赖底层的渲染引擎，这样引擎的优化升级不会造成上层的小程序代码的不兼容，并且渲染行为是完全是可控的。4. Native SDK我们再看 Native 层，在支付宝中是由 Nebula H5 容器负责实现，它为小程序提供 Native 能力，为小程序提供的包管理、后台保活等功能。Native API ：小程序调用的 API 中有部分功能需要在 native 中实现，这部分 API 通过桥接调用进入对应的 Native API。包管理 ：负责小程序包的下载、存储、加载。小程序包的下载具有多种策略，可以满足小程序的预下载、强制更新等需求。后台保活 ：小程序在后台可以存活 5 分钟，使得用户在下次打开时可以获得更好的体验。5. 小结现在让我们回到前面提到的两个小程序的基本需求，体验和管控。我们看下框架是如何实现这两个需求的。对于体验需求，主要有以下几点：框架对小程序做了逻辑处理和视图渲染的分离以提升渲染性能对于较重的组件（地图）使用 Native 实现以提升性能小程序公共资源预置在小程序框架以提升加载性能后台保活机制提高二次启动速度对于管控需求，主要有两点：小程序开发只能使用框架提供的自定义的模板样式JS 代码运行在与 Webview 隔离的 JS 引擎中，无法操作浏览器 DOM5. mPaaS 技术架构与助力1. 支付宝小程序与 mPaaS小程序这么有优势，那能否把支付宝小程序放到其他 APP 中运行呢？答案是肯定的，借助 mPaaS，小程序技术不仅在蚂蚁金服内部使用，也能够提供给外部用户使用。首先简单介绍下什么是 mPaaS，mPaaS 全称是 Mobile Platform as a Service，即移动端的 PaaS 。作为蚂蚁金服独创的移动研发平台，它源于支付宝近 10 年的移动技术的沉淀，为移动开发、测试、运营及运维提供云到端的一站式解决方案，能有效降低技术门槛、减少研发成本、提升开发效率，协助生态伙伴快速搭建稳定高质量的移动 App。2. mPaaS 小程序再来看下什么是 mPaaS 小程序，它是在支付宝小程序的基础上做了瘦身、去依赖的小程序 SDK，为了能便捷的输出给其他 App 快速地搭建出小程序平台。它保持和支付宝小程序一样的模板样式和通用 API，仅仅少量的像授权这样的开放的 API 需要客户自定义开发。借助 mPaaS 小程序，可以做到一套小程序代码，在支付宝和自己的 App 上双端投放和运行，甚至可以构建出自己的小程序生态体系。这里和大家分享下 mPaaS 小程序在其他 App 中集成时可能需要解决的问题：SDK 集成冲突，这个是多个 SDK 集成可能会遇到的共性问题，一般通过去除不要的 SDK 或者对 SDK 中部分符号名做针对性的修改。开放 API 定制开发，开放 API 依赖后端的服务，比如用户授权这个 API，它需要获取用户的账号信息，那么就需要重写这个 API 的具体实现，去访问 App 的用户中心服务以实现授权功能。小程序框架提供了一套自定义和重写 API 的插件机制，能快速的去重写某个 API，甚至添加一个新的 API。3. mPaaS 小程序 IDE小程序的开发除了可使用支付宝小程序开放平台提供的 IDE，还可以使用 mPaaS 版的小程序 IDE。通过 mPaaS 版的 IDE 可以导出本地的小程序包，后续在 mPaaS 发布平台中使用这个本地包直接发布。未来，小程序 IDE 将会与 mPaaS 直接打通，在 IDE 中可以直接完成 mPaaS 小程序的开发、测试和发布这一系列的开发运维体验。4. mPaaS MDS小程序技术的一个基础的能力，就是小程序发布系统。mPaaS 小程序的发布服务是由 mPaaS 的移动发布系统（MDS）提供的。MDS 提供多种发布策略，能够在正式发布之前进行多种类型的灰度测试。MDS 提供增量差分包更新能力，可减少更新包的体积，在移动端网络不稳定场景中发挥优势。mPaaS MDS 控制台目前，mPaaS 小程序已在众多政务项目中落地服务，帮助政务小程序在支付宝和自有 App 双端投放运行。相同的业务功能使用小程序实现，在支付宝和自有 App 中可进行共用，能显著地降低开发成本，做到业务的快速上线及动态更新。如果想要进一步了解 mPaaS 小程序，可以复制地址到浏览器中打开：t.cn/ELBlvEr关于小程序框架的优化思路或具体实践，如果你有任何疑问或建议，欢迎随时和我们一同交流。往期阅读《开篇 | 模块化与解耦式开发在蚂蚁金服 mPaaS 深度实践探讨》《支付宝移动端动态化方案实践》《支付宝客户端架构解析：iOS 容器化框架初探》《支付宝客户端架构解析：Android 容器化框架初探》《支付宝客户端架构解析：Android 客户端启动速度优化之「垃圾回收」》《Demo Show | 蚂蚁金服 mPaaS IDEA 插件实践》《支付宝客户端架构分析：自动化日志收集及分析》"}
{"title": "小程序页面跳转解析 ", "author": "Rolan", "pub_time": "2017-10-28 00:50", "content": "对于两个或更多页面的微信小程序而言，页面之间的跳转是在所难免的。有关小程序页面间跳转的 API 函数，微信一共为我们提供了 4 个（另外，还有返回上一级或多级的 wx.navigateBack）。下面，我将主要围绕这四个 API 函数，教你如何跳出页面跳转的大坑。四个接口怎么用？这四个 API 可接受的参数都是完全相同的，如下：在小程序 JavaScript 逻辑代码中的用法，也完全相同，具体语法为：函数名({\r\n  url: \"\",\r\n  success: function () {},\r\n  fail: ...,\r\n  complete: ...\r\n})虽然它们有这么多的相同点，但它们绝对一点都不多余， 因为它们的用法完全各不相同。直接跳转：wx.navigateTo()wx.navigateTo() 用于保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面。对于页面不是特别多的小程序，通常推荐使用 wx.navigateTo 进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用。重定向：wx.redirectTo()当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 5 层页面栈。这时，我们应该考虑选择 wx.redirectTo。wx.redirectTo() 用于关闭当前页面，跳转到应用内的某个页面。这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间。清空页面栈再跳转：wx.reLaunch()wx.reLaunch() 与 wx.redirectTo() 的用途基本相同， 只是 wx.reLaunch() 先关闭了内存中所有保留的页面，再跳转到目标页面。跳转至 Tab Bar 页面：wx.switchTab()对于跳转到 tab bar 的页面，最好选择 wx.switchTab()，它会先关闭所有非 tab bar 的页面。其次，也可以选择 wx.reLaunch()，它也能实现从非 tab bar 跳转到 tab bar，或在 tab bar 间跳转，效果等同 wx.switchTab()。使用其他跳转 API 来跳转到 tab bar，则会跳转失败。tab bar 如下所示（位于小程序底部）： 关闭页面：wx.navigateBack()wx.navigateBack() 用于关闭当前页面，并返回上一页面或多级页面。开发者可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。这个 API 需要填写的参数只有 delta，表示要返回的页面数。若 delta 的取值大于现有可返回页面数时，则返回到用户进入小程序的第一个页面。当不填写 delta 的值时，就默认其为 1（注意，默认并非取 0），即返回上一页面。"}
{"title": "你有一份小程序产品设计心经，请查收 ", "author": "Rolan", "pub_time": "2018-7-2 00:05", "content": "微信月活用户在2018年一季度达到10.4亿人，日均登录用户在2017 年9月就已经达到9.02亿人，从这两个数据可以看出微信的活跃人群覆 盖率几乎占据了国内移动互联网的所有用户群体，微信已经成为人们 在移动互联网上活动的最重要的工具，而小程序的出现会进一步强化 微信在移动互联网中的地位，占据用户更多的使用时长。小程序陆陆续续提供越来越多服务、开放更多入口。小程序数量在下半年也将会倍加增长。那么知悉以下5点小程序接口并良好去应用，能让你的小程序level up up up~1. 屏幕保持常亮状态设置是否保持常亮状态。对一些在使用时需要“待机运行”一段时间的小程序非常适用，如：直播类小程序。避免用户还处于使用状态时不能因某些客观因素造成体验差评。2. 版本更新处理小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。什么是热启动？小程序文档的解释是：假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台态的小程序切换到前台，这个过程就是热启动；什么是冷启动？冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。版本更新机制就是在小程序冷启动时如果发现有新版本，将会异步下载新版本的代码包，并同时用客户端本地的包进行启动，即新版本的小程序需要等下一次冷启动才会应用上。下面以“小明、老王、小程序项目组”3大视角下看看如何避免冷启动时还是旧版本的情况“失败案例”小明：10月10日上午8点蹲马桶时打开了小程序a，此时版本为1.1.1，玩耍了一圈就溜了小程序项目组：10月10日上午11点提交了小程序a的一个新版本1.1.2，主要更新内容：小程序首页新增1个模块，用于跳转至其它小程序，此时并没有接入wx.getUpdateManager接口小程序审核团队：10月10日下午3点审核通过小程序a1.1.2版本小程序项目组：10月10日下午3点30分发布了小程序a1.1.2版本小明 ：10月10下午4点又打开了小程序a，由于没有接入wx.getUpdateManager，冷启动时未检查微信版本所以此时小程序a的版本在小明的微信上还是1.1.1版，所以小明不知道该小程序新增了一个模块。 如果小明删掉小程序a，在搜索栏重新搜索小程序a名称进行打开重新打开的小程序a版本为1.1.2，这操作显得很不友好。老王：新来的老王之前没有打开过小程序a，10月10日下午4点老王搜索后打开了小程序a，此时版本号为1.1.2，老王可以看到新增的模块内容。“成功案例”小明：10月10日上午9点打开了小程序a，此时版本为1.1.1，玩耍了一圈也溜了小程序项目组：10月10日上午11点提交了小程序a的一个新版本1.1.2，主要更新内容：小程序首页新增1个模块，用于跳转至其它小程序，另外此时并接入wx.getUpdateManager接口小程序审核团队：10月10日下午3点审核通过小程序a1.1.2版本小程序项目组：10月10日下午3点30分发布了小程序a1.1.2版本小明：10月10下午4点又打开了小程序a，此时小明会收到提示，“新版本已经准备好，是否重新启动？”ps：小程序冷启动时自动触发wx.getUpdateManager接口，当检查到小程序有新版本，会主动触发下载操作，当下载完成后，会通过onUpdateReady告知开发者。如果小明在下载新版本时Wi-Fi断了，没有下载成功，也会通过另外一个接口onUpdateFailed进行通知。老王：新来的老王之前没有打开过小程序a，10月10日下午4点老王搜索后打开了小程序a，此时版本号为1.1.2，老王也可以看到新增的模块内容。案例结论：新版本上线时一方面避免新老用户短时间内解决信息不共识问题，另一方面化繁为简提高用户体验，避免右滑删除重新搜索等复杂流程。tips：由于小程序开发版和体验版没有「版本」概念，所以测试同学无法在开发版或体验版上测试更版本更新情况，测试需到正式版进行测试体验。3. 监听用户截屏现在“截屏文化”深入各位机友民心，使用小程序时也有很多截屏后的使用场景。比如目前小程序内只能识别菊花码（小程序码），并不能识别普通二维码。监听用户截屏后 触发识别二维码、触发转发等可借助该监听后的事件达到最理想的流程和结果。4. 快速获取绑定微信的手机号截止2018年6月小程序用户游戏类占比达到34.6%，网络购物达到22.7%，此类小程序在注册、联系方式上均需要登记手机号码。对于目前对微信用户绝大多数均绑定手机号码，则可在页面上部署手机号码快速填写组件，用户点击组件，完成弹窗授权后，即可直接将微信绑定的手机号填入。（图片来源于网络）但考虑到微信号和手机号属于1对多的情况下，若绑定该微信对手机号码不想绑定在该小程序上，则需提供手动输入手机号码功能。5. 内容安全如今小程序数量越来越多，代表在内容安全层面责任也越来越大，微信对踩红线对小程序从不手软。目前小程序对图片和文字有提供现成API供调用，确保绿色健康的微信环境（API调用限制：迸发限制1分钟2000次，次数限制1天一百万次）5.1 图片违规校验一张图片是否含有违法违规内容。如：涉及拍照的工具类小程序(如黑咔相机小程序，识图类、肌肤测试类等应用)用户拍照上传；电商类小程序商品详情图片；媒体类小程序用户上传文章图片；社交类小程序用户上传的图片；各大小程序内用户头像检测等。5.2 文字违规检查一段文本是否含有违法违规内容。如：各个类别用户个人资料违规文字；媒体类小程序用户发表文章／文字，各大小程序用户评论内容；游戏类用户编辑上传的素材(如答题类小游戏用户上传的问题及答案)检测等。 本文由 @动物园园长 原创发布于人人都是产品经理。未经许可，禁止转载"}
{"title": "微信小程序请求API接口PHPSESSID变化的解决方式 ", "author": "Rolan", "pub_time": "2018-4-13 00:18", "content": "微信小程序开发，请求服务器API的方法使用的是微信官方提供的wx.request()方法。在开发中发现，每一个请求都会生成一个独立的PHPSESSID，如下图示：搜索后得知，这是由于wx.request()造成的。如果直接使用浏览器请求并不会出现这种情况。解决方式如下：　　通过登录接口获取到用户的session_key 和 open_id，设置session信息如下：　　$3rd_session = md5(session_key . $open_id)　　$_SESSION[$3rd_session ] = session_key . '|' . $open_id;　　服务器生成此用户的session_id，接口返回 3rd_session 和 session_id。　　在其他接口请求中，在header中设置cookie的值：session_id：　　header = header || {    　　'content-type': 'application/x-www-form-urlencoded;',    　　'Cookie': 'PHPSESSID=session_id值'　　}     　　并在接口中带上参数session=3rd_session，此时服务端获取到的就是同一个session_id，根据3rd_session从$_SESSION得到用户的openid"}
{"title": "小程序wx.setScreenBrightness/wx.getScreenBrightness接口测试 ", "author": "Rolan", "pub_time": "2018-1-24 00:27", "content": "前言最近接触了微信小程序 API - wx.setScreenBrightness 、wx.getScreenBrightness 接口，调用该接口可以调节并显示手机屏幕亮度数据。对于喜欢腾讯新闻、今日头条等一些阅读类小程序的小伙伴，还是挺友好的。不需要下拉屏幕或退出小程序页面就可以调整屏幕亮度，直接在小程序内部完成屏幕亮度调节工作，更加快速。下面，就分享一下如何使用该微信小程序API接口以及需注意的问题。好！下面进入正文。首先，打开微信开发者工具，添加小程序项目，选择一个本地新建的空白小程序文件即可，APPid根据情况填写。完成（工具会自动生成小程序必要一些的文件）。本次删除了logs/until页面，直接在index页面上开发了第一步，打开 app.json 文件（全局控制，决定页面文件的路径、窗口表现），检查是否写入pages/index/index，否则无法访问index页面。接着配置navigation的相关参数，控制窗口顶部相关样式信息，如backgroundcolor（背景）、textstyle（文本颜色）等源码参考：//app.json{  \"pages\": [    \"pages/index/index\"  ],  \"window\": {    \"navigationBarBackgroundColor\": \"#000000\",    \"navigationBarTextStyle\": \"white\",    \"navigationBarTitleText\": \"调节屏幕亮度\",    \"backgroundColor\": \"#eeeeee\",    \"backgroundTextStyle\": \"light\",    \"enablePullDownRefresh\": false  }}第二步，打开index的js文件，在page下定义changeScreenLight对象，并同时在.wxml文件中设置参数，传递changeScreenLight下相关事件函数处理的值。接着开始配置wx.setScreenBrightness 以及 wx.getScreenBrightness两个事件函数！1）wx.setScreenBrightness 即获得屏幕亮度值，用value参数来写入，这里还使用了parseFloat、toFixed两个函数来界定value的取值。为了把获得的value值回调至下个事件函数wx.getScreenBrightnes的ScreenBrightnes中，这里借助var that = this 来处理，即把这个this事件的值复制一份到that，在下个事件函数中，用that.setDatal来回调数值。2）wx.getScreenBrightness 即给屏幕亮度赋值，通过success参数(成功调用)的res属性来传递这个事件函数，接着使用that.setData回调数值，而其中的ScreenBrightness：res.value即res第一个事件函数中的value值啦!源码参考：//index.jsPage({  data:{  },  changeScreenLight:function(e){    var that = this;    //滑动拉杆获得值    wx.setScreenBrightness({      value: parseFloat(e.detail.value).toFixed(1)    })    //给屏幕亮度赋值    wx.getScreenBrightness({      success: function(res) {        that.setData({          ScreenBrightness: res.value        })      }    })  }})第三步，配置index.wxml文件。index.wxml文件的配置和.js文件是有关联性的。这里在.wxml用slider做了一个滑杆，通过min、max、step控制滑杆的最小值、最大值以及每滑动一单位时的增量，最后通过bindchange=\"changeScreenLight\"，来传递.js文件中changeScreenLight相关事件函数的处理结果。{{ScreenBrightness}}参数则是传递了.js文件中的value值。 源码参考：<slider min=\"0\" max=\"1\" step=\"0.1\"bindchange=\"changeScreenLight\"/><view>屏幕亮度：{{ScreenBrightness}}</view>总结：getScreenBrightness 接口若安卓系统设置中开启了自动调节亮度功能，则屏幕亮度会根据光线自动调整，该接口仅能获取自动调节亮度之前的值，而非实时的亮度值。"}
{"title": "当微信小程序遇上 TensorFlow：接收 base64 编码图像数据 ", "author": "Rolan", "pub_time": "2018-10-18 00:21", "content": "这是 当微信小程序遇上TensorFlow 系列文章的第四篇文章，阅读本文，你将了解到：如何查看tensorflow SavedModel的签名如何加载tensorflow SavedModel如何修改现有的TensorFlow模型，增加输入层如果你想要了解更多关于本项目，可以参考这个系列的前三篇文章：当微信小程序遇上TensorFlow：Server端实现当微信小程序遇上TensorFlow：Server端实现补充当微信小程序遇上TensorFlow：小程序实现关于Tensorflow SavedModel格式模型的处理，可以参考前面的文章：Tensorflow SavedModel模型的保存与加载如何查看tensorflow SavedModel格式模型的信息如何合并两个TensorFlow模型问题截至到目前为止，我们实现了一个简单的微信小程序，使用开源的Simple TensorFlow Serving部署了服务端。但这种实现方案还存在一个重大问题：小程序和服务端通信传递的图像数据是(299, 299, 3)二进制数组的JSON化表示，这种二进制数据JSON化的最大缺点是数据量太大，一个简单的299 x 299的图像，这样表示大约有3 ～ 4 M。其实HTTP传输二进制数据常用的方案是对二进制数据进行base64编码，经过base64编码，虽然数据量比二进制也会大一些，但相比JSON化的表示，还是小很多。所以现在的问题是，如何让服务器端接收base64编码的图像数据？查看模型的签名为了解决这一问题，我们还是先看看模型的输入输出，看看其签名是怎样的？这里的签名，并非是为了保证模型不被修改的那种电子签名。我的理解是类似于编程语言中模块的输入输出信息，比如函数名，输入参数类型，输出参数类型等等。借助于Tensorflow提供的saved_model_cli.py工具，我们可以清楚的查看模型的签名：python ./tensorflow/python/tools/saved_model_cli.py show --dir /data/ai/workspace/aiexamples/AIDog/serving/models/inception_v3/ --all\r\n\r\nMetaGraphDef with tag-set: 'serve' contains the following SignatureDefs:\r\n\r\nsignature_def['serving_default']:\r\n  The given SavedModel SignatureDef contains the following input(s):\r\n    inputs['image'] tensor_info:\r\n        dtype: DT_FLOAT\r\n        shape: (-1, 299, 299, 3)\r\n        name: Placeholder:0\r\n  The given SavedModel SignatureDef contains the following output(s):\r\n    outputs['prediction'] tensor_info:\r\n        dtype: DT_FLOAT\r\n        shape: (-1, 120)\r\n        name: final_result:0\r\n  Method name is: tensorflow/serving/predict从中我们可以看出模型的输入参数名为image，其shape为(-1, 299, 299, 3)，这里-1代表可以批量输入，通常我们只输入一张图像，所以这个维度通常是1。输出参数名为prediction，其shape为(-1, 120)，-1和输入是对应的，120代表120组狗类别的概率。现在的问题是，我们能否在模型的输入前面增加一层，进行base64及解码处理呢？也许你认为可以在服务器端编写一段代码，进行base64字符串解码，然后再转交给Simple Tensorflow Serving进行处理，或者修改Simple TensorFlow Serving的处理逻辑，但这种修改方案增加了服务器端的工作量，使得服务器部署方案不再通用，放弃！修改模型，增加输入层其实在上一篇文章《 如何合并两个TensorFlow模型 》中我们已经讲到了如何连接两个模型，这里再稍微重复一下，首先是编写一个base64解码、png解码、图像缩放的模型： base64_str = tf.placeholder(tf.string, name='input_string')\r\n  input_str = tf.decode_base64(base64_str)\r\n  decoded_image = tf.image.decode_png(input_str, channels=input_depth)\r\n  # Convert from full range of uint8 to range [0,1] of float32.\r\n  decoded_image_as_float = tf.image.convert_image_dtype(decoded_image,\r\n                                                        tf.float32)\r\n  decoded_image_4d = tf.expand_dims(decoded_image_as_float, 0)\r\n  resize_shape = tf.stack([input_height, input_width])\r\n  resize_shape_as_int = tf.cast(resize_shape, dtype=tf.int32)\r\n  resized_image = tf.image.resize_bilinear(decoded_image_4d,\r\n                                           resize_shape_as_int)\r\n  tf.identity(resized_image, name=\"DecodePNGOutput\")接下来加载retrain模型： with tf.Graph().as_default() as g2:\r\n    with tf.Session(graph=g2) as sess:\r\n      input_graph_def = saved_model_utils.get_meta_graph_def(\r\n          FLAGS.origin_model_dir, tag_constants.SERVING).graph_def\r\n\r\n      tf.saved_model.loader.load(sess, [tag_constants.SERVING], FLAGS.origin_model_dir)\r\n\r\n      g2def = graph_util.convert_variables_to_constants(\r\n          sess,\r\n          input_graph_def,\r\n          [\"final_result\"],\r\n          variable_names_whitelist=None,\r\n          variable_names_blacklist=None)这里调用了graph_util.convert_variables_to_constants将模型中的变量转化为常量，也就是所谓的冻结图(freeze graph)操作。利用tf.import_graph_def方法，我们可以导入图到现有图中，注意第二个import_graph_def，其input是第一个graph_def的输出，通过这样的操作，就将两个计算图连接起来，最后保存起来。代码如下： with tf.Graph().as_default() as g_combined:\r\n    with tf.Session(graph=g_combined) as sess:\r\n      x = tf.placeholder(tf.string, name=\"base64_string\")\r\n      y, = tf.import_graph_def(g1def, input_map={\"input_string:0\": x}, return_elements=[\"DecodePNGOutput:0\"])\r\n      z, = tf.import_graph_def(g2def, input_map={\"Placeholder:0\": y}, return_elements=[\"final_result:0\"])\r\n\r\n      tf.identity(z, \"myOutput\")\r\n\r\n      tf.saved_model.simple_save(sess,\r\n                                 FLAGS.model_dir,\r\n                                 inputs={\"image\": x},\r\n                                 outputs={\"prediction\": z})如果你不知道retrain出来的模型的input节点是啥（注意不能使用模型部署的signature信息）？可以使用如下代码遍历graph的节点名称：for n in g2def.node:\r\n  print(n.name)模型部署及测试注意，我们可以将连接之后的模型保存在./models/inception_v3/2/目录下，原来的./models/inception_v3/1/也不用删除，这样两个版本的模型可以同时提供服务，方便从V1模型平滑过渡到V2版本模型。我们修改一下原来的test_client.py代码，增加一个model_version参数，这样就可以决定与哪个版本的模型进行通信： with open(file_name, \"rb\") as image_file:\r\n    encoded_string = str(base64.urlsafe_b64encode(image_file.read()), \"utf-8\")\r\n\r\n  if enable_ssl :\r\n    endpoint = \"https://127.0.0.1:8500\"\r\n  else:\r\n    endpoint = \"http://127.0.0.1:8500\"\r\n\r\n  json_data = {\"model_name\": model_name,\r\n               \"model_version\": model_version,\r\n               \"data\": {\"image\": encoded_string}\r\n              }\r\n  result = requests.post(endpoint, json=json_data)小结经过一个多星期的研究和反复尝试，终于解决了图像数据的base64编码通信问题。难点在于虽然模型是编写retrain脚本重新训练的，但这段代码不是那么好懂，想要在retrain时增加输入层也是尝试失败。最后从Tensorflow模型转Tensorflow Lite模型时的freezing graph得到灵感，将图中的变量固化为常量，才解决了合并模型变量加载的问题。虽然网上提供了一些恢复变量的方法，但实际用起来并不管用，可能是Tensorflow发展太快，以前的一些方法已经过时了。本文的完整代码请参阅：https://github.com/mogoweb/aiexamples/tree/master/AIDog/serving点击 阅读原文 可以直达在github上的项目。到目前为止，关键的问题已经都解决，接下来就需要继续完善微信小程序的展现，以及如何提供识别率，敬请关注我的微信公众号：云水木石，获取最新动态。参考How to Show Signatures of Tensorflow Saved ModelServing Image-Based Deep Learning Models with TensorFlow-Serving’s RESTful APITensorflow: How to replace a node in a calculation graph?"}
{"title": "微信小程序通过api接口将json数据展现到小程序上 ", "author": "Rolan", "pub_time": "2018-3-9 00:45", "content": "实现知乎客户端的一个重要知识前提就是，要知道怎么通过知乎新闻的接口，来把数据展示到微信小程序端上。 那么我们这一就先学习一下，如何将接口获取到的数据展示到微信小程序上。1.用到的知识点<1> wx.request 请求接口资源（微信小程序api中的发起请求部分） <2>swiper 实现轮播图的组件 <3>wx:for 循环语句 <4>微信小程序的基础知识2.实现原理首先，先看一下这个请求函数varwx.request({  url: '******', //这里填写你的接口路径  header: { //这里写你借口返回的数据是什么类型，这里就体现了微信小程序的强大，直接给你解析数据，再也不用去寻找各种方法去解析json，xml等数据了      'Content-Type': 'application/json'  },  data: {//这里写你要请求的参数     x: '' ,     y: ''  },  success: function(res) {  //这里就是请求成功后，进行一些函数操作    console.log(res.data)  }})"}
{"title": "【微信小程序】自定义模态对话框实例 ", "author": "Rolan", "pub_time": "2017-8-15 00:43", "content": "自定义模态对话框实例由于官方API提供的显示模态弹窗，只能简单地显示文字内容，不能对对话框内容进行自定义，欠缺灵活性，所以自己从模态弹窗的原理角度来实现了自定义的模态对话框。wx.showModal(OBJECT)自定义模态对话框赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\n黄秀杰\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序组件化（上） \n              微信小程序之表单校验 \n            \n             \n            \n                  原作者: Acoe \n                  来自: csdn \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序自定义实用组件（对话框、指示器、五星评分...\n                                    \n                  • 微信小程序自定义对话框\n                                    \n                  • 微信小程序自定义对话框+弹出和隐藏动画详解\n                                    \n                  • 微信小程序使用mock.js提供模拟数据，提示输入对话框prompt\n                                    \n                  • 闲聊-智能对话：微信小程序详解\n                                    \n                  • 微信小程序组件化 快速实现可用模态窗\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    2 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n     \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         numberTwo\r\n                \r\n       \r\n       2017-8-16 10:17\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    您好，我用你的代码来测试这个阻止事件冒泡catchtouchmove，结果无效果呢，主页还是继续滚动\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n          \r\n                 \r\n  \r\n    \r\n        \r\n       \r\n          \r\n         ukzq\r\n                \r\n       \r\n       2017-8-15 22:58\r\n       \r\n          \r\n       \r\n       \r\n    \r\n    消灭0回复%……\r\n    回复 \r\n  \r\n\r\n\r\n \r\n     \r\n             \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSoi0ei1', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n推荐阅读\r\n\r\n\r\n微信小程序开发早知道2019-04-04微信小程序上线“页面收录”功能，真正的SE2019-04-04小程序侵权“生死局”2019-04-04微信小程序搭建mpvue+vant+flyio2019-04-04微信小程序自定义导航栏2019-04-08使用weixin-java-miniapp配置进行单个小程2019-04-04全国首例微信小程序侵权案已判决，腾讯要承2019-04-08微信小程序ad自适应布局2019-04-08从产品角度，看小程序的设计2019-04-09我的前端规范系列-高清屏适配[按标准来就行2019-04-09\r\n\r\n\r\n最新Demo\r\n\r\n\r\n“坦白言”社交类型分享裂变小程序开源2019-04-08AI驾驶行为检测DEMO2019-04-05弹幕微信小程序Demo2019-04-050.02019-04-02小程序组件常用组件分享2019-04-02性格测试小程序2019-04-01小程序登录Demo2019-03-26想做一个微信论坛项目2019-03-25新版答题小程序2019-03-21需要一个搬家下单的小程序2019-03-20\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880736|91cce5f4298ba6b4acb7792b7e9d7e80|2';"}
{"title": "关于微信小程序webview的使用 ", "author": "Rolan", "pub_time": "2017-12-4 00:31", "content": "小程序微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。同时提供一系列工具帮助开发者快速接入并完成小程序开发。关于如何注册配置就不多言了，本文主要还是体验了下web-view的功能。web-view详解有了这个组件之后，小程序可以很好的嵌入一些页面，可以环境小程序size告急的问题，同样也使开发更加便捷，毕竟小程序开发者基本都对前端开发较为了解。web-view能力说再多还是需要去看官方文档，web-view文档,兼容首先就需要注意：兼容问题，版本库和对应版本比例基础库 1.6.4 开始支持，低版本需做兼容处理，个人类型与海外类型的小程序暂不支持使用。目前而言，基本80%的用户会升级微信，所以其实不必担心版本问题，官方截止2017-12-01提供的数据也说明88%的用户支持web-view。使用web-view 组件是一个可以用来承载网页的容器，会自动铺满整个小程序页面；属性：src 是String类型，是一个网站的url，默认值是none，webview 指向网页的链接。需登录小程序管理后台配置域名白名单。\r\n\r\n<web-view src=\"https://mp.weixin.qq.com/\">web-view>可以配合Page实例的onLoad方法来获取url的具体值，也就是一个微信小程序页面中只有一个web-view，但是这个web-view的内容可以根据上一个页面传递的参数来获取页面URL，后面会讲如何实践，官方提供如下接口：web-view和小程序的通信1. 由小程序到`web-view`,其实本质上`WEB-VIEW`也是小程序的一个页面，所以小程序到`web-view`是正常的小程序间的通信，通过`wx.navigateTo`、`wx.redirectTo`，带上`url`参数,`query`参数就像正常`url`的参数一样跟着后面，然后在`web-view`的页面的`Page`实例里面通过`onLoad`的方法的参数来获取`url`的值，设置给`web-view`的`src`属性为改值即可。\r\n2. 由`web-view`到小程序，由于在`web-view`的跳转通常是在`src`对应的网页中的操作来处理的，所以需要结合`jssdk`来处理，不需要`wx.config`配置，直接通过`script`标签来引入`https://res.wx.qq.com/open/js/jweixin-1.3.0.js`，就可以使用`wx.miniProgram.navigateTo`、`wx.miniProgram.navigateBack`、`wx.miniProgram.switchTab`、`wx.miniProgram.reLaunch`、`wx.miniProgram.redirectTo`接口，就像小程序之间的跳转一样，单是只能在当前小程序页面内跳转。支持以下部分JSSDK接口图像、音频、摇一摇、地理位置等信息，具体可以查看web-view文档,不过这些需要通过wx.config来授权，就和服务号开发类似。用户分享时可获取当前的URL，即在onShareAppMessage回调中返回webViewUrl参数。Page({\r\n  onShareAppMessage(options) {\r\n    console.log(options.webViewUrl)\r\n  }\r\n})在网页内可通过window.__wxjs_environment变量判断是否在小程序环境。// web-view下的页面内\r\nconsole.log(window.__wxjs_environment === 'miniprogram') // trueweb-view实践在目前实践了部分web-view的功能，//index.js\r\nPage({\r\n    data: {\r\n       url: 'https://test.com'\r\n    },\r\n    onLoad: function(options){\r\n        options.url ? this.setData({url: options.url}) : wx.navigateBack({delta: 2});\r\n\r\n    }\r\n});\r\n\r\n//index.wxml\r\n\"{{url}}\">web-view>在这个web-view中，指向的就是https://test.com的内容，所以在在https://test.com中跳转出回到小程序，需要修改https://test.com中的JavaScript,\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\r\n    <title>testtitle>\r\n    <link rel=\"stylesheet\" href=\"https://test.com/index.css\" />\r\nhead>\r\n<body>\r\n    <div class=\"app\">\r\n        <h1>webview-wechat-detailh1>\r\n        <p>\r\n            detail\r\n        p>\r\n        <button type=\"button\" id=\"btn\">返回小程序button>\r\n    div>\r\n    <script src=\"https://test.com/jquery.js\">script>\r\n    <script src=\"https://res.wx.qq.com/open/js/jweixin-1.3.0.js\">script>\r\n    <script>\r\n        /* eslint-disable */\r\n$(function(){\r\n    doucument.cookie = 'bb=bbbbbb';\r\n    $('#btn').on('click',function(s) {\r\n        document.cookie = 'aa=ssssss';\r\n        wx.miniProgram.navigateTo({\r\n            url:'/pages/index?test=testtest',\r\n            success: function(){\r\n                console.log('success')\r\n            },\r\n            fail: function(){\r\n                console.log('fail');\r\n            },\r\n            complete:function(){\r\n                console.log('complete');\r\n            }\r\n\r\n            });\r\n        });\r\n    });\r\n    script>\r\nbody>\r\nhtml>\r\n如果需要使用一些其他的的jssdk的方法，那就需要参照公众号的开发配置了。web-view采坑由于很多使用中的一些问题1.打开的域名没有在小程序管理后台设置业务域名（注意是业务域名，不是服务器域名）2.打开的页面必须为https服务3.打开的页面302过去的地址也必须设置过业务域名4.web-view空白问题，请升级微信客户端到 6.5.165.页面可以包含iframe，但是iframe的地址必须为业务域名6.web-view不支持支付能力，web-view的API能力见web-view的文档说明7.开发者自己检查自己的https服务是否正常，测试方法：普通浏览器打开对应的地址8.如果web-view使用了公众号授权的服务，开发者工具提示网页开发者的问题，请见：公众号开发其他的问题注意：每个页面只能有一个，会自动铺满整个页面，并覆盖其他组件，小程序对webview的监控状态基本没有，只能设置src设置url。关于小程序和web-view的通信， → 小程序只能通过JSSDK 1.3.0提供的接口返回小程序页面，设置参数来传值，反之，小程序到webview也是一样的，只能是src的路径带上参数；web-view不支持支付能力,是指无法唤起小程序的直接支付窗口，对于h5的那套支付应该是支持的，但是web-view 里边没法使用 微信支付的 JSAPI，也就是可能可以h5的相关的的支付中心来支付；关于层级，在webview中可以无限跳转，对于导航条返回和物理键返回都会回到上一个页面直到退出webview，就像history.back。webview中的html的title会自动放到小程序的头部作为标题；webview中可以正常使用ajax之类的操作。一些可能的问题问题汇总"}
{"title": "微信小程序-自定义NavBar组件（1） ", "author": "Rolan", "pub_time": "2018-5-15 00:19", "content": "转载请注明出处：王亟亟的大牛之路最近公司项目忙得不可开交，各种不可描述的事情，然后学习基本停机。这个周末没出去浪，就在家把之前王夫人给我设计的小程序做了做，然后一步步分享做的过程中遇到的问题和积累，希望大家爬坑过程中能帮到一些吧组件化组件化本身是一个可以讲的很大，也可以浓缩为封装可复用的，模版组件基于mvvm的微信小程序当然也支持这一特性，我们做项目的时候也可以把注入公用的header footer之类的封一封（其实工具类的组装也可以作为组件化的一种形式）小程序的组件化挺有意思的基于Component，自行实现了一套比较深的实现（这篇不讲实现），第一次看感觉跟Page好，或者说是换汤不换药。但内部组件（页面）的生命周期，事件处理等有自己的特点，这个之后再写的时候再提吧然后微信，本身的sample已经写清楚了一些要素，那我这边也就在这个基础上做发散，官方传送门如下： https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/目录结构这边贴一下代码结构蓝色是自定义的组件(啊呀，好像没取components/nav这类名字)红色是引用他的首页设计图长这样做的长这样（UI还没调，效果先实现吧，反正大家也就看个思路，长啥样无所谓了）实现功能来源是 https://github.com/Tencent/weui-wxss 组件库中提取出来的，我做的工作就是把本来Page页面改成Component，然后给大家理一理过程。首先是提取功能代码在dist/example/navbar目录下，有3个文件我们先完全copy过来，然后添加一个navbar.json文件navbar.json{\r\n  \"component\": true,\r\n  \"usingComponents\": {}\r\n}如果有用到其他组件，那就定义一下，没有的话可以不管。component要为true。（证明我是谁嘛，这个好理解）因为设计图只需要2个tab页，所以把navbar.wxml文件进行了微调（没有重要步骤的我就不多做解释了）<view class=\"page\">\r\n    <view class=\"page__bd\">\r\n        <view class=\"weui-tab\">\r\n            <view class=\"weui-navbar\">\r\n                <block wx:for=\"{{tabs}}\" wx:key=\"*this\">\r\n                    <view id=\"{{index}}\" class=\"weui-navbar__item {{activeIndex == index ? 'weui-bar__item_on' : ''}}\" bindtap=\"tabClick\">\r\n                        <view class=\"weui-navbar__title\">{{item}}</view>\r\n                    </view>\r\n                </block>\r\n                <view class=\"weui-navbar__slider\" style=\"left: {{sliderLeft}}px; transform: translateX({{sliderOffset}}px); -webkit-transform: translateX({{sliderOffset}}px);\"></view>\r\n            </view>\r\n            <view class=\"weui-tab__panel\">\r\n                <view class=\"weui-tab__content\" hidden=\"{{activeIndex != 0}}\">PHOTO</view>\r\n                <view class=\"weui-tab__content\" hidden=\"{{activeIndex != 1}}\">BLOG</view>\r\n            </view>\r\n        </view>\r\n    </view>\r\n</view>这边任意一个点击都会触发tabClick()这个方法class=”weui-navbar__slider”的这个view用来绘制内容偏移的动画样式这块，空间本身有一些属性，然后微信这套设计有一个自己的风格，复制的时候从多个地方扣过来。navbar.wxss/*!\r\n * WeUI v1.1.1 (https://github.com/weui/weui-wxss)\r\n * Copyright 2017 Tencent, Inc.\r\n * Licensed under the MIT license\r\n */\r\n\r\n.weui-navbar {\r\n  margin-top: 50px;\r\n  display: -webkit-box;\r\n  display: -webkit-flex;\r\n  display: flex;\r\n  position: absolute;\r\n  z-index: 500;\r\n  top: 0;\r\n  width: 100%;\r\n  border-bottom: 1rpx solid #ccc;\r\n}\r\n\r\n.weui-navbar__item {\r\n  position: relative;\r\n  display: block;\r\n  -webkit-box-flex: 1;\r\n  -webkit-flex: 1;\r\n  flex: 1;\r\n  padding: 13px 0;\r\n  text-align: center;\r\n  font-size: 0;\r\n}\r\n\r\n.weui-navbar__item.weui-bar__item_on {\r\n  color: #F5CD79;\r\n}\r\n\r\n.weui-navbar__slider {\r\n  position: absolute;\r\n  content: \" \";\r\n  left: 0;\r\n  bottom: 0;\r\n  width: 50%;\r\n  height: 3px;\r\n  background-color: #F5CD79;\r\n  -webkit-transition: -webkit-transform 0.3s;\r\n  transition: -webkit-transform 0.3s;\r\n  transition: transform 0.3s;\r\n  transition: transform 0.3s, -webkit-transform 0.3s;\r\n}\r\n\r\n.weui-navbar__title {\r\n  display: inline-block;\r\n  font-size: 15px;\r\n  max-width: 8em;\r\n  width: auto;\r\n  overflow: hidden;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n  word-wrap: normal;\r\n}\r\n\r\n.weui-tab__panel {\r\n  box-sizing: border-box;\r\n  height: 100%;\r\n  padding-top: 50px;\r\n  overflow: auto;\r\n  -webkit-overflow-scrolling: touch;\r\n}然后就是逻辑选手navbar.js (解释我写在注释里吧)var sliderWidth = 96; // 需要设置slider的宽度，用于计算中间位置\r\n\r\nComponent({\r\n  properties: {\r\n    // 这里定义了tabs属性，属性值可以在组件使用时指定，类似于react的props和proptype\r\n    tabs: {\r\n      type: [],\r\n      value: [\"PHOTO1\", \"BLOG1\"],\r\n    }\r\n  },\r\n  data: {\r\n    // 初始化一些默认值ß\r\n    activeIndex: 0,\r\n    sliderOffset: 0,\r\n    sliderLeft: 0\r\n  },\r\n  created: function () {\r\n    //空间被创建时触发\r\n    console.log('--->navbar Component created')\r\n    var that = this;\r\n    wx.getSystemInfo({\r\n      success: function (res) {\r\n        that.setData({\r\n          sliderLeft: (res.windowWidth / that.data.tabs.length - sliderWidth) / 2,\r\n          sliderOffset: res.windowWidth / that.data.tabs.length * that.data.activeIndex\r\n        });\r\n      }\r\n    });\r\n  },\r\n  methods: {\r\n    // 按钮行为触发状态机变化\r\n    tabClick: function (e) {\r\n      this.setData({\r\n        sliderOffset: e.currentTarget.offsetLeft,\r\n        activeIndex: e.currentTarget.id\r\n      });\r\n    }\r\n  }\r\n});触发生命周期如图也是由内向外计算，渲染，加载主页面调用首先，先添加引用{\r\n    \"usingComponents\": {\r\n      \"Nav\": \"../../common/navbar/navbar\"\r\n    }\r\n}然后在页面里像使用普通控件一样使用就行了 <Nav tabs=\"{{数据源}}\"></Nav>总结：网上有许多自定义tab的一些方案，无非就是写复杂的viewgroup然后用hidfe show替换或者是改写swipe来实现。本文的例子更偏向第一种，但是又有像swipe的滑动动画具体的内容分析，之后会补上，这一篇作为开始，先撸个东西，之后再努力做好吧！源码等这一系列结束后，放出吧（但是跟着步骤做的话一定是可以把demo撸出来的）"}
{"title": "微信小程序实例-- 电影影评小程序 ", "author": "Rolan", "pub_time": "2017-8-7 00:05", "content": "这是博主的项目包含的文件截图： 首先如图建立文件夹和page页面然后app.json页面更新代码如下：{\r\n  \"pages\": [\r\n    \"pages/hotPage/hotPage\",\r\n    \"pages/comingSoon/comingSoon\",\r\n    \"pages/search/search\",\r\n    \"pages/more/more\"\r\n  ],\r\n  \"window\": {\r\n    \"backgroundTextStyle\": \"light\",\r\n    \"navigationBarBackgroundColor\": \"#fff\",\r\n    \"navigationBarTitleText\": \"WeChat\",\r\n    \"navigationBarTextStyle\": \"black\"\r\n  },\r\n  \"tabBar\": {\r\n    \"list\": [{\r\n      \"pagePath\": \"pages/hotPage/hotPage\",\r\n      \"text\": \"本地热映\"\r\n    },{\r\n      \"pagePath\": \"pages/comingSoon/comingSoon\",\r\n      \"text\": \"即将上映\"\r\n    },{\r\n      \"pagePath\": \"pages/search/search\",\r\n      \"text\": \"影片搜索\"\r\n    }]\r\n  }\r\n}1234567891011121314151617181920212223242526然后是app.wxss页面（为后面的页面样式写的）：/**app.wxss**/\r\n.container {\r\n  height: 100%;\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: center;\r\n  justify-content: space-between;\r\n  padding: 200rpx 0;\r\n  box-sizing: border-box;\r\n} \r\n/* hotPage.wxss */\r\n.movies{\r\n  display:flex;\r\n}\r\n.myimage{\r\n  flex: 1;\r\n}\r\n.moveInfo{\r\n  flex: 2;\r\n}\r\n.yanyuanlist{\r\n  display:flex;\r\n}\r\n.left{\r\n  flex:1;\r\n}\r\n.right{\r\n  flex:2;\r\n}1赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                \r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              为微信小程序增加mixin扩展 \n              微信小程序开发--从px到rpx \n            \n             \n            \n                  原作者: 涉水的小菜叽 \n                  来自: csdn博客 \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序实例--贪吃蛇\n                                    \n                  • 微信小程序入门实例：2048\n                                    \n                  • 微信小程序入门实例：navbar、swiper 应用\n                                    \n                  • 微信小程序开发实例--仿麦当劳微信小程序\n                                    \n                  • 微信小程序实例--洗衣小程序开发经验分享\n                                    \n                  • 微信小程序实例--知乎日报小程序\n                                    \n                  • eweapp：ECShop非官方版微信小程序商城\n                                    \n                  • 闲聊-智能对话：微信小程序详解\n                                    \n                  • 小程序实战--天气预报\n                                    \n                  • 微信小程序实例--仿豆瓣电影\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSnC3com', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \r\n推荐教程\r\n\r\n\r\n给媳妇做一个记录心情的小程序2019-03-22微信小程序开发中的代码片段总结2019-03-22小程序自定义单页面、全局导航栏2019-03-15微信，支付宝小程序实现原理概述2019-03-25Natsuha - 用Taro写个天气微信小程序2019-03-12mpvue开发音频类小程序踩坑和建议2019-03-12微信单页应用的那些事2019-03-13微信小程序框架wepy踩坑记录（与vue对比）2019-03-12如何使用微信小程序云函数发送短信验证码2019-03-13\r\n\r\n\n     \n      \r\n最新Demo\r\n\r\n\r\n“坦白言”社交类型分享裂变小程序开源2019-04-08AI驾驶行为检测DEMO2019-04-05弹幕微信小程序Demo2019-04-05小程序组件常用组件分享2019-04-02性格测试小程序2019-04-01小程序登录Demo2019-03-26想做一个微信论坛项目2019-03-25新版答题小程序2019-03-21小程序组件常用组件分享2019-03-15\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880736|91cce5f4298ba6b4acb7792b7e9d7e80|2';"}
{"title": "微信小程序 输入框限制字数 ", "author": "Rolan", "pub_time": "2018-2-24 00:38", "content": "想实现的效果如图wxml:   class='suggest_title'>请输入你想反馈的问题   class='suggest_box'>     class='suggest_text' bindinput=\"bindText\" maxlength='200' placeholder='我们有什么地方让您不满意，请输入您的反馈意见' placeholder-class='sug_p'>    {{t_length}}/200   js:  data: {    t_length:0,  },  bindText: function (e) {    var t_text = e.detail.value.length;    // console.log(t_text)    this.setData({      t_length: t_text    })   },"}
{"title": "微信小程序---设计支付密码的输入框 ", "author": "Rolan", "pub_time": "2017-6-16 00:43", "content": "设计支付密码的输入框效果如下：源码：github地址：-\">https://github.com/fiveTree/--干货：<view class=\"pay\"><view class=\"title\">支付方式</view><view catchtap=\"wx_pay\" class=\"wx_pay\"><i class=\"icon {{payment_mode==1?'active':''}}\" type=\"String\"></i><text>微信支付</text></view><view catchtap=\"offline_pay\" class=\"offline_pay\"><i class=\"icon {{payment_mode==0?'active':''}}\" type=\"String\"></i><text>对公打款</text></view><block wx:if=\"{{balance!=0}}\"><view catchtap=\"wallet_pay\" class=\"wallet_pay\"><i class=\"icon {{payment_mode==2?'active':''}}\" type=\"String\"></i><text>钱包支付(余额:{{balance/100}}元)</text></view></block><block wx:if=\"{{balance==0}}\"><view class=\"wallet_pay\"><i class=\"icon\" type=\"String\" style=\"background:#e8e8e8;border:none;\"></i><text style=\"color:#999\">钱包支付(余额不足)</text></view></block></view><view catchtap=\"pay\" class=\"save\">确定</view><!--输入钱包密码--><view wx:if=\"{{wallets_password_flag}}\" class=\"wallets-password\"><view class=\"input-content-wrap\"><view class=\"top\"><view catchtap=\"close_wallets_password\" class=\"close\">×</view><view class=\"txt\">请输入支付密码</view><view catchtap=\"modify_password\" class=\"forget\">忘记密码</view></view><view class=\"actual_fee\"><span>￥</span><text>{{actual_fee/100}}</text></view><view catchtap=\"set_Focus\" class=\"input-password-wrap\"><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=1}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=2}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=3}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=4}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=5}}\"></i></view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=6}}\"></i></view></view></view><input bindinput=\"set_wallets_password\" class=\"input-content\" password type=\"number\" focus=\"{{isFocus}}\" maxlength=\"6\" /></view>//index.jsPage({  data: {    payment_mode: 1,//默认支付方式 微信支付    isFocus: false,//控制input 聚焦    balance:100,//余额    actual_fee:20,//待支付    wallets_password_flag:false//密码输入遮罩  },  //事件处理函数  onLoad: function () {  },  wx_pay() {//转换为微信支付    this.setData({      payment_mode: 1    })  },  offline_pay() {//转换为转账支付    this.setData({      payment_mode: 0    })  },  wallet_pay() {    this.setData({//转换为钱包支付      payment_mode: 2    })  },  set_wallets_password(e) {//获取钱包密码    this.setData({      wallets_password: e.detail.value    });    if (this.data.wallets_password.length == 6) {//密码长度6位时，自动验证钱包支付结果      wallet_pay(this)    }  },  set_Focus() {//聚焦input    console.log('isFocus', this.data.isFocus)    this.setData({      isFocus: true    })  },  set_notFocus() {//失去焦点    this.setData({      isFocus: false    })  },  close_wallets_password () {//关闭钱包输入密码遮罩    this.setData({      isFocus: false,//失去焦点      wallets_password_flag: false,    })  },  pay() {//去支付    pay(this)  }})/*-----------------------------------------------*//*支付*/function pay(_this) {  let apikey = _this.data.apikey;  let id = _this.data.id;  let payment_mode = _this.data.payment_mode  if (payment_mode == 1) {  //  微信支付  // 微信自带密码输入框    console.log('微信支付')  } else if (payment_mode == 0) {  //  转账支付 后续跳转至传转账单照片    console.log('转账支付')  } else if (payment_mode == 2) {    // 钱包支付 输入密码    console.log('钱包支付')    _this.setData({      wallets_password_flag: true,      isFocus: true    })  }}// 钱包支付function wallet_pay(_this) {  console.log('钱包支付请求函数')  /*  1.支付成功  2.支付失败：提示；清空密码；自动聚焦isFocus:true，拉起键盘再次输入  */}index.wxsspage {  height: 100%;  width: 100%;  background: #e8e8e8;}page .pay {  display: flex;  flex-direction: column;  background: #fff;}page .pay .title {  height: 90rpx;  line-height: 90rpx;  font-size: 28rpx;  color: #353535;  padding: 0 23rpx;  border-bottom: 1rpx solid #ddd;  box-sizing: border-box;}page .pay .wx_pay, page .pay .offline_pay, page .pay .wallet_pay {  margin: 0 26rpx;  height: 90rpx;  line-height: 90rpx;  border-bottom: 2rpx solid #ddd;  box-sizing: border-box;  display: flex;  align-items: center;  justify-content: flex-start;}page .pay .wx_pay .icon, page .pay .offline_pay .icon,page .pay .wallet_pay .icon {  width: 34rpx;  height: 34rpx;  border: 2rpx solid #ddd;  box-sizing: border-box;  border-radius: 50%;}page .pay .wx_pay .icon.active, page .pay .offline_pay .icon.active,page .pay .wallet_pay .icon.active {  border: 10rpx solid #00a2ff;}page .pay .wx_pay text, page .pay .offline_pay text, page .pay .wallet_pay text {  margin-left: 20rpx;  color: #353535;  font-size: 26rpx;}page .pay .wallet_pay {  border: 0;  border-top: 2rpx solid #ddd;}page .pay .offline_pay {  border: 0 none;}page .save {  margin: 80rpx 23rpx;  color: #fff;  background: #00a2ff;  height: 88rpx;  line-height: 88rpx;  text-align: center;  font-size: 30rpx;  border-radius: 10rpx;}page .wallets-password {  position: absolute;  left: 0;  top: 0;  width: 100%;  height: 100%;  background: rgba(0, 0, 0, 0.6);}page .wallets-password .input-content-wrap {  position: absolute;  top: 200rpx;  left: 50%;  display: flex;  flex-direction: column;  width: 600rpx;  margin-left: -300rpx;  background: #fff;  border-radius: 20rpx;}page .wallets-password .input-content-wrap .top {  display: flex;  align-items: center;  height: 90rpx;  border-bottom: 2rpx solid #ddd;  justify-content: space-around;}page .wallets-password .input-content-wrap .top .close {  font-size: 44rpx;  color: #999;  font-weight: 100;}page .wallets-password .input-content-wrap .top .forget {  color: #00a2ff;  font-size: 22rpx;}page .wallets-password .input-content-wrap .actual_fee {  display: flex;  align-items: center;  justify-content: center;  color: #000;  height: 100rpx;  margin: 0 23rpx;  border-bottom: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .actual_fee span {  font-size: 24rpx;}page .wallets-password .input-content-wrap .actual_fee text {  font-size: 36rpx;}page .wallets-password .input-content-wrap .input-password-wrap {  display: flex;  align-items: center;  justify-content: center;  height: 150rpx;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot {  display: flex;  align-items: center;  justify-content: center;  text-align: center;  color: #000;  box-sizing: border-box;  width: 90rpx;  height: 90rpx;  border: 2rpx solid #ddd;  border-left: none 0;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot:nth-child(1) {  border-left: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot i {  background: #000;  border-radius: 50%;  width: 20rpx;  height: 20rpx;}page .wallets-password .input-content {  position: absolute;  opacity: 0;  left: -100%;  top: 600rpx;  background: #f56;  z-index: -999;}page .wallets-password .input-content.active {  z-index: -99;}github地址：-\">https://github.com/fiveTree/--"}
{"title": "浅谈微信小程序用setStorage和getStorage缓存和获取数据 ", "author": "Rolan", "pub_time": "2018-6-13 00:11", "content": "每个微信小程序都可以有自己的本地缓存，可以通过 wx.setStorage（wx.setStorageSync）、wx.getStorage（wx.getStorageSync）、wx.clearStorage（wx.clearStorageSync）可以对本地缓存进行设置、获取和清理。同一个微信用户，同一个小程序 storage 上限为 10MB 。localStorage 以用户维度隔离，同一台设备上，A 用户无法读取到 B 用户的数据。数据常用于哪里？对于数据需求较小的历史记录、购物车事件等都可以使用 storage 进行缓存， Storage 将数据存储在本地缓存中指定的 key 中，如果重复会覆盖掉原来该 key 对应的内容 可以参照微信小程序开发手册中的Storage如何使用异步接口进行数据缓存？将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容，这是一个异步接口。OBJECT参数说明：示例代码wx.setStorage({\r\n    key:\"key\",\r\n    data:\"value\"\r\n})当 setStorage 之后可以去到开发者工具里面查看 这是没有保存值的情况可以看到是没有 key值的 那么当我们去进行输入搜索最后再去 storage中查看获取到了一个 key 为 history 的 Array数组 那么再去进行搜索再看看 storage得到了一个数组而且没有被覆盖，那么怎么实现的呢？ 先来看看代码search.wxml\r\n\r\n <view class=\"search-top-input\">\r\n      <input type=\"text\" placeholder=\"搜索公司/职位\" auto-focus=\"true\" value=\"{{inputsearch}}\" \r\n      bindconfirm=\"search\"\r\n      bindinput=\"inputSearchTap\"\r\n      data-index=\"{{index}}\"/>\r\n </view>\r\n \r\n <view class=\"search-history\" wx:if=\"{{status}}\">\r\n        <view class=\"search-history-title\">\r\n              <text>历史搜索</text>\r\n              <image src=\"../../images/delete.png\" bindtap=\"deleteHistory\"></image>\r\n        </view>\r\n        <view class=\"search-history-detail\" >\r\n              <view class=\"history-detail\" wx:for=\"{{history}}\" wx:key=\"{{item}}\" bindtap=\"historySearch\" data-index=\"{{index}}\">\r\n                    <text class=\"detail\" >{{item}}</text>\r\n              </view>\r\n        </view>\r\n </view>\r\n \r\n search.js\r\n \r\n 设置data\r\n \r\ndata: {\r\n    status:false,\r\n    inputsearch:'',\r\n    job:[],\r\n    history:[],\r\n},\r\n \r\n 首先去获取storage中的值\r\n \r\n  onLoad: function (options) {\r\n    var that =this;\r\n    wx.getStorage({\r\n    key: 'history',\r\n    success: function(res){\r\n        that.setData({\r\n          history:res.data,\r\n        })\r\n        if(that.data.history.length==0){\r\n          that.setData({\r\n            status:false\r\n          });\r\n        }else{\r\n          that.setData({\r\n            status:true\r\n          })\r\n         }\r\n      },\r\n      fail: function(res) {\r\n        console.log(res+'aaaaa')\r\n      }\r\n    });\r\n},\r\n \r\n进行搜索和缓存数据到storage中\r\n\r\nsearch:function(e){\r\nvar that =this;\r\nvar sear =this.data.inputsearch;\r\nvar jobs=this.data.job;\r\nvar input = new RegExp(sear);\r\nvar temp = [];\r\nif(sear == ''){\r\n  wx.showToast({\r\n    title: '请输入要搜索信息',\r\n    icon:\"none\",\r\n    duration: 1000\r\n  });\r\n return false;\r\n}else{\r\n   this.data.history.unshift(sear);\r\nwx.setStorage({\r\n  key: 'history',\r\n  data: that.data.history,\r\n  success: function(res){\r\n    that.setData({\r\n      history:that.data.history,\r\n      status:true\r\n    })\r\n    console.log(res.data);\r\n  },\r\n})\r\n  for(let i =0;i<jobs.length;i++){\r\n    if(input.test(jobs[i].job) || input.test(jobs[i].company) || input.test(jobs[i].address)){\r\n      \r\n      temp.push(jobs[i]);\r\n    var detail=temp;\r\n    app.globalData.details=detail;\r\n    }\r\n  } \r\n  if(temp ==''){\r\n     wx.showToast({\r\n    title: '暂无此信息',\r\n    icon:\"none\",\r\n    duration: 1000\r\n    \r\n  });\r\n  this.setData({\r\n    inputsearch:''\r\n  })\r\n  }else if(temp){\r\n    wx.navigateTo({\r\n      url:'../about/about'\r\n    })\r\n    this.setData({\r\n      inputsearch:''\r\n    })\r\n  }\r\n }\r\n},将 storage 中的 key 值设为 hisotrywx.setStorage({\r\n  key: 'history',\r\n  data: that.data.history,\r\n)}定义一个数组 history 空数组去获取 storage 中的值,首先是去查询有没有该 key 值，如果没有则 fail ，那么 history 依然为空数组wx.setStorage({\r\n  key: 'history',\r\n  data: that.data.history,\r\n  success: function(res){\r\n    that.setData({\r\n      history:that.data.history,\r\n      status:true\r\n    })\r\n  },\r\n})返回得到 history 之后再去将 inputsearch 的值添加到 history 中,这里有个误区\r\n可能你会将输入的值inputsearch  push到一个新的空数组，然后再将这个新数组push到history数组中，但这个方法\r\n显然不可行，你添加之后新数组将会存放在history数组的第一个下标的数组下，\r\n对于history数组也就只有两个值好了，回到我要说的，那么如何将 inputsearch 添加到 history 中呢,可以使用 unshift 方法或者 push 方法，这里应该使用 unshift 应该将每个新增值存放在 history 的第一个位置，这是其实就是一个用户体验问题了var that =this;\r\nvar sear =this.data.inputsearch;\r\nthis.data.history.unshift(sear);\r\nwx.setStorage({\r\n    key: 'history',\r\n    data: that.data.history,\r\n      success: function(res){\r\n        that.setData({\r\n          history:that.data.history,\r\n          status:true\r\n        })\r\n        console.log(res.data);\r\n      },\r\n})好了，这样就不会出现“覆盖掉”原来的 key 值的问题了,是不是美滋滋当然还有 setStorageSync 同步接口的问题详情点击这里这里是项目地址查看点击这里如果你觉得对你有所帮助那么给我的 github 项目一个 Star 吧访问点击 这里"}
{"title": "微信小程序动态的加载数据，动态设置导航条，用ES6Promise.all批量上传文件 ... ", "author": "天下雪", "pub_time": "2017-4-14 00:14", "content": "一：动态设置导航条分享者：HaiJing1995，来自原文地址 我们知道微信小程序中设置导航条可以直接在json文件中设置 \"navigationBarTitleText\" = \"String\" 就可以了 但是我们有时可能需要根据不同的情况动态设置导航条。微信小程序给我们提供了一个方法setNavigationBarTitle({      title: \"string\",       success: funciton(res){         ...      }  })  注意这个setNavigationBarTitle方法一定要写在onReady方法中，因为这是页面才完全渲染完成。通常在onLoad中我们是不能对UI进行操作的。setNavigationBarTitle方法中的title如果我们像这样设置静态字符串的话是起不到动态设置导航条的作用 的。 我们可以从onLoad中获取到一个动态变量，那如何将这个变量从onLoad中传递给onReady方法呢？ 我们可以在onLoad中通过this.setData({key: value})将这个变量传递给data，在onReady中再通过this.data.key获得这个变量。二：动态加载数据分享者：冉然，来自原文地址 1、首先要写在js里定义一个全局变量 data: {    datalist: []  },2、请求数据加载，获得整个数组信息    wx.request({      url: httpUrl,      data: {},      success: function (res) {        that.setData({          datalist: res.data.courses        })      },3、在.wxml中调用 数组的调用用：wx:for=\"{{datalist}}\" 数组中的单个变量调用用：{{item.courseTitle}} 数组中有域名的单个变量的调用用：https://360fast-edu.com{{item.pictureUrl}}三：用ES6Promise.all批量上传文件分享者：马小云，来自原文地址 客户端Page({    onLoad: function() {        wx.chooseImage({            count: 9,            success: function({ tempFilePaths }) {                var promise = Promise.all(tempFilePaths.map((tempFilePath, index) => {                    return new Promise(function(resolve, reject) {                        wx.uploadFile({                            url: 'https://www.mengmeitong.com/upload',                            filePath: tempFilePath,                            name: 'photo',                            formData: {                                filename: 'foo-' + index,                                index: index                            },                            success: function(res) {                                resolve(res.data);                            },                            fail: function(err) {                                reject(new Error('failed to upload file'));                            }                        });                    });                }));                promise.then(function(results) {                    console.log(results);                }).catch(function(err) {                    console.log(err);                });            }        });    }});服务端<?phpuse IlluminateHttpRequest;Route::post('/upload', function (Request $request) {    if ($request->photo->isValid()) {        $request->photo->storeAs('images/foo/bar/baz', $request->filename . '.' . $request->photo->extension());        return ['success' => true, 'index' => $request->index];    }});"}
{"title": "教你理解微信小程序的生命周期和运行原理 ", "author": "Rolan", "pub_time": "2017-10-16 08:01", "content": "写微信小程序，他的生命周期不能不知道，不知道小程序就会出现各种bug而无法解决。小助君公众号带你学习小程序的生命周期和运行原理。小程序由两大线程组成：负责界面的线程（view thread）和服务线程（appservice thread），各司其职由互相配合小程序的生命周期借鉴了Android的生命周期，如果你了解过Android的APP开发，那么理解小程序的就会很简单。界面线程有四大状态： 1. 初始化状态：初始化界面线程所需要的工作，包括工作机制，基本和我们开发者没有关系，等初始化完毕就向 “服务线程”发送初始化完毕信号，然后进入等待传回初始化数据状态。2.首次渲染状态：收到“服务线程”发来的初始化数据后（就是 json和js中的data数据），就开始渲染小程序界面，渲染完毕后，发送“首次渲染完毕信号”给服务线程，并将页面展示给用户。3.持续渲染状态：此时界面线程继续一直等待“服务线程”通过this.setdata（）函数发送来的界面数据，只要收到就重新局部渲染，也因此只要更新数据并发送信号，界面就自动更新。4.结束状态：你懂得。服务线程五大状态： 1 初始化状态：无需和其他模块交流，跟小程序开发也没多大关联，此阶段就是启动服务线程所需的基本功能，比如信号发送模块。系统的初始化工作完毕，就调用自定义的onload和onshow， 然后等待界面线程的“界面线程初始化完成”信号。 onload是只会首次渲染的时候执行一次，onshow是每次界面切换都会执行，简单理解，这就是唯一差别。2 等待激活状态：接收到“界面线程初始化完成”信号后，将初始化数据发送给“界面线程”，等待界面线程完成初次渲染。3.激活状态：收到界面线程发送来的“首次渲染完成”信号后，就进入激活状态既程序的正常运行状态，并调用自定义的onReady()函数。 此状态下就可以通过 this.setData 函数发送界面数据给界面线程进行局部渲染，更新页面。4.后台运行状态：如果界面进入后台，服务线程就进入后台运行状态，从目前的官方解读来说，这个状态挺奇怪的，和激活状态是相同的，也可以通过setdata函数更新界面的。毕竟小程序的框架刚推出，应该后续会有很大不同吧。==============================================================================微信小程序 生命周期和页面的生命周期详细介绍转自：http://www.jb51.net/article/103586.htm 微信小程序 生命周期和页面的生命周期详解：1.小程序的生命周期——App.jsApp() 必须在 app.js 中注册，且不能注册多个。所以App（）方法在一个小程序中有且仅有一个。App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。先上代码：赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\nhello_xn\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              Mac下搭建小程序服务器的过程 \n              微信小程序支付c#后台实现 \n            \n             \n            \n                  原作者: IT==挨踢 \n                  来自: csdn \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序学习笔记《一》：页面的生命周期与参数传递\n                                    \n                  • 微信小程序page的生命周期和音频播放及监听\n                                    \n                  • 微信小程序历险记：表单取值为字符串，生命周期，bindtap事件遇上bindtouchend事件，b ...\n                                    \n                  • 微信小程序的事件及生命周期\n                                    \n                  • 微信小程序 生命周期函数\n                                    \n                  • 任务列表中显示\"小程序\"的原理分析\n                                    \n                  • 微信小程序开发之详解生命周期方法\n                                    \n                  • 微信小程序运行流程看这篇就够了\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSwg0L4q', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n微信小程序开发早知道2019-04-04\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880736|91cce5f4298ba6b4acb7792b7e9d7e80|2';"}
{"title": "小程序实现长按删除图片 ", "author": "Rolan", "pub_time": "2018-5-19 00:07", "content": "说明最近在学小程序,遇到长按图片删除的问题,特此记录,记录自己的成长轨迹需求: 长按删除指定图片需要解决的问题长按事件如何表示出来?如何获取当前长按元素的下标?如何删除元素?解决办法长按事件是用bindlongpress(不会跟点击事件bindtap冲突);在wxml中添加索引index,然后在js中用currentTarget.dataset.index获取当前元素下标通过splice方法删除splice(index,1),删除一个当前元素具体实现<view class=\"uploader__files\">\r\n      <block wx:for=\"{{images}}\" wx:key=\"{{item.id}}\" >\r\n            <view class=\"uploader__file\" bindlongpress=\"deleteImage\" data-index=\"{{index}}\">\r\n               <image mode=\"aspectFill\" class=\"uploader__img\" src=\"{{item.path}}\" />\r\n            </view>\r\n      </block>\r\n</view>在wxml中添加 bindlongpress=\"deleteImage\" data-index=\"{{index}}\" 来绑定事件并添加索引indexdeleteImage: function (e) {\r\n    var that = this;\r\n    var images = that.data.images;\r\n    var index = e.currentTarget.dataset.index;//获取当前长按图片下标\r\n    wx.showModal({\r\n      title: '提示',\r\n      content: '确定要删除此图片吗？',\r\n      success: function (res) {\r\n        if (res.confirm) {\r\n          console.log('点击确定了');\r\n          images.splice(index, 1);\r\n        } else if (res.cancel) {\r\n           console.log('点击取消了');\r\n           return false;       \r\n          }\r\n        that.setData({\r\n          images\r\n        });\r\n      }\r\n    })\r\n  }删除部分的代码注意currentTarget与target的区别currentTarget:绑定的事件当前元素及其子元素都会触发target: 绑定的事件 子元素不会被触发事件效果展示"}
{"title": "微信小程序开发之详解生命周期方法 ", "author": "Rolan", "pub_time": "2017-11-21 00:15", "content": "在小程序中 ，通过App()来注册一个小程序 ，通过Page()来注册一个页面先来看一张小程序项目结构从上图可以看出，根目录下面有包含了app.js,app.wxss,app.json三个文件这是小程序的全局文件，app.js是小程序逻辑 ，app.json是小程序公共设置，app.wxss是小程序公共样式表在app.js文件中 ， 定义了一些生命周期方法 ， onLaunch，onShow，onHide，onError，以及任意开发者添加的函数或者数据（通过this可以访问）以下是各个生命周期方法作用和描述onLaunch 生命周期函数--监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）onShow 生命周期函数--监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShowonHide 生命周期函数--监听小程序隐藏 当小程序从前台进入后台，会触发 onHideonError 错误监听函数 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息其他 Any 开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问我们在app.js文件中定义以下方法 ，并打印出来App({\r\n  onLaunch: function (options) {\r\n    console.log(\"app.js ---onLaunch---\" + JSON.stringify(options));\r\n  },\r\n  onShow:function(){\r\n    console.log(\"app.js ---onShow---\");\r\n  },\r\n  onHide:function(){\r\n    console.log(\"app.js ---onHide---\");\r\n  },\r\n  onError: function (msg){\r\n    console.log(\"app.js ---onError---\" + msg);\r\n  },\r\n  globalData: {\r\n    userInfo: null\r\n  }\r\n})这是我们打开一个小程序打印出来的一些方法可以看出， 打开程序依次执行了app.js下面onLaunch和onShow方法，以及page页面中的onLoad，onShow和onReady方法其中 ， onLaunch, onShow 方法会返回一个参数对象， 里面包含了三个参数 ， path,query和scene ，path是打开小程序的路径query是打开小程序页面url的参数，scene是打开小程序的场景值更多场景值可以查看https://mp.weixin.qq.com/debug/wxadoc/dev/framework/app-service/scene.html小程序切换到后台会执行以下2个方法返回小程序前台在page页面中定义的生命周期方法onLoad 生命周期函数--监听页面加载onReady 生命周期函数--监听页面初次渲染完成onShow 生命周期函数--监听页面显示onHide 生命周期函数--监听页面隐藏onUnload 生命周期函数--监听页面卸载Page({\r\n  onLoad: function (options) {\r\n    console.log(\"page ---onLoad---\");\r\n  },\r\n  onReady: function () {\r\n    console.log(\"page ---onReady---\");\r\n  },\r\n  onShow: function () {\r\n    console.log(\"page ---onShow---\");\r\n  },\r\n  onHide: function () {\r\n    console.log(\"page ---onHide---\");\r\n  },\r\n  onUnload: function () {\r\n    console.log(\"page ---onUnload---\");\r\n  }\r\n})其中，打开小程序后会依次执行onLoad，onReady和onShow方法前后台切换会分别执行onHide和onShow方法，当小程序页面销毁时会执行 onUnload方法例如，我们在details.js中定义onUnload方法onUnload: function () {\r\n    console.log(\"details.js  --onUnload\")\r\n  },当我们从首页打开一个新页面details.wxml，然后再关闭着这个页面从上图可以看到页面执行了onUnload方法另外， 小程序为我们提供了全局数据管理 ，在page页面中通过getApp()方法获取app.js实例例如：我们在app.js通过定义一个globalData数据对象App({\r\n  globalData: {\r\n    userInfo: null\r\n  }\r\n})\r\n\r\n// other.js\r\nvar appInstance = getApp()\r\nconsole.log(appInstance.globalData)注意：App() 必须在 app.js 中注册，且不能注册多个。不要在定义于 App() 内的函数中调用 getApp() ，使用 this 就可以拿到 app 实例。不要在 onLaunch 的时候调用 getCurrentPages()，此时 page 还没有生成。通过 getApp() 获取实例之后，不要私自调用生命周期函数。参考文章微信小程序开发详解（七）---微信小程序APP生命周期"}
{"title": "微信小程序开发-rem转换rpx小工具 ", "author": "Rolan", "pub_time": "2018-3-8 09:13", "content": "实现原理：对样式进行格式化，然后根据 “rem” 进行拆分，这样就会拆分成一个数组 [str1,str2,str3...,str6],除了最后一个元素，前边的元素都会以 “rem” 样式的数值结尾，然后在对数组中的元素字符串进行再次根据 “：” 进行拆分，这样就把原rem样式的数字给提取出来了，然后就根据规则转换成rpx的数值，重新组合就好了。css格式化工具：https://tool.lu/css/源码:<!DOCTYPE html><html>    <head>        <meta charset=\"UTF-8\">        <title></title>        <style>            div#newCss{                border:1px solid #999;                width:504px;                height:140px;            }        </style>    </head>    <body>        <script type=\"text/javascript\">            function rem2rpx() {                var oldCss = document.getElementById(\"css\").value.trim(); //\".similar_recommend .title{margin:.3rem 0 0;padding-top:.4rem;color:#666;font-size:.28rem;}\"                //对原样式根据rem进行拆分成数组，这样除了最后一个元素，数组前边的几个元素都是以原rem样式数值结尾                //拆分后的格式：[\".similar_recommend{background:#fff;border-radius:.1\", \";height:7.4\", \";margin-top:-.3\", \"}\"]                var newCssArr = oldCss.split(\"rem\")                 var newCss = \"\" //转换后新的样式变量                for(var i in newCssArr) {                    if(i < newCssArr.length - 1) {                        //非最后一个元素，对字符串按照:再次拆分，把rem样式的数值分离出来进行转换                        var str = newCssArr[i]                        var idx = str.lastIndexOf(':')                        var prevStr = str.substring(0, idx + 1)                        var nextStr = \"\"//nextStr格式为    -.3 , -3 , 3 , .3                        if(str.indexOf('-.')>-1){                             //nextStr格式为-.3rem或-3rem                            nextStr = str.substring(str.indexOf(':-')+2, str.length)                            //nextStr格式为.3rem或3rem                            if(nextStr.indexOf('.')>-1){                                nextStr =\"0\"+ nextStr                            }                            nextStr = \"-\"+parseInt(nextStr * 100) + \"rpx\"                        }else{                            nextStr = str.substring(idx + 1, str.length)                            nextStr = nextStr.indexOf('.') > -1 ? \"0\" + nextStr : nextStr                            nextStr = parseInt(nextStr * 100) + \"rpx\"                        }                        //重组数组内的样式字符串                        newCss += prevStr + \"\" + nextStr                    }else{                        //追加最后一个数组元素                        newCss+=newCssArr[i]                    }                }                document.getElementById(\"newCss\").innerHTML=newCss            }        </script>        <h4>rem样式</h4>        <textarea id=\"css\" cols=\"60\" rows=\"10\"></textarea>        <br />                <input type=\"button\" value=\"rem转换rpx\" onclick=\"rem2rpx()\" />        <h4>转换后的样式</h4>        <div id=\"newCss\"></div>    </body></html>"}
{"title": "支付宝小程序日期选择组件 datePicker 封装 ", "author": "Rolan", "pub_time": "2018-8-6 00:12", "content": "项目地址 https://github.com/iocool/antminDatePicker另博客地址 https://www.cnblogs.com/iocool/p/9397816.html最近在做支付宝小程序(以下简称小程序)开发,发现小程序的日期选择组件很不好用,比如安卓和IOS设备上,样式明显不同,因为小程序调用该组件是调用系统原生组件,所以会有一定的差异,另外,小程序提供的日期组件并不满足我当前的业务需求:该日期为快递上门时间.用户只可选择的日期范围,当日往后 2 天(即 今天 , 明天 )的日期,并且时间选择为早上 9 点至下午 18 点间的 10 个小时整点时间.由于是快递上门,所以可选择的时间点为当前时间点 2 小时后(比如,现在时间是11点,用户可选择的最早时间为13点).如果当前时间晚于下午 18 点,则用户应该可以看到 明天 及 后天 2 天的时间点.针对以上需求,借助小程序的 picker-view 组件,进行了二次封装,以下是封装后的组件.示例项目结构.\r\n├── README.md\r\n├── app.acss\r\n├── app.js\r\n├── app.json\r\n├── components                      // 组件目录\r\n│   └── dateTimePicker              // 日期组件目录\r\n│       ├── datePickerBase.js       // 基础 js 文件,需在使用文件中引入\r\n│       ├── dateTimePicker.acss     // 组件默认样式,除非特殊需要,一般不用修改\r\n│       ├── dateTimePicker.axml     // 组件默认结构\r\n│       ├── dateTimePicker.js       // 组件 js \r\n│       ├── dateTimePicker.json     // 组件配置信息\r\n│       └── js\r\n│           ├── handleDateArr.js    // 日期数组处理的 js ,用以生成所需的日期数组\r\n│           └── moment.min.js       // 时间生成使用 moment.js\r\n│\r\n└── pages                         // 示例目录\r\n    └── index\r\n        ├── index.acss\r\n        ├── index.axml\r\n        ├── index.js\r\n        └── index.json\r\n\r\n复制代码使用说明支付宝小程序的组件引用方法,及使用说明,可参照 支付宝使用自定义组件 查看,也可参照本示例中 pages/index 下的使用方法.pages/index/index.json 需配置 usingComponents , 填写组件路径{\r\n    \"defaultTitle\": \"日期选择picker demo\",\r\n    \"usingComponents\": {\r\n        \"picker\": \"../../components/dateTimePicker/dateTimePicker\"\r\n    }\r\n}\r\n复制代码pages/index/index.js 引入基础文件,详细配置及使用说明,参照 js 文件内容// 引入基础初始\r\nimport datePicker from '../../components/dateTimePicker/datePickerBase'\r\n\r\n复制代码pages/index/index.axml 使用 picker 组件<picker\r\n        title=\"{{datePicker.title}}\"\r\n        class=\"{{datePicker.class}}\"\r\n        visible=\"{{datePicker.visible}}\"\r\n        onHidePicker=\"hidePicker\"\r\n        onConfirm=\"onConfirm\"\r\n        pickerValue=\"{{datePicker.defaultValue}}\"\r\n/>\r\n复制代码其中title           // 组件标题\r\nclass           // 组件样式,可以自定义\r\nvisible         // 组件显示/隐藏\r\nonHidePicker    // 隐藏该组件的事件\r\nonConfirm       // 点击组件弹窗确定后的事件,onConfirm(str),其中 str 为最终回调的参数,可取到 picker 的值\r\npickerValue     // 默认参数,用来初始的时候用,传入数据是 picker 的索引值,默认(0,0),即 默认选中两列 picker 的第一项\r\n复制代码一些其他的说明组件的封装过程中,由于采用的是支付宝的 picker-view 所以在界面上没有花过多的时间,主要可能还是日期时间数组的生成需要处理一下,借助了 moment.js 库,对于时间处理上还是很方便的,以下是对处理日期数组 handleDateArr.js 的代码说明.// 依赖于 moment.js\r\nconst Moment = require('./moment.min')\r\n\r\n/**\r\n * 生成日期时间数组\r\n * @param dayLength // 要生成的天数时长,不传的话,默认生成 1 天\r\n * @param timeSection // 时间区间,默认 10 , 可下单区间早上9点到下午6点,可下单时间在当前小时后2小时\r\n */\r\nfunction getDaysArr(dayLength, timeSection){\r\n  let _daysArr = [[],[]]\r\n  let _dayLength = dayLength || 1\r\n  const _timeSection = timeSection || 10\r\n  const _nowHour = Moment().format('HH')  // 当前时间 小时\r\n  const _expressHour = parseInt(_nowHour) + 2 // 可下单时间,当前时间 +2\r\n  const _earlyHour = 9  // 最早时间\r\n  const _endHour = 19 // 截止时间\r\n\r\n  for(let i = 0; i < _dayLength; i++){\r\n\r\n    // 当天时间处理\r\n    if( i === 0){\r\n\r\n      if(_expressHour <= _earlyHour ){\r\n\r\n        // 早于早上 9点时\r\n        _daysArr[1].push(getHoursArr(_earlyHour, _timeSection))\r\n\r\n        // 处理日期\r\n        _daysArr[0].push(Moment().add(i, 'days').format('YYYY-MM-DD'))\r\n\r\n      } else if( _expressHour > _earlyHour && _expressHour < _endHour){\r\n\r\n        // 晚于早上 9 点, 早于下午 18 点之前\r\n        _daysArr[1].push(getHoursArr(_expressHour, (_endHour - _expressHour)))\r\n        // 处理日期\r\n        _daysArr[0].push(Moment().add(i, 'days').format('YYYY-MM-DD'))\r\n      } else if ( _expressHour >= _endHour && _expressHour < 24){\r\n\r\n        // 超过晚上 19 点之后,日期天数增加一天\r\n        _dayLength++\r\n\r\n      }\r\n\r\n    } else {\r\n      // 其他日期时间处理\r\n\r\n      // 早于早上 9点时\r\n      _daysArr[1].push(getHoursArr(_earlyHour, _timeSection))\r\n      // 处理日期\r\n      _daysArr[0].push(Moment().add(i, 'days').format('YYYY-MM-DD'))\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * 获取小时时间数组\r\n   * @param nowHour // 当前小时\r\n   * @param hoursLength // 小时区间长度\r\n   */\r\n  function getHoursArr(nowHour, hoursLength) {\r\n    let _hoursArr = []\r\n    for(let j = 0 ; j < hoursLength; j++){\r\n      _hoursArr.push(`${nowHour + j}:00:00`)\r\n    }\r\n    return _hoursArr\r\n  }\r\n\r\n  return _daysArr\r\n}\r\n\r\nmodule.exports = {\r\n  getDaysArr\r\n}\r\n\r\n复制代码在 dateTimePicker.js 文件中使用 handleDateArr.js 的方法...\r\n\r\nconst { getDaysArr } = require('./js/handleDateArr');   // 引入处理函数\r\n\r\nComponent({\r\n  data: {\r\n    ...\r\n  },\r\n  methods: {\r\n\r\n    // 获取日期数据\r\n    doGetDaysArr() {\r\n      this.setData({\r\n        dateTimeData: getDaysArr(2)     // 传入参数,需返回的日期天数,2天\r\n      });\r\n    }\r\n  }\r\n});\r\n...\r\n\r\n复制代码以上就是该组件的基本说明,代码相对比较简单,觉得可以给目前在做支付宝小程序并有相关需要的童鞋参考一下."}
{"title": "支付宝小程序PHP全栈开发--前端样式的设计.acss样式详解 ", "author": "Rolan", "pub_time": "2017-9-6 00:31", "content": "关于.acss文件在视频中已经说过了，小程序的设计思想和原生app的设计思想颇为相似，基本的应用单元为页面。当然对于一个页面来说每一个元素的放置位置在哪儿以及显示成什么样子这个是由样式来决定的。我们知道在web开发中样式是在css文件中规定的，叫做层叠样式表 (Cascading Style Sheets)。其实在APP中样式的约束也是使用css，在支付宝小程序中也是使用css不过文件的后缀是.acss而且对css3进行了扩充而已。CSS3是CSS技术的升级版本，CSS3语言开发是朝着模块化发展的。以前的规范作为一个模块实在是太庞大而且比较复杂，所以，把它分解为一些小的模块，更多新的模块也被加入进来。这些模块包括： 盒子模型、列表模块、超链接方式 、语言模块 、背景和边框 、文字特效 、多栏布局等。那么在支付宝小程序中的.acss和微信小程序中的.wxcss没有什么两样。上边已经说了.acss其实包含了css3那么它还有一些新的特性是css3中不具备的，让我们一一看看rpx第一次看到这个东西也能猜到他是干什么用的。在css中我们知道规定大小一般使用像素(px)这个单位。比如显示生活中我们说房子128㎡那这儿的单位是平方米，在开发中需要更加精准的大小就是px像素。像素就非常精细了因为在我们显示屏幕中像素是最小的显示单元。这个道理如果不懂的话就找个LED屏幕仔细看，LED屏幕上一个一个的发光二极管可以想象为像素。px为单位导致的问题我们知道手机屏幕有大有小，就拿iPhone来说，iPhone 6 plus比iPhone 5要大。那么就说明plus的像素比5要多。对比：iPhone 6 plus和iPhone5的尺寸对比手机宽度高度手机宽度高度iPhone 6 plus414px736pxiPhone 5320px568px加入有一个160px宽度的红色矩形在这两种手机中的位置如下：那么rpx的特殊之处在哪儿呢？rpx（responsive pixel）可以根据屏幕宽度进行自适应。如何自适应呢？看下边的分析：不管一个屏幕有多宽我们可以对屏幕平均分配吧。既然iPhone 6 plus宽度为414px，iPhone 5的宽度为320px。如果创建一个宽度为160px的矩形那么在iPhone 5 中占有一半的宽度，但是在iPhone 6 plus中不足一半，在手机显示中不是很好看。那么我们不管屏幕多宽都给他分750份。那么在iPhone 6 plus中每一份就是414/750=0.552px 而对于iPhone 5的每一份就是320/750=0.42px。那现在我们规定大小和位置时不使用px而使用份数来表示如何呢？比如我们规定一个红色的矩形在iPhone 6 plus中占有375份(375x0.552=207px)，在iPhone 5中也是325份(375x0.42=157.5px)。 再来看看，都占有375份的情况下iPhone 6 plus中的宽度207px（约占有总宽度414px的50%），而iPhone 5中的宽度157.5px（约占有总宽度320的50%）。也就是在两个不同尺寸的屏幕上当以份数来规定是占有的比例是差不多的。而这个份数就是rpx看下图：样式导入在模块化开发中我们有时候不得不在页面中使用其他的第三方库的样式，而第三方库的样式是保存在第三方包中的，我们不可能全部复制到我们的.acss文件中，那最好的办法就是导入了。在样式表中导入其他外联样式表。@import \"./button.acss\";\r\n.md-button {\r\n  padding:15px;\r\n}1234当然仍旧支持内联样式和class属性制定样式类，如<view class=\"my-awesome-view\" />\r\n<view class=\"my-awesome-view\" style=\"color:red;\" />12选择器选择器和css3的保持一致。一般有class=”test”类选择器和id=”test”的id选择器。当然在支付宝小程序的样式中特殊的地方就是： ※ .a- 或者 .am-为前缀的选择器已经被系统占用所以不要使用； ※ 不能使用属性选择器，例如,以下写法不被支持：//这种选择器不被支持\r\ninput[name=\"title\"]{\r\n    color: test;\r\n}1234全局样式与局部样式在项目结构讲解时我们已经说过在项目根目录下有一个app.acss文件这个样式文件中定义的样式在任何一个页面中都可以直接使用。页面容器的样式我之前说过小程序开发的应用单元为页面。其实我们在.axml中写的页面并不包含页面容器，就相当于我们做一个页面但是body标签不用写那如果我们要改变整个页面的背景怎么办呢?其实有一个固定的选择器。例如：可以通过 page 元素选择器来设置页面容器的样式，比如页面背景色:page {\r\n  background-color: red;\r\n}123在你想改变页面容器的页面中定义该样式也可以，全局定义也可以，例如我想将test这个页面的页面容器背景设置为蓝色，就可以再pages目录下的test目录下找到test.acss在其中定义page的样式下节是视图层讲解，如果有任何问题可以再下方给我留言或者发邮件到weiyongqiang@weiyongqiang.com我在收到邮件后会回复。"}
{"title": "案例研究｜一款APP的UX & UI设计全过程 ", "author": "Rolan", "pub_time": "2018-5-22 00:03", "content": "照片是记录生活的方式之一，使用智能手机的人们可以拍成千上万张照片，再也不用担心错失美好瞬间了。手机APP为人们的摄影爱好提供了支持，提供诸如图像编辑等各种功能。如今，修图的需求是很高的，这也是为什么很多设计师都会接触到这类项目的原因。修图APP的主要用户群体就是年轻人，很多女孩都喜欢自拍并且通过特殊的效果和组件美化自拍照。今天就来给大家分享一款针对年轻人的修图软件的设计过程。UI设计师Tania Bashkatova和平面设计师Yaroslava Yatsuba是这次任务的主要执行人员。任务一款修图APP的UI和UX设计。流程设计师接到的任务是为一款可以一键自拍、修图的APP做UI、UX设计，APP名为Cuteen，针对15-35岁的女性群体，slogan为：“遇见最美的自己”。主要任务是为该APP的六个基本功能创建智能化的用户体验，并进行现代化、年轻化、女性化和趣味化的UI设计。此外，我们的团队决定创建一组自定义图标并在用户界面中使用鲜艳的是色彩。在创新流程开始之前，设计师们首先进行了市场和用户调研。这个过程能收集核心信息，从而创造出符合用户期望的产品。基于调研结果和头脑风暴，设计师的思想体现在基本的UX解决方案和风格偏好上。UX设计之前的设计师的任务是以一种每个人都可以直观地进行编辑的方式组织和呈现所有功能。为了使这个过程更有效率，设计者创建了线框图来展示信息构架的未来布局，线框图是最简单最快速可视化展示APP屏幕和跳转原理的方式，线框图能够帮助开发者和客户清晰地理解APP的布局框架。Cuteen APP需要得到有效展示的基本功能有六项，设计师们提供了两种布局方案：第一个包含屏幕顶部的圆形横幅和品牌名称，设计师设计了几种基本功能图标以及CTA 照片按钮的放置方式。CTA按钮必须显眼，这样用户才会将其视为界面的主要交互元素。该方案显示了三种UI组件放置方式，第一种，“相机”按钮与其他功能是分开展示的；后两种不一样，“相机”按钮与其他功能是连接在一起的。第二种方案的重点是功能展示，顶部横幅被移除了，图标放置在屏幕的顶端，CTA按钮放在中间的位置。这种结构使用户能够集中注意力，减少所有可能的干扰并使导航更直观。此外，设计师还制作了一个显示最近流行效果的原始Feed，用户可以一键应用最佳功能。这两个方案都有它们的优点和好处，因此设计人员决定在UI设计阶段再决定到底选用哪一种。UI设计UI设计的主要方法包括时尚和娱乐视觉风格的结合，考虑到该APP面向年轻女性用户，设计师决定使用明亮的色彩创建UI组件以及渐变效果。用于CTA按钮和一些其他UI组件的中心颜色为粉红色，粉色与与美丽，敏感和年轻女性气质密切相关，所以如果目标是年轻女性的话，粉色是个好选择。六个功能图标使用了六种对比色，这样一来每一种颜色都代表了一种特定的功能，用户即使不去看图标下面的文字说明也能迅速明白每个图标是干嘛的。此外，为了让整个用户界面看起来温和愉悦，设计师使用白色背景将平衡带入视觉构图。我们来看看一些效果图：经过多次创造性探索之后，设计师选择了上图中没有横幅的第三种设计方案。在这种结构中，交互区域非常明显并且在逻辑上与其他区域是分离的。另外，第二个版本作为附加选项提供，用户可以随时随地切换。在第二种版本的布局中，用户注意力会集中在自定义图标上。总而言之，CuteenAPP的用户界面看起来明亮且充满活力，并且拥有简单的交互系统、原始Feed和自定义图标集。自定义图标设计主要目的是设计一套原创图标，让这款产品在竞争对手中脱颖而出，平面设计师接受了这项有趣的挑战。为了节省时间并且充分发挥想象力，插图画家开始用手绘草图。设计师提供了三套不同风格的图标，并为每个功能提供了各种概念。下面是草图：设计师选择了下图中的第二种方案，手绘草图转换成了电子版的，所有的细节都得到了解决。自定义图标是APP可识别性的有效组成部分，而且，他们支持界面中基本文体解决方案的一致性。设计师制作了两种图标——完整的和简约的：完整的图标使布局风格多彩，看起来非常明亮；简约的图标用于基本布局款。使用闭合技术，设计师可以使图标看起来充满活力，从而可以感受到冻结运动的感觉，这种技术是基于人眼倾向于看闭合形状。闭合适用于物体不完整，但用户通过填充缺失部分将其视为完整形状的情况，该技术与我们在设计心理学中描述的格式塔原理相关。总结一下，最小的细节往往决定着APP的设计是否强大，因此设计师应该关注所有UI组件，包括图标和按钮。 作者：Tubik Studio原文链接：https://uxplanet.org/case-study-cuteen-ui-and-ux-design-for-a-mobile-photo-editor-16bca220a8d0翻译：熊小熊，微信公众号：集创堂本文由 @熊小熊 翻译发布于人人都是产品经理。未经许可，禁止转载题图来自 unsplash，基于 CC0 协议"}
{"title": "微信小程序请求API接口PHPSESSID变化的解决方式 ", "author": "Rolan", "pub_time": "2018-4-18 00:21", "content": "微信小程序开发，请求服务器API的方法使用的是微信官方提供的wx.request()方法。在开发中发现，每一个请求都会生成一个独立的PHPSESSID，如下图示：搜索后得知，这是由于wx.request()造成的。如果直接使用浏览器请求并不会出现这种情况。解决方式如下：　　通过登录接口获取到用户的session_key 和 open_id，设置session信息如下：　　$3rd_session = md5(session_key . $open_id)\r\n　　$_SESSION[$3rd_session ] = session_key . '|' . $open_id;　　服务器生成此用户的session_id，接口返回 3rd_session 和 session_id。　　在其他接口请求中，在header中设置cookie的值：session_id：　　header = header || {\r\n    　　'content-type': 'application/x-www-form-urlencoded;',\r\n    　　'Cookie': 'PHPSESSID=session_id值'\r\n　　}           　　并在接口中带上参数session=3rd_session，此时服务端获取到的就是同一个session_id，根据3rd_session从$_SESSION得到用户的openid"}
{"title": "微信小程序图片预加载组件 wxapp-img-loader ", "author": "Rolan", "pub_time": "2018-10-18 00:25", "content": "由于微信小程序没有提供类似 Image 这样的 JS 对象，要实现图片的预加载要麻烦一些， wxapp-img-loader自定义组件可以在微信小程序中实现图片预加载功能。使用1、下载 wxapp-img-loader项目源代码（https://github.com/o2team/wxa...），将 img-loader 目录拷贝到你的项目中2、在页面的 WXML 文件中添加以下代码，将组件模板引入<import src=\"../../img-loader/img-loader.wxml\"/>\r\n<template is=\"img-loader\" data=\"{{ imgLoadList }}\"></template>\r\n3、在页面的 JS 文件中引入组件脚本const ImgLoader = require('../../img-loader/img-loader.js')\r\n\r\n4、实例化一个 ImgLoader 对象，将 this(当前 Page 对象) 传入，第二个参数可选，为默认的图片加载完成的回调方法this.imgLoader = new ImgLoader(this)\r\n\r\n5、调用 ImgLoader 实例的 load 方法进行图片加载，第一个参数为图片链接，第二个参数可选，为该张图片加载完成时的回调方法。图片加载完成的回调方法的第一个参数为错误信息（加载成功则为 null），第二个参数为图片信息（Object 类型，包括 src、width 及 height）。this.imgLoader.load(imgUrlOriginal, (err, data) => {    console.log('图片加载完成', err, data.src, data.width, data.height)\r\n})\r\nwxapp-img-loader组件可以加载单张图片、也可以加载多张图片。运行效果：其他wxapp-img-loader项目地址：https://github.com/o2team/wxa..."}
{"title": "各种小程序的组件机制差异 ", "author": "Rolan", "pub_time": "2018-10-18 00:12", "content": "在蚂蚁金服的开放平台上看到一些贴子，说提供一个工具，一键转换微信小程序为支付宝小程序。我与百度的人交流时，也听到相似的东西。其实都没有这么简单，它们最多是将一些循环条件分支指令改一下名，将一些文件的后缀名改一下，更多的差异点在API与各式的配置对象上，细节是魔鬼，我在娜娜奇的官网也列举了许多相关的东西，但也不能打票说已经很齐全。。。。各种小程序的差异点-文档补充一句，娜娜奇是我们公司的小程序开发框架，以React方式转译成各种小程序与快应用的框架。类似于京东的taro。最近忙于支付宝小程序的开发，我得到许多有关小程序的一手资料，包括自己测试得到的，及从百度，小米快应用与支付宝内部人士提供的。本文将重点说一下小程序的组件机制，之前娜娜奇的组件机制是基于template标签实现的，但百度的template有点BUG，给他们提了，不知现在修了没有。与template机制在快应用又出入太大，于是转向用自定义组件机制开发娜娜奇的组件机制。下面链接有一些相关的测试与说明转换小程序 · Issue #133 · RubyLouvre/anu经测试，使用了自定义组件机制的确是比template实现的简洁一些。但自定义组件机制是一个比较高级的特性，因此兼容性上比template差多了。只能内部推到各方改进了。微信在Component的配置对象提供了一些对象如methods， lifetimes，pageLifetimes，来减少其直辖的配置项。比如说lifetimes收纳了created、attached、ready、moved、detached这些生命周期钩子，pageLifetimes收纳了onShow, onHide这些与页面切换的钩子，methods收纳剩下的方法，另外还有许多配置项。的确，微信小程序独自发布这么久，肯定是最完善的支付宝的自定义组件机制没有properties，只有props，并且作用也不一样，props只是指定默认值，不是规定参数类型。支付宝也没有lifetimes与pageLifetimes对象，生命周期函数的名字也不一样 didMount 、didUpdate 、didUnmount，数量也少了，但从名称来看，支付宝在内部应该运行一个自己的迷你React。其他方面，支付宝没有 dataset， selectComponent，selectAllComponents，getRelationNodes这些东西，但支持了早被React废弃的mixin机制。支付宝没有created这样的钩子是相当麻烦的事，因此积级推动他们加上这个钩子！百度的自定义组件机制与微信的较为相近，但也没有lifetimes与pageLifetimes对象，只有4种生命周期钩子：created，attached，ready，detached。有selectComponent，selectAllComponents。快应用的页面与组件的配置对象都是一样，但它没有构造函数，只是要求我们export一个对象有props对象，用来定义类型与默认值，也有与state相似的data对象，也有三个做了访问限制的private, protected, public对象。生命周期钩子上有onInit、onReady、onDestroy这三个。从组件的设计来看， 微信 > 百度 > 支付宝 > 快应用因此想兼容这么多种小程序，我们必须自己写一个工厂方法，根据不同的平台生成不同的配置项，并且放弃掉一些微信的强大功能了。var hooksName = {\r\n\twx: ['created', 'attached', 'detached'],\r\n\tbu: ['created', 'attached', 'detached'],\r\n\tali: ['didMount', 'didMount', 'didUnmount'],\r\n\tquick: ['onInit', 'onReady', 'onDestroy'],\r\n};\r\n\r\nexport function registerComponent(type, name) {\r\n\tregisterComponents[name] = type;\r\n\tvar reactInstances = (type.reactInstances = []);\r\n\tvar wxInstances = (type.wxInstances = []);\r\n\tvar hooks = [\r\n\t\tfunction created() {\r\n\t\t\tvar instance = reactInstances.shift();\r\n\t\t\tif (instance) {\r\n\t\t\t\tconsole.log('created时为', name, '添加wx');\r\n\t\t\t\tinstance.wx = this;\r\n\t\t\t\tthis.reactInstance = instance;\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('created时为', name, '没有对应react实例');\r\n\t\t\t\twxInstances.push(this);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction attached() {\r\n                        if(appType == \"ali\"){\r\n                            created.call(this)\r\n                        }\r\n\t\t\tif (this.reactInstance) {\r\n\t\t\t\tupdateMiniApp(this.reactInstance);\r\n\t\t\t\tconsole.log('attached时更新', name);\r\n\t\t\t} else {\r\n\t\t\t\tconsole.log('attached时无法更新', name);\r\n\t\t\t}\r\n\t\t},\r\n\t\tfunction detached() {\r\n\t\t\tthis.reactInstance = null;\r\n\t\t},\r\n\t];\r\n\tvar data = {\r\n\t\tprops: {},\r\n\t\tstate: {},\r\n\t\tcontext: {},\r\n\t};\r\n\tvar config = {\r\n\t\tdata: data,\r\n\t\tpublic: data,\r\n\t\tdispatchEvent: eventSystem.dispatchEvent,\r\n\t\tmethods: {\r\n\t\t\tdispatchEvent: eventSystem.dispatchEvent,\r\n\t\t},\r\n\t};\r\n\thooksName[appType].forEach(function(name, index) {\r\n\t\tconfig[name] = hooks[index];\r\n\t});\r\n\r\n\treturn config;\r\n}"}
{"title": "微信小程序--location API ", "author": "Rolan", "pub_time": "2017-9-26 00:47", "content": "location API也就分这里分两种wx.getLocation(object)获取当前位置和wx.openLocation(object)通过经纬度打开内置地图。其中定位获取位置信息返回参数是有问题的speed，accuracy这两个是没有的。还有一个就是打开内置地图之后再返回会报一个错误(Page route错误—WAService.js:2 navigateBack 一个不存在的webviewId0)如果有知道的可告知，我找到解决方式也会补充下！主要属性：wx.getLocation(object)获取当前位置成功之后返回参数wx.openLocation(object)打开微信内置地图这里直接进入微信内置应用，当使用导航返回键时是内部写的外界无法干预所以WAService.js:2 navigateBack 一个不存在的webviewId0这个错估计也带等小程序修复吧！！wxml<button id=\"0\" type=\"primary\" bindtap=\"listenerBtnGetLocation\">定位当前位置并打开内置地jsPage({  data:{    text:\"Page location\"  },  onLoad:function(options){    // 页面初始化 options为页面跳转所带来的参数  },  /**   * 监听定位到当前位置   */  listenerBtnGetLocation: function() {    wx.getLocation({      //定位类型 wgs84, gcj02      type: 'gcj02',      success: function(res) {        console.log(res)        wx.openLocation({          //当前经纬度          latitude: res.latutude,          longitude: res.longitude,          //缩放级别默认28          scale: 28,          //位置名          name: '测试地址',          //详细地址          address: '火星路24号',          //成功打印信息          success: function(res) {            console.log(res)          },          //失败打印信息          fail: function(err) {            console.log(err)          },          //完成打印信息          complete: function(info){            console.log(info)          },        })      },      fail: function(err) {        console.log(err)      },      complete: function(info) {        console.log(info)      },    })  },  onReady:function(){    // 页面渲染完成  },  onShow:function(){    // 页面显示  },  onHide:function(){    // 页面隐藏  },  onUnload:function(){    // 页面关闭  }"}
{"title": "小北微信小程序教程之-- 服务器端接口restful配置 ", "author": "Rolan", "pub_time": "2018-1-10 00:31", "content": "说干咱就干，老沙灰常高兴的开始了，在这一篇老沙将带着你完成yii2程序的restful配置过程。\r\n\r\nRESTful\r\n老沙计划使用 xgh.nai8.me/xcx 作为接口的基本地址，将来会有比如\r\n\r\nGET xgh.nai8.me/xcx/albums\r\nGET xgh.nai8.me/xcx/albums/… \r\n....\r\n\r\n类似的url，这样是符合restful。\r\n为了以后版本化，将每个版本的接口以模块的形式建立，当然建立支持restful和建立普通的模块并没有差别，使用gii的模块生成即可。\r\n此处省略好几个字，模块建立完成。\r\nalt\r\nyii2框架内置是支持restful规范的，按照yii2的规则做我们可以轻松实现比如数据表数据的获取、插入、更新、删除等基础操作以及登录验证等功能。\r\n也就是说我省了很多事情~~，当然我们还是需要简单配置的，这个配置主要是urlManager及模块控制器的继承问题。\r\nurlManager\r\n如果要实现上面的url样子，我们必须进行url美化，这需要web服务器的支持（apache&nginx如何支持url重写可以参考 速查表），单单这样还不够，yii2提供了restful专有的url规范，需要按照它的要求配置。\r\n对于一般的restful规则的yii2路由配置如下图alt\r\n红色框内的代表一个标准restful中控制器路由规则，绿色框内是你必须要填写的，其他的except、pluralize、extraPatterns非必填，具体使用场景以后用到会说明。\r\n这里要说明的参数是pluralize，在restful使用上一直存在两种观点，就是对于资源在url上的表现应该是单数还是复数问题，yii2默认是复数形式，如果你想使用单数可以将pluralize设置为false即可。\r\n在pluralize=false的情况下url是类似于 GET xgh.nai8.me/xcx/album 的样子。\r\n在我们设置了urlManager后，yii2就变得智商满满了，当过来一个 GET xgh.nai8.me/xcx/albums 请求后，yii2知道这是一个要获取资源结果集的请求，则会去调用xcx模块下的album控制器的actionIndex，以此类推yii2提供了很多个内置的action识别，具体见下图\r\nalt\r\n当然具体如何实现的你可以参考 yii\\rest\\UrlRule.php 类及yii2的actions函数。\r\n\r\n小提示：在兄弟连PHP原创视频中对这个原理也进行了详细的解析（《Yii2的RESTful讲解》第三节）\r\n\r\n配置控制器\r\nurlManager配置完成，接下来就是写一个控制器了，老沙对此很熟悉，不就是一个继承问题么！！！\r\n是的，这是一个继承问题，如果你想让yii2支持restful，请将对应控制器继承到 yii\\rest\\ActiveController 上，最简单的一个具有restful资源操作能力的控制器如下图。\r\nalt\r\n是的，就是这样，当控制器继承于 ActiveController 在指定一个$modelClass后，这个控制器就可以对 $modelClass 对应的数据表进行列表、详情、生成、更新、删除等操作，而你无需再写任何对应代码，简单吧~~\r\n这里要注意几点\r\n第一：必须指定$modelClass，每个控制器代表一种资源，隐身就是一个数据表中的数据或你操作系统的文件云云，总之它是一种资源。\r\n第二：这里的AblumController就是urlMananger中的'controller' => 'xcx/album', 控制器的名字于单复数的设置无关。\r\n完事了\r\n简单配置后，老沙搞定了服务器端的配置，接下来他计划使用小程序和yii2实现一个队相册列表的功能实现，下一篇告诉你。"}
{"title": "微信小程序require 引用 BASE64.JS 失败问题的分析解决 ", "author": "halfyawn", "pub_time": "2016-11-25 19:16", "content": "# 问题\r\n有朋友问,  微信小程序require ('base64.js')文件时，会失败,,,\r\n\r\n# 分析\r\n事实上，微信小程序require很多JS模块都有不兼容现象。。。先从base64.js这个模块入手吧。\r\n调试出错点:\r\n~~~~\r\n(function(global) {\r\n    'use strict';\r\n    // existing version for noConflict()\r\n    var _Base64 = global.Base64;  // 这句出错了...变量global的值是传入的this指针值,this指针为空了.\r\n    var version = \"2.1.9\";\r\n    // if node.js, we use Buffer\r\n    var buffer;\r\n\r\n~~~~\r\n调试了一下，主要现象\r\n   base64.js 代码里面假定了this指定非空。微信小程序require调入进来后，this指针为空，就会抛出异常。\r\n\r\n( 对于微信小程序模块化的机制与require，，参见本人写的另一篇文字：关于微信小程序require机制的浅析   https://segmentfault.com/a/1190000007586766)\r\n\r\n# 处理\r\n\r\n知道这个修改就较容易了：\r\n两处改动：\r\n\r\n一 避免global为空指针\r\n~~~~\r\n代码头部几行\r\n(function(global) {\r\n    'use strict';\r\n    // existing version for noConflict()\r\n    var _Base64 = global.Base64;\r\n    var version = \"2.1.9\";\r\n~~~\r\n添加两行改为\r\n~~~\r\n(function(global) {\r\n    'use strict';\r\n    // existing version for noConflict()\r\n    var _Base64 = global.Base64;\r\n    var version = \"2.1.9\";\r\n    if (!global)\r\n        global = {}\r\n\r\n~~~\r\n二 添加module.exports\r\n\r\n~~~\r\n文件尾部几行\r\n    }\r\n    // that's it!\r\n    if (global['Meteor']) {\r\n        Base64 = global.Base64; // for normal export in Meteor.js\r\n    }\r\n })(this);\r\n~~~\r\n添加一行\r\n~~~\r\n    }\r\n    // that's it!\r\n    if (global['Meteor']) {\r\n        Base64 = global.Base64; // for normal export in Meteor.js\r\n    }\r\n    module.exports = global.Base64;\r\n})(this);\r\n\r\n~~~\r\n\r\n\r\n然后在微信小程序里面调用测试：\r\n\r\n~~~\r\n    var base64 = require(\"../../utils/base64.js\");\r\n    ...\r\n    var srcstr = '不要问我从哪里来';\r\n    var base64str = base64.encode(srcstr);\r\n    console.log(base64str);\r\n\r\n输出： 5LiN6KaB6Zeu5oiR5LuO5ZOq6YeM5p2l\r\n\r\n~~~\r\n\r\n# 总结\r\n类似兼容性处理方案：\r\n\r\n1，因为目前微信小程序require机制，，并不容易自定义一个require函数去代替（内存中模块列表对象在闭包之中，不易访问），所以通常做法是修改被加载的js模块。\r\n\r\n2，被微信小程序require初始化时，this指针为空，处理避开这类访问。\r\n\r\n3，js模块中,尽可能按module.exports = ... 方式导出对象."}
{"title": "微信小程序- 移动设备的分辨率与rpx ", "author": "Rolan", "pub_time": "2018-2-26 00:15", "content": "表格image.png理解屏幕尺寸：是对角线的距离pt： 逻辑分辨率 只和屏幕尺寸有关系，是长度和视觉的单位 px： 物理分辨率，1个px是一个物理像素点，和屏幕大小没关系，不是一个长度单位Reader：1pt 下包含 Reader 个 px 1个逻辑分辨率下由reader个像素点构成Reader @2X 已经达到人类视网膜的极限，再增加也不会有好的视觉效果PPI：每英寸包含多少个物理像素点 计算公式：勾股定理 分辨率平方开根号/屏幕尺寸总结：Iphone6（现在大部分设计图都是在Iphone6下进行换算的）下2个px构成一个pt如何做不同分辨率设备的自使用？1、以iphone6的物理像素750x1334为视觉稿进行设计，而在小程序中使用rpx为单位 2、iphone6下 1px=1rpx=0.5pt 3、使用rpx，小程序会自动在不同的分辨率下进行转换，而使用px单位则不会为什么要用iphone6的物理分辨率来做设计设计图？ iphone6下 1px = 1rpx (好计算) iphone6 plus下 1px = 0.6rpx"}
{"title": "微信小程序实例--仿豆瓣电影 ", "author": "Rolan", "pub_time": "2017-9-5 00:43", "content": "最近不想写论文，就想捣鼓点新东西吧，就边看官方文档，花了3天时间写了一个简单的仿豆瓣电影的微信小程序，给大家分享一下教程吧。源码&效果图源码点击这里，欢迎star运行方法：下载微信web开发者工具新建项目，项目目录为代码存放目录点击开发者工具中的编译即可在模拟器里看到效果图如下开发环境与项目简介微信提供了一个微信开发者工具，可以完成小程序的 API 和页面的开发调试、代码查看和编辑、小程序预览和发布等功能。下载地址下载后，打开该工具，选择代码目录和申请的AppID，勾选quickStart选项，这样会创建几个基础页面。正好在写代码的第二天，微信开发者工具就全新改版，比原来好多了，原来的console调试界面与编辑代码不在同一个页面，十分麻烦，现在就像平时前端调试一样，调试界面与代码编辑页面在同一个界面，方便多了。项目代码结构这里说一下，在新建目录后，可以选择添加page,js,wxml,wxss,json文件，如果直接添加page文件的话，会直接在该目录下生成与目录相同名字的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js后缀的文件是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。豆瓣电影API【获取正在上映电影】https://api.douban.com/v2/movie/in_theaters【获取豆瓣TOP250电影】https://api.douban.com/v2/movie/top250【 获取即将上映电影】https://api.douban.com/v2/movie/coming_soon【获取具体某一电影信息】https://api.douban.com/v2/movie/subject/:id详细数据情况可看https://developers.douban.com/wiki/?title=movie_v2其实前三个API返回的数据都是一致的，只是返回的电影类型数据不一样而已，所以在list页面，我们只要传入不同的类型即可。在电影列表页和首页，都有展示电影的基础信息（海报，名字，评分），所以可以把这个部分拿出来做一个模板公用。大体的思路就是这样，比较简单。配置小程序窗口和导航栏在根目录下的app.json文件中配置小程序的窗口样式和导航栏属性信息如图，来自官网点击上方的“编译”，就可以看到效果我们在调试具体某一个页面的时候，可以添加面板上方中间的”添加编译模式”，填写相关参数，这样就不用从首页进去调试了。具体代码编写这里只讲一下首页代码的情况，其他页面用到的属性基本雷同。这里不介绍小程序的使用语法，请先在官网上浏览个大概wx.showLoading()在最开始进入页面时，还没加载完数据时，我们想要有一个loading效果，可直接使用小程序的apiwx.showLoading(OBJECT)显示 loading 提示框, 需主动调用 wx.hideLoading 才能关闭提示框123456onLoad: function () {    wx.showLoading({      title: '全力加载中...',    })   }加载完，需要关闭时，就只需要调用即可wx.hideLoading();onLoad 表示监听页面加载wx.request()请求数据调用wx.request();详细属性介绍点击这里因为请求电影列表在list和index页面都需要用到，所以我在app.js作为一个全局的方法来写12345678910111213141516171819getFilminfo:function(pageType,start,count,cb) {//电影列表类型，开始数据下标，请求总数，callback函数    var that = this;    wx.request({      url: that.globalData.basicUrl +\"/\" + pageType + '?start=' + start + '&count=' + count,      // url:url,      header: {        \"Content-Type\": \"json\",      },      success: function (res) {        cb(res);      }    })   },  globalData: {    userInfo: null,    basicUrl:\"https://api.douban.com/v2/movie\",    pageTypelist: {\"coming_soon\":\"即将上映\",\"in_theaters\":\"正在热映\",\"top250\":\"TOP250电影\"}  }然而，在调用接口的时候发现了这样的错误原因是我在开发配置里，没有豆瓣api的域名添加到request合法域名里，所以只要在配置里加上需要的即可所以在index.js中，调用这个全局方法如下：12//获取应用实例var app = getApp()123456789101112131415161718192021222324252627282930313233343536373839Page({  data: {    motto: 'Hello World',    userInfo: {},    films:[{},{},{}]  },  onLoad: function () {    wx.showLoading({      title: '全力加载中...',    })    console.log('onLoad')    var that = this;    var typelist = [\"in_theaters\",\"coming_soon\",\"top250\"];    var titlelist = [\"正在热映\",\"即将上映\", \"TOP250电影\"];    for(let i = 0;i<typelist.length;i++){      var type = typelist[i];      app.getFilminfo(type, 0, 8, function (res) {        wx.hideLoading();        var data = res.data;        data.subjects.map(function (item) {          if (item.title.length > 8) {            item.title = item.title.slice(0, 7) + \"...\";          }          if (item.rating.average>=9.5){            item.rating.star = \"star10\";          }else{            item.rating.star = \"star\" + Math.round(item.rating.average);          }          console.log(item.rating.star);        })        that.data.films[i] = {title:titlelist[i],data:data.subjects,type:typelist[i]};        that.setData({          films: that.data.films        });        console.log(that.data.films);      })    }  }})我们通过“更多”按钮跳转到对应的电影列表list页面，所以需要绑定事件在index.wxml中，1<button bindtap=\"toView\" data-type=\"{{filminfo.type}}\" class=\"more-btn\" plain=\"false\">更多></button>bindtap就是对应是事件名字，同时我们需要设置data-type属性，属性值即是电影列表类型在index.js中123456toView: function(e) {    var temp = e.currentTarget.dataset;//获取当前组件上由data-开头的自定义属性组成的集合    wx.navigateTo({      url: '../list/list?type=' + temp.type//temp.type即是当时data-type属性值    })  },wx.navigateTo(）就是路由跳转的api模板因为电影的基础信息展示在多个页面中都有用到，我们单独提出来写个电影预览模板1234567891011<template name=\"movieThumb\">  <view wx:key=\"id\" class=\"film-item\" data-title=\"{{title}}\" data-id=\"{{id}}\"  bindtap=\"detail\">  <image src=\"{{images.medium}}\" alt=\"{{alt}}\" class=\"film-image\"></image>    <text class=\"film-title\">{{title}}</text>    <view class=\"film-rate\" wx:if=\"{{rating.average!=0}}\">    <view class=\"film-star {{rating.star}}\"></view>    <text>{{rating.average}}</text>  </view>  <text class=\"film-rate\" wx:else>暂无评分</text>  </view></template>模板名字设置为“movieThumb”例如在首页中有用到该模块，那在index.wxml中如下调用即可123456<import src=\"../template/movieThumb.wxml\" />  <scroll-view scroll-x=\"true\" class=\"filmlist\">        <template is=\"movieThumb\" wx:for-items=\"{{filminfo.data}}\"  wx:for-item=\"film\" wx:key=\"id\" data=\"{{...film}}\">           </template></scroll-view>先写到这里吧，其他代码看github上的即可，具体还是要多看文档，写个项目练练，就很容易上手啦！"}
{"title": "eweapp：ECShop非官方版微信小程序商城 ", "author": "Rolan", "pub_time": "2017-8-12 00:38", "content": "eweapp\r\nECShop非官方版微信小程序商城，基于3.6版本appserver接口，100%兼容原有程序，没有对原有程序代码进行过任何改动。\r\nGitHub\r\nhttps://github.com/tumobi/eweapp\r\n功能列表\r\n\r\n首页： 轮播图、商城滚动公告、精品推荐、新品上市、销量排行\r\n分类：商品搜索功能、全部一级二级分类展示\r\n购物车\r\n我的：退出登录功能、用户信息显示、订单统计\r\n商品列表：排序功能、底部加载更多商品\r\n商品详情\r\n登录：用户名或邮箱登录\r\n其它功能正在开发中...\r\n\r\n界面预览\r\n首页\r\n\r\n我的"}
{"title": "微信小程序--实现密码加密 ", "author": "Rolan", "pub_time": "2017-7-5 00:27", "content": "在utils中的util.js 文件中增加 函数 实现 字符串转换为16进制加密后的字符串function encodeUTF8(s) {  var i, r = [], c, x;  for (i = 0; i < s.length; i++)    if ((c = s.charCodeAt(i)) < 0x80) r.push(c);    else if (c < 0x800) r.push(0xC0 + (c >> 6 & 0x1F), 0x80 + (c & 0x3F));    else {      if ((x = c ^ 0xD800) >> 10 == 0) //对四字节UTF-16转换为Unicode        c = (x << 10) + (s.charCodeAt(++i) ^ 0xDC00) + 0x10000,          r.push(0xF0 + (c >> 18 & 0x7), 0x80 + (c >> 12 & 0x3F));      else r.push(0xE0 + (c >> 12 & 0xF));      r.push(0x80 + (c >> 6 & 0x3F), 0x80 + (c & 0x3F));    };  return r;};// 字符串加密成 hex 字符串function sha1(s) {  var data = new Uint8Array(encodeUTF8(s))  var i, j, t;  var l = ((data.length + 8) >>> 6 << 4) + 16, s = new Uint8Array(l << 2);  s.set(new Uint8Array(data.buffer)), s = new Uint32Array(s.buffer);  for (t = new DataView(s.buffer), i = 0; i < l; i++)s[i] = t.getUint32(i << 2);  s[data.length >> 2] |= 0x80 << (24 - (data.length & 3) * 8);  s[l - 1] = data.length << 3;  var w = [], f = [    function () { return m[1] & m[2] | ~m[1] & m[3]; },    function () { return m[1] ^ m[2] ^ m[3]; },    function () { return m[1] & m[2] | m[1] & m[3] | m[2] & m[3]; },    function () { return m[1] ^ m[2] ^ m[3]; }  ], rol = function (n, c) { return n << c | n >>> (32 - c); },    k = [1518500249, 1859775393, -1894007588, -899497514],    m = [1732584193, -271733879, null, null, -1009589776];  m[2] = ~m[0], m[3] = ~m[1];  for (i = 0; i < s.length; i += 16) {    var o = m.slice(0);    for (j = 0; j < 80; j++)      w[j] = j < 16 ? s[i + j] : rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1),        t = rol(m[0], 5) + f[j / 20 | 0]() + m[4] + w[j] + k[j / 20 | 0] | 0,        m[1] = rol(m[1], 30), m.pop(), m.unshift(t);    for (j = 0; j < 5; j++)m[j] = m[j] + o[j] | 0;  };  t = new DataView(new Uint32Array(m).buffer);  for (var i = 0; i < 5; i++)m[i] = t.getUint32(i << 2);  var hex = Array.prototype.map.call(new Uint8Array(new Uint32Array(m).buffer), function (e) {    return (e < 16 ? \"0\" : \"\") + e.toString(16);  }).join(\"\");  return hex;};导出函数module.exports = {  formatTime: formatTime,  sha1:sha1}这样就可以在其他页面中调用了var util = require('../../utils/util.js')util.sha1(\"123456\")以 密码为 123456 作为示例，在线加密结果小程序中调用结果 加密结果是相同的"}
{"title": "微信小程序-输入密码 ", "author": "Rolan", "pub_time": "2017-12-26 00:26", "content": "wxml\r\n<view wx:if=\"{{wallets_password_flag}}\" class=\"wallets-password\"><view class=\"input-content-wrap\"><view class=\"top\"><view catchtap=\"close_wallets_password\" class=\"close\">×view><view class=\"txt\">请输入支付密码view><view catchtap=\"modify_password\" class=\"forget\">忘记密码view>view><view class=\"actual_fee\"><span>￥span><text>{{actual_fee/100}}text>view><view catchtap=\"set_Focus\" class=\"input-password-wrap\"><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=1}}\">i>view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=2}}\">i>view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=3}}\">i>view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=4}}\">i>view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=5}}\">i>view><view class=\"password_dot\"><i wx:if=\"{{wallets_password.length>=6}}\">i>view>view>view><input bindinput=\"set_wallets_password\" class=\"input-content\" password type=\"number\" focus=\"{{isFocus}}\" maxlength=\"6\" />view>\r\nwxss\r\npage .wallets-password {position: absolute;left: 0;top: 0;width: 100%;height: 100%;background: rgba(0, 0, 0, 0.6);}page .wallets-password .input-content-wrap {position: absolute;top: 200rpx;left: 50%;display: flex;flex-direction: column;width: 600rpx;margin-left: -300rpx;background: #fff;border-radius: 20rpx;}page .wallets-password .input-content-wrap .top {display: flex;align-items: center;height: 90rpx;border-bottom: 2rpx solid #ddd;justify-content: space-around;}page .wallets-password .input-content-wrap .top .close {font-size: 44rpx;color: #999;font-weight: 100;}page .wallets-password .input-content-wrap .top .forget {color: #00a2ff;font-size: 22rpx;}page .wallets-password .input-content-wrap .actual_fee {display: flex;align-items: center;justify-content: center;color: #000;height: 100rpx;margin: 0 23rpx;border-bottom: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .actual_fee span {font-size: 24rpx;}page .wallets-password .input-content-wrap .actual_fee text {font-size: 36rpx;}page .wallets-password .input-content-wrap .input-password-wrap {display: flex;align-items: center;justify-content: center;height: 150rpx;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot {display: flex;align-items: center;justify-content: center;text-align: center;color: #000;box-sizing: border-box;width: 90rpx;height: 90rpx;border: 2rpx solid #ddd;border-left: none 0;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot:nth-child(1) {border-left: 2rpx solid #ddd;}page .wallets-password .input-content-wrap .input-password-wrap .password_dot i {background: #000;border-radius: 50%;width: 20rpx;height: 20rpx;}page .wallets-password .input-content {position: absolute;opacity: 0;left: -100%;top: 600rpx;background: #f56;z-index: -999;}page .wallets-password .input-content.active {z-index: -99;}\r\nwxjs\r\ndata: {payment_mode: 1,//默认支付方式 微信支付isFocus: false,//控制input 聚焦balance:100,//余额actual_fee:20,//待支付wallets_password_flag:false//密码输入遮罩},set_wallets_password(e) {//获取钱包密码this.setData({wallets_password: e.detail.value});if (this.data.wallets_password.length == 6) {//密码长度6位时，自动验证钱包支付结果wallet_pay(this)}},set_Focus() {//聚焦inputconsole.log('isFocus', this.data.isFocus)this.setData({isFocus: true})},set_notFocus() {//失去焦点this.setData({isFocus: false})},close_wallets_password () {//关闭钱包输入密码遮罩this.setData({isFocus: false,//失去焦点wallets_password_flag: false,})},pay() {//去支付pay(this)}})/*-----------------------------------------------*//*支付*/function pay(_this) {let apikey = _this.data.apikey;let id = _this.data.id;let payment_mode = _this.data.payment_modeif (payment_mode == 1) {// 微信支付// 微信自带密码输入框console.log('微信支付')} else if (payment_mode == 0) {// 转账支付 后续跳转至传转账单照片console.log('转账支付')}"}
{"title": "微信小程序中如何使用wxParse解析html ", "author": "Rolan", "pub_time": "2017-6-16 00:38", "content": "最近项目上遇到在微信小程序里需要显示新闻内容，新闻内容是通过接口读取的服务器中的富文本内容，是html格式的，小程序默认是不支持html格式的内容显示的，那我们需要显示html内容的时候，就可以通过wxParse来实现。准备工作：首先我们下载wxParsegithub地址：https://github.com/icindy/wxParse下载完之后我们需要用到目录下的wxParse文件夹，把他拷贝到我们的项目目录下下面是具体的使用步骤1、在app.wxss全局样式文件中，需要引入wxParse的样式表2、在需要加载html内容的页面对应的js文件里引入wxParse这里需要说明一下，我们先看网上说的，以下是截图：这种做法，是针对当前页面只有资讯详细信息，没有其他内容，比如：标题，日期，缩略图等等。如果需要运用自己的布局，可以这样做，如图：3、引入js并加载数据下面我们来简单的说一下wxParse参数说明* WxParse.wxParse(bindName , type, data, target,imagePadding)* 1.bindName绑定的数据名(必填)* 2.type可以为html或者md(必填)* 3.data为传入的具体数据(必填)* 4.target为Page对象,一般为this(必填)* 5.imagePadding为当图片自适应是左右的单一padding(默认为0,可选)总结以上就是这篇文章的全部内容了，希望本文的内容对大家的学习或者工作能带来一定的帮助，如果有疑问大家可以留言交流，谢谢大家对我们的支持。"}
{"title": "微信小程序开发实例--仿麦当劳微信小程序 ", "author": "Rolan", "pub_time": "2017-7-15 00:57", "content": "学习使我happy!!!作为全栈的学习者，初学微信小程序，抱着试试做心态，一个星期内初步完成了这个项目。小程序是何方神圣？  小程序是一种新的开放能力，开发者可以快速地开发一个小程序。小程序可以在微信内被便捷地获取和传播，同时具有出色的使用体验。为什么选择它？用户可便捷地获取服务，无需安装或下载即可使用具有更丰富的功能和出色的使用体验封装一系列接口能力，帮助快速开发和迭代切身体验，你也可以来！小程序对于新手来说，是很容易上手的，需要你用几天时间去熟悉小程序的构建过程和说明文档，你就可以初步做出一个比较完整的小程序。 我觉得小程序最屌地方还是rpx，使得小程序有很大的兼容性，在页面布局使用这个属性，可以适应不同的手机，这也使得我们降低工作量。而且小程序是一个不需要下载安装即可使用的应用，而且它的背后是强大的微信，所以，如果我们能够用自己的创造思维去看待这个，你会得到很大的收获O(∩_∩)O哈哈~。项目工具及文档：微信web开发者工具：微信小程序官网 微信开发的小程序编辑软件，下载安装即可使用，不需要去添加什么的；开发文档：微信小程序宝典秘籍 这里面详细的介绍了小程序的各项信息，包括组件、框架、API等等；Easy Mork： easy-mock 小程序后台数据可以在这里模拟，利用json格式；图标库： Iconfont-阿里巴巴矢量图标库 这个是个好东西，以前我总是为找不到图标元素烦恼，但是现在有了它就啥也不怕了。页面注册\"pages\":[\r\n    \"pages/index/index\",   // 主页\r\n    \"pages/happynotice/happynotice\",  //开心通告栏\r\n    \"pages/userinfo/userinfo\",    //个人信息详情>\r\n    \"pages/queryintegral/queryintegral\",  // 积分查询\r\n    \"pages/integralmall/integralmall\", // 积分商城\r\n    \"pages/user/user\",  //个人信息\r\n    \"pages/integraldetail/integraldetail\",   //  优惠券详情\r\n    \"pages/qrcodenull/qrcodenull\", // 请求注册页面\r\n    \"pages/register/register\", // 注册信息页面\r\n    \"pages/qrcode/qrcode\"  //我的二维码\r\n ], \r\n项目功能已实现功能：注册用户信息手机号码验证(这里实现了页面)个人信息修改优惠券信息查看优惠券兑换积分查询开心通告栏未实现功能：麦有礼卡片(这个是刚上线的功能)麦麦同乐会的注册文字页面-常见问题、积分规则...项目GIF部分功能解析1. 获取本地信息在这里我们首先要登录利用wx.login(OBJECT) 必写（不然获取不到用户的信息） 然后利用方法wx.getUserInfo(OBJECT)获取用户信息 //登录的信息创建\r\n    wx.login({\r\n      success: function (e) {\r\n        wx.setStorage({\r\n          key: \"key\",\r\n          data: e.errMsg\r\n        })\r\n      }\r\n    })\r\n    //获取用户的信息\r\n    wx.getUserInfo({\r\n      success: function(res) {\r\n        var userInfo = res.userInfo\r\n        var nickName = userInfo.nickName\r\n        var avatarUrl = userInfo.avatarUrl\r\n        var gender = userInfo.gender //性别 0：未知、1：男、2：女\r\n        var province = userInfo.province\r\n        var sex;\r\n        ...2. 优惠券的显示及页面传值这里我们从easy-mock获取到优惠券的信息并且将信息显示到页面上，我们就利用了wx:for这个控制属性绑定一个数组 这里我们还可以注意这个信息navigator是个跳转页面的属性，在跳转的过程中它可以传值,例如**?url={{item.url}}这里我要穿的是图片地址信息到下个页面。 当然页面传值并不是只是这样方法，还有设置全局的数据缓存**，引入事件订阅和发布onfire.js，这里就不一一介绍了有兴趣可以去Google   <block wx:for=\"{{imgs}}\" wx:key=\"\" class=\"block\" >\r\n    <swiper-item >\r\n        <navigator url=\"/pages/integraldetail/integraldetail?url={{item.url}}&description={{item.description}}&prompt={{item.prompt}}\">\r\n            <image  src=\"{{item.url}}\" class=\"side-img\" />\r\n            <view class=\"check click\">查看详情view>\r\n        navigator>\r\n        <view class=\"exchange click\" bindtap=\"exchangetap\">立即兑换view>\r\n    swiper-item>\r\n\r\n  block>\r\n```    \r\n我们需要在js文件中声明你的的优惠券数据imgs:[]，**注意这里是json格式加','** \r\n```javascript\r\n data: {\r\n    imgs:[],\r\n    modalHidden: true,\r\n  },利用wx.request(OBJECT)发起的是https请求，从easymock中获取数据信息,利用setData()改变imgs得值, 要注意一定要声明var that = this,因为wx:request里面是请求不到当前页面的data的数据信息，我们需要将this的赋值给that。还有一个微信小程序，同时只能有5个网络请求连接。  var that = this;\r\n  wx.request({\r\n      url: \"https://www.easy-mock.com/mock/595f3f139adc231f357b0615/McDonald/list\",\r\n      method: 'GET',\r\n      success: function (res) {\r\n        console.log(res);\r\n        that.setData({\r\n          imgs: res.data.image,\r\n        })\r\n      }\r\n    })3. 星座选择器（这里我踩过坑）表单组件picker支持三种选择器，通过mode来区分，分别是普通选择器，时间选择器，日期选择器，这里我们选择的是普通选择器。range是显示的数组，只有声明mode为selector这个才能实现；value表示选择的第几个（由0开始）；bindchange是触发事件<view class=\"userdata-name\">星座view>\r\n      <view class=\"userdata-symbol\">view>\r\n      <picker mode=\"selector\" class=\"userdata-input\" range=\"{{actionConItems}}\" value=\"{{conIndex}}\" bindchange=\"pickerConSelected\">\r\n           <text>{{actionConItems[conIndex]}}text>\r\n      picker>\r\n view>      从微信端获取的个人信息放在本地利用wx.setStorageSync(\"key\", '')存储特定的信息，picker到的星座就可以利用这个方法，放到本地。 data: {    \r\n    actionConItems: ['白羊座','金牛座','双子座','巨蟹座','狮子座','处女座','天秤座','天蝎座','射手座','摩羯座','水瓶座','双鱼座'],\r\n    conIndex: 0,\r\n  },\r\n  \r\n    //星座弹出窗口  可以将数据放在本地setStorage\r\n  pickerConSelected: function (e) {\r\n     console.log('picker发送选择改变，星座为' + e.detail.value);\r\n      wx.setStorageSync(\"con\", e.detail.value);\r\n      this.setData({\r\n             conIndex: e.detail.value,\r\n             btnColor: \"#ffc324\",\r\n      });\r\n  },踩过的坑...开始对文档不熟悉，导致自己走了很多的弯路，例如啊，我做星座选择器的时候就不知道picker这个组件，而去使用了action-sheet，因为action-sheet里面的数据不能超过6项，我们都知道啊有12星座，所以我在这里卡了一段时间，后面详细了看了下文档才解决了问题。所以在你开发小程序时候，你应该对小程序的文档有个详细的了解。微信小程序的编译包是不能超过2M的，开始你可能不知道将自己的图片放在云端得到API，你尽可能将你的图片压缩小点来，我开发的时候编译包就超过了2M。 目前小程序还有很多的限制，需要去申请合法的域名等等之类的啊，不过相信后面微信团队会逐渐放开这些限制。目前我最擅长的也就是切页面，切页面...由于之间不知道弹性布局，页面总显得不那么整齐。display:flex这里有它的详细说明，快来点我哦这个可以完美解决我的问题，妈妈再也不会担心我的图片文字同时居中了。作为处女座男生，可能有那么一丢丢的强迫症，就是特别想做的完美，一直在改图片的样式，字体样式...这也有好处，当然坏处也不少╮(╯▽╰)╭项目地址：https://github.com/wuyuanlijie/iMcDonald-master"}
{"title": "微信小程序闭包问题引发的JS闭包解决方案 ", "author": "天下雪", "pub_time": "2017-4-14 00:05", "content": "作者：虫哥写代码，来自原文地址看到标题“闭包”很多人会觉得懵逼包括我在内，之前对闭包有所听闻但始终无法准确全面的了解。对于前端同学无论在面试还是在开发，都逃不过关于闭包的问题。最近小程序项目中遇到变量访问权限的问题一时间没考虑到闭包，郁闷了，在此感谢@Topqiang给我指点。本文阅读一遍不一定能够理解掌握，需要反复推敲和练习，有疑问欢迎随时在下方评论。在网上搜索学习关于闭包的技术时发现讲的都比较抽象【我是菜鸟】，不好理解闭包的概念以及使用方法。今天我们带着疑问去学习：首先我给大家还原一下需求场景；对需求场景进行分析；引入闭包解决方案；升华闭包概念理解。废话少说直接步入正题。还原需求场景我要实现一个未知的多对多的数据请求并加载到页面中，由于后端接口限制，不支持多对多的同步返回，需要前端去做数据匹配处理。下面来看看这种需求场景下，小程序前端代码是什么样子按照常规双层for循环逻辑来理解是没有问题的，内层访问外层变量去遍历list需求场景分析这种需求下有同学会考虑后台将双层数据处理后返回给前端，但是如果后端考虑业务功能的解耦不做此操作，我们还是要解决这个问题。亲测单纯的双层for循环中内层访问外层变量是Ok的，加入wx.request过后内层将无法正常访问外层循环变量 i 。如果外层数据res.data的长度为3，那么i在外层for循环中正常遍历为：0、1、2；但是在内层for循环中遍历 i 的数据为：3、3、3，这个时候我对showdata.data赋值无法拿到完整的数据，而只能拿到最后一遍遍历出的数据。分析到这里我们的目的就明确了，要想在内层wx.request中的for循环中得到外层变量 i ，怎么实现呢？闭包解决方案JS闭包可以很轻松的解决内层访问外层存活的私有变量。下面给出3种解决方案，仅供参考。方案一：增加若干个对应的闭包域空间(这里采用的是匿名函数),专门用来存储原先需要引用的内容(下标),不过只限于基本类型(基本类型值传递,对象类型引用传递)方案二：增加若干个对应的闭包域空间用来存储下标，将事件绑定在新增的匿名函数返回的函数上方案三：使用ES6新语法 let 关键字：块作用域，不能重复声明覆盖，限制了变量的作用域，保证变量不会去污染全局变量网上针对javascript解决闭包的方案还有很多，有兴趣的朋友可以深入了解。看了这么多内容不知道大家是否对微信小程序闭包有所了解。网上针对微信小程序闭包代码搜索最多的是下图：升华闭包概念闭包到底是什么？官方的解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分，闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。了解JS闭包之前我们回忆一下变量的作用域。javascript特殊的作用域函数内部变量访问全局变量，函数外部无法获取函数内的局部变量。函数内部声明变量要用var，不用var则声明全局变量。Javascript语言的“链式作用域”结构（chain scope）导致子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的。闭包也就是将函数内部和函数外部连接起来的中介。作用和应用场景闭包可以读取函数内部的变量，也可以让这些变量的值始终保持在内存中。在内存中维持一个变量。通过保护变量的安全实现JS私有属性和私有方法（不能被外部访问）私有属性和方法在Constructor外是无法被访问的【本文涉及的场景】闭包的注意点1、由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。"}
{"title": "微信小程序 App全局变量 保存 修改 读取，滑动删除 ", "author": "天下雪", "pub_time": "2017-4-30 00:14", "content": "一：App全局变量 保存 修改 读取分享者：小春，原文地址 app.jsvar userState = {    isLogin: false,    userInfo: {        nickName: \"登录过期\",        avatarUrl: \"/pages/images/loginLogo.png\"    },    identity: \"\",    status: -2}App({    onLaunch: function () {        console.log(\"--onLaunch------------------------\")    }, onHide: function () {        //console.log(\"--onHide------------------------\")    }, onShow() {        console.log(\"--onShow-----------------------\")        wx.checkSession({            success: function () {                //读取本地userState                 userState = wx.getStorageSync('StorageUserState') || userState;            }, fail: function () {            }        })    },    getUserState:function(){        return userState    },    setUserState:function(state){赞赏 \n                             \n                 \n                邀请 \n               \n               \n               \n            \n             \n                         \n              \r\n\r\n\r\n\r\n\r\n                鲜花                (1)\r\n\r\n\r\n\r\n\r\n\r\n\r\n                鸡蛋                \r\n\r\n\r\n\r\n\r\nfunction errorhandle_clickhandle(message, values) {\r\nif(values['id']) {\r\nshowCreditPrompt();\r\nshow_click(values['idtype'], values['id'], values['clickid']);\r\n}\r\n}\r\n\r\n\r\n\r\n刚表态过的朋友 (1 人)\r\n\r\n\r\n\r\n\r\n天下钞票\r\n\r\n\r\n\r\n\r\n \n            \n            \n\n分享至 :\n\n\nQQ空间\n\nwindow._bd_share_config={\"common\":{\"bdSnsKey\":{},\"bdText\":\"\",\"bdMini\":\"2\",\"bdMiniList\":false,\"bdPic\":\"\",\"bdStyle\":\"0\",\"bdSize\":\"16\"},\"share\":{},\"image\":{\"viewList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"],\"viewText\":\"分享到：\",\"viewSize\":\"16\"},\"selectShare\":{\"bdContainerClass\":null,\"bdSelectMiniList\":[\"qzone\",\"tsina\",\"tqq\",\"renren\",\"weixin\"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];\n\n收藏\n\n             \n                         \n              微信小程序this报错，后台音乐播放注意事项 \n              微信小程序动态显示和隐藏某个控件 \n            \n             \n            \n                   \n                   \n                   \n                   \n                              \n            \r\n    /*700*200 创建于 2017/12/12*/\r\n    var cpro_id = \"u3158955\";\r\n\r\n \n            \n                        \n              \n                相关阅读\n              \n              \n                \n                                    \n                  • 微信小程序全局状态管理，并提供Vuex的开发体验\n                                    \n                  • 小程序实现长按删除图片\n                                  \n              \n            \n             \n            \n          \n           \n        \n      \n       \n       \n      \r\n   \r\n    0 条回复\r\n  \r\n   \r\n    \r\n     \r\n     \r\n    \r\n        \r\n      \r\n  \r\n\r\n        \r\n    \r\n     \r\n\r\n\r\n\r\n\r\n\r\n                \r\n\r\n\r\n\t\t\r\nupdateseccode('cSF15Q4d', '<sec> <span id=\"sec<hash>\" onclick=\"showMenu(this.id);\"><sec></span><div id=\"sec<hash>_menu\" class=\"p_pop p_opt\" style=\"display:none\"><sec></div>', 'portal::view');\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n发表回复\r\n                \r\n\r\n           \r\n    \r\n    \r\n    \r\n    \r\n\r\n   \r\n    \r\n        \r\n    jQuery(function(){\r\njQuery(\"#tedt .pt\").focus(function(){\r\n  jQuery(this).addClass(\"bgchange\");\r\n}).blur(function(){\r\n  jQuery(this).removeClass(\"bgchange\");\r\n});\r\n    });\r\n     \r\n\r\n    \r\n    \r\n \n       \n       \n    \n  \n  \n    \n     \n      \r\n          相关栏目\r\n      \r\n        官方教程后端教程官方问答入门系列官方基础教程新手教程面向新手系列小技巧系列https相关系列实战教程\r\n      \r\n          \r\n新手教程阅读排行\r\n\r\n\r\n微信小程序开发早知道2019-04-04\r\n\r\n \n    \n  \n\n\n\n \n   \n\n\n \njQuery(function() {\njQuery(\"span\").click(function() {\nvar thisEle = jQuery(\"#article_content\").css(\"font-size\");\nvar textFontSize = parseFloat(thisEle, 10);\nvar unit = thisEle.slice( - 2);\nvar cName = jQuery(this).attr(\"class\");\nif (cName == \"bigger\") {\nif (textFontSize <= 22) {\ntextFontSize += 2;\n}\n} else if (cName == \"smaller\") {\nif (textFontSize >= 12) {\ntextFontSize -= 2;\n}\n}\njQuery(\"#article_content\").css(\"font-size\", textFontSize + unit);\n});\n});\n \n \n     \n\n\r\n\r\n\n\n  \n     Copyright © 2016-2017 微信小程序联盟\n         - 鄂ICP备14019861号-2         \n        \r\nvar _hmt = _hmt || [];\r\n(function() {\r\n  var hm = document.createElement(\"script\");\r\n  hm.src = \"//hm.baidu.com/hm.js?c3e02db653db36da2f23ce021891217b\";\r\n  var s = document.getElementsByTagName(\"script\")[0]; \r\n  s.parentNode.insertBefore(hm, s);\r\n})();\r\n\r\n\r\n\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-98020757-1', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n\r\n\r\n     \n   \n \n\n \n\n \n \n\n \n\n \n \n \n\n \n \n\n \n \n \n \n \n\n  \n\n\n\n返回顶部\n\n\njQuery.noConflict();\njQuery(function(){\n        //首先将#back-to-top隐藏\n        jQuery(\"#share\").hide();\n        //当滚动条的位置处于距顶部100像素以下时，跳转链接出现，否则消失\n        jQuery(function () {\n            jQuery(window).scroll(function(){\n                if (jQuery(window).scrollTop()>100){\n                    jQuery(\"#share\").fadeIn();\n                }\n                else\n                {\n                    jQuery(\"#share\").fadeOut();\n                }\n            });\n            //当点击跳转链接后，回到页面顶部位置\n            jQuery(\"#totop\").click(function(){\n                jQuery('body,html').animate({scrollTop:0},500);\n                return false;\n            });\n        });\n    }); \n\n\n \n \t\t\t\r\n\t\t\t\r\n\t\t\t\tvar tipsinfo = '9999|X3.2|0.6||0||0|7|1554880738|0756471e9076aa938022121e2c71d718|2';"}
{"title": "微信小程序图片使用示例 ", "author": "Rolan", "pub_time": "2018-5-25 00:35", "content": "小程序官方API:https://developers.weixin.qq.com/miniprogram/dev/component/image.html1：加载本地文件夹图片     <image  src=\"/image/pig.jpg\" mode=\"aspectFill\">       </image>  2:加载服务器图片wxml:    <image  src=\"{{imageUrl}}\" mode=\"aspectFill\">      </image>  js:Page({  data: {    imageUrl: \"http://www.intmote.com/timg.jpg\",  },g 或者直接在wxml写代码：    <image  src=\"http://www.intmote.com/timg.jpg\" mode=\"aspectFill\">      </image>  3：给小程序页面加载一张背景图片方法一： 使用背景图片的时候用网络图片，就是用外链的形式，比如你将这张图片放到你的服务器，如：https://xxxx/xxx.jpg；方法二： 将背景图片使用编码base64进行转换，可以在这个网址进行http://tool.css-js.com/base64.html 转换，如：background-image: url(\"转换后得到的编码文本\")，如果多次使用的话可以将该值设置为全局变量，再在js文件进行引用即可；详见上一篇博客：https://www.jianshu.com/p/61e6e7390f4a90后前端妹子，爱编程，爱运营，爱折腾。 坚持总结工作中遇到的技术问题，坚持记录工作中所所思所见，欢迎大家加入群聊，一起探讨交流。"}
